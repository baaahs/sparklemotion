{"title":"Ben's SparkleMotion Show","patchIds":["xyProjection-patch","darkness-patch","hsb-patch"],"layouts":{"panels":{"backdrops":{"title":"Backdrops"}},"formats":{"default":{"mediaQuery":null,"tabs":[{"type":"Grid","title":"Main","columns":12,"rows":9,"items":[{"controlId":"shaderControls","column":0,"row":0,"width":8,"height":2,"layout":{"columns":1,"rows":1,"matchParent":true,"items":[{"controlId":"vacuity","column":0,"row":0}]}},{"controlId":"shaders","column":0,"row":2,"width":6,"height":7,"layout":{"columns":4,"rows":7,"items":[{"controlId":"squarezzz","column":2,"row":0},{"controlId":"colorPulse","column":0,"row":0},{"controlId":"geometricColorPulse","column":0,"row":1},{"controlId":"complexTrippyShit1","column":1,"row":1},{"controlId":"baaahzebra","column":2,"row":1},{"controlId":"orangeSnowflake","column":1,"row":2},{"controlId":"acidAtTheDisco","column":1,"row":3},{"controlId":"picassoSNightmare","column":0,"row":3},{"controlId":"plasma","column":0,"row":4},{"controlId":"evolutionOfAcid","column":1,"row":4},{"controlId":"wobblyColorGrid","column":2,"row":4},{"controlId":"gadzooks","column":0,"row":5},{"controlId":"gaiaSOrgasm","column":1,"row":5},{"controlId":"faeriePulse","column":2,"row":5},{"controlId":"yasQueen","column":2,"row":6},{"controlId":"geometricSheep","column":0,"row":2},{"controlId":"aquaticFlood","column":2,"row":3},{"controlId":"circularDependency","column":1,"row":6},{"controlId":"redSea","column":0,"row":6},{"controlId":"baaahsLogo","column":2,"row":2},{"controlId":"baaahsEclipse","column":1,"row":0}]}},{"controlId":"effects","column":6,"row":2,"width":2,"height":7,"layout":{"columns":1,"rows":7,"matchParent":true,"items":[{"controlId":"wobble","column":0,"row":0},{"controlId":"sparklez","column":0,"row":1},{"controlId":"heart","column":0,"row":2},{"controlId":"thatSAllFolks","column":0,"row":3},{"controlId":"soundBrightness","column":0,"row":4},{"controlId":"blackout","column":0,"row":5}]}},{"controlId":"globalControls","column":8,"row":5,"width":4,"height":4,"layout":{"columns":4,"rows":2,"matchParent":true,"items":[{"controlId":"brightness","column":0,"row":0},{"controlId":"saturation","column":1,"row":0}]}},{"controlId":"visualizer","column":8,"row":0,"width":4,"height":3},{"controlId":"beatLink","column":8,"row":3,"width":4,"height":2},{"controlId":"none","column":6,"row":9}]}]}}},"shaders":{"xyProjection":{"title":"XY Projection","src":"// XY Projection\n\nstruct ModelInfo {\n    vec3 center;\n    vec3 extents;\n};\nuniform ModelInfo modelInfo;\n\n// @return uv-coordinate\n// @param pixelLocation xyz-coordinate\nvec2 main(vec3 pixelLocation) {\n    vec3 pixelOffset = (pixelLocation - modelInfo.center) / modelInfo.extents + .5;\n    return vec2(1.-pixelOffset.x, pixelOffset.y);\n}"},"darkness":{"title":"Darkness","src":"void main(void) {\n    gl_FragColor = vec4(0., 0., 0., 1.);\n}"},"hsb":{"title":"HSB","src":"// HSB\n\nuniform float brightness; // @@Slider min=0 max=1.25 default=1\nuniform float saturation; // @@Slider min=0 max=1.25 default=1\nuniform float hueShift; // @@Slider min=0 max=2 default=1\n\n// All components are in the range [0‚Ä¶1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// All components are in the range [0‚Ä¶1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// @return color\n// @param inColor color\nvec4 main(vec4 inColor) {\n    vec4 clampedColor = clamp(inColor, 0., 1.);\n    vec3 hsv = rgb2hsv(clampedColor.rgb);\n    hsv.x += hueShift;\n    hsv.y *= saturation;\n    hsv.z *= brightness;\n    return vec4(hsv2rgb(hsv), clampedColor.a);\n}"},"squarezzz":{"title":"[üêë] Squarezzz","src":"// Square pulse thingy optimized for BAAAHS\n// originally based on https://www.shadertoy.com/view/XsBfRW\n\nuniform float time; // @@Time\nuniform vec2 resolution; // @@Resolution\nuniform float speed; // @@Slider default=3.0 min=1.0 max=5.0\n\n\nstruct BeatInfo {\n\tfloat beat;\n\tfloat bpm;\n\tfloat intensity;\n\tfloat confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n/* Returns a value which cycles from 0 to 1 for each beat, with most of the increase occuring near the beat */\nfloat beatIntegral() {\n\tfloat t = mod(beatInfo.beat, 1.);\n\tfloat POWER = 4.; // Adjusts sharpnett of the curve\n\tfloat OFFSET = 0.0; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n\treturn 1. - pow(1. - mod(t + OFFSET, 1.0), POWER);\n}\n\n/* Returns a monotonically increasing time value which with most of the increase occuring near the beat */\nfloat pulsedTime() {\n\tfloat timeAdjustment = beatIntegral() - mod(beatInfo.beat, 1.);\n\treturn speed * 0.87 * (time + .4 * timeAdjustment); // 0.87 keeps it from pausing at the same spot each cycle\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tfloat t = pulsedTime();\n\n\tfloat aspect = resolution.y/resolution.x;\n\tfloat value;\n\tvec2 uv = fragCoord.xy / iResolution.x;\n\tuv -= vec2(0.5, 0.5 * aspect);\n\tuv *= .6;\n\n\tfloat rot = radians(45.0); // radians(45.0*sin(t));\n\tmat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n\n\tuv = m * uv;\n\tuv += vec2(0.5, 0.5 * aspect);\n\tuv.y+=0.5*(1.0 - aspect);\n\tvec2 pos = 10.0 * uv;\n\tvec2 rep = fract(pos);\n\tfloat dist = 2.0*min(min(rep.x, 1.0-rep.x), min(rep.y, 1.0-rep.y));\n\tfloat squareDist = length((floor(pos)+vec2(0.5)) - vec2(5.0) );\n\n\tfloat edge = sin(t-squareDist*0.5)*0.5+0.5;\n\n\tedge = (t-squareDist*0.5)*0.5;\n\tedge = 2.0*fract(edge*0.5);\n\n\tvalue = fract (dist*2.0);\n\tvalue = mix(value, 1.0-value, step(1.0, edge));\n\n\tedge = pow(abs(1.0-edge), 2.0);\n\n\tvalue = smoothstep( edge-0.05, edge, 0.95*value);\n\n\n\tvalue += squareDist*.1;\n\n\tvec4 baseColor = vec4(0.5 + 0.5*cos(t+uv.xyx+vec3(0,2,4)), 1.0);\n\tfragColor = mix(vec4(1.0,1.0,1.0,1.0), baseColor, value);\n\tfragColor.a = 0.25*clamp(value, 0.0, 1.0);\n}\n\n"},"colorPulse":{"title":"[üêë] ColorPulse","src":"// Color pulses sweeping from front to back of the sheep synchronized to the beat\n// Ben Bartlett\n\nuniform float time; // @@Time\nuniform float hueRange; // @@Slider default=0.3 min=0.0 max=1.0\nuniform float pulseSpeed; // @@Slider default=1.0 min=1.0 max=3.0\nuniform bool fromCenter; // @@Switch\nuniform vec2 center; // @@XyPad\n\n\nstruct BeatInfo {\n\tfloat beat;\n\tfloat bpm;\n\tfloat intensity;\n\tfloat confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n/* Returns a value which cycles from 0 to 1 for each beat, with most of the increase occuring near the beat */\nfloat beatIntegral() {\n\tfloat t = mod(beatInfo.beat, 1.);\n\tfloat POWER = 4.; // Adjusts sharpnett of the curve\n\tfloat OFFSET = 0.0; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n\treturn 1. - pow(1. - mod(t + OFFSET, 1.0), POWER);\n}\n\nvec3 hsl2rgb(in vec3 c) {\n\tvec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 hsv2rgb(vec3 c){\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// A pulse from 0 to 1 back to 0 with adjustable ramp and width\nfloat smoothstepPulse(float t) {\n\tfloat riseTime = 0.3;\n\tfloat peakTime = 0.2;\n\treturn smoothstep(0., 1., t / riseTime) - smoothstep(0., 1., (t - peakTime) / riseTime);\n}\n\n// @return color\n// @param uvIn uv-coordinate\nvec4 main(vec2 uvIn) {\n\n\tfloat s = uvIn.x;\n\tif (fromCenter) {\n\t\ts = distance(uvIn, center);\n\t}\n\n\tfloat pulse = smoothstepPulse(mod(beatIntegral() - s / (2.5*pulseSpeed), 1.));\n\n\tfloat H = .2 * time + s * hueRange;\n\tfloat S = .5 + .5 * pulse;\n\tfloat V = .2 + .6 * pulse;\n\n\treturn vec4(hsl2rgb(vec3(H,S,V)), 1.);\n}\n"},"geometricColorPulse":{"title":"[üêë] Geometric ColorPulse","src":"// Make each physical panel a different color and swipe color pulses along the panels\n// Ben Bartlett\n\n// Color pulses sweeping from front to back of the sheep synchronized to the beat\n// Ben Bartlett\n\nuniform float time; // @@Time\nuniform float hueRange; // @@Slider default=0.3 min=0.0 max=1.0\nuniform float cycleSpeed; // @@Slider min=0.0 max=5.0 default=1.0\nuniform float pulseSpeed; // @@Slider default=1.0 min=1.0 max=3.0\n\nstruct FixtureInfo {\n\tvec3 boundaryMin;\n\tvec3 boundaryMax;\n};\nuniform FixtureInfo fixtureInfo; // @@FixtureInfo\n\nint getPanelID(FixtureInfo info) {\n\tfloat idX = (info.boundaryMin.x * (info.boundaryMin.x + info.boundaryMax.x));\n\tfloat idY = (info.boundaryMin.y * (info.boundaryMin.y + info.boundaryMax.y));\n\tfloat idZ = (info.boundaryMin.z * (info.boundaryMin.z + info.boundaryMax.z));\n\tint id = int(idX + idY + idZ);\n\treturn id;\n}\n\nstruct BeatInfo {\n\tfloat beat;\n\tfloat bpm;\n\tfloat intensity;\n\tfloat confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n/* Returns a value which cycles from 0 to 1 for each beat, with most of the increase occuring near the beat */\nfloat beatIntegral() {\n\tfloat t = mod(beatInfo.beat, 1.);\n\tfloat POWER = 4.; // Adjusts sharpness of the curve\n\tfloat OFFSET = 0.0; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n\treturn 1. - pow(1. - mod(t + OFFSET, 1.0), POWER);\n}\n\nvec3 hsl2rgb(in vec3 c) {\n\tvec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 hsv2rgb(vec3 c){\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// A pulse from 0 to 1 back to 0 with adjustable ramp and width\nfloat smoothstepPulse(float t) {\n\tfloat riseTime = 0.3;\n\tfloat peakTime = 0.2;\n\treturn smoothstep(0., 1., t / riseTime) - smoothstep(0., 1., (t - peakTime) / riseTime);\n}\n\n// @return color\n// @param uvIn uv-coordinate\nvec4 main(vec2 uvIn) {\n\n\tint panelID = getPanelID(fixtureInfo);\n\n\tfloat pulse = smoothstepPulse(mod(beatIntegral() - uvIn.x / (2.5*pulseSpeed), 1.));\n\n\tfloat H = .2 * time + hueRange * (uvIn.x + 0.3 * float((panelID % 6)) / 6.);\n\tfloat S = .5 + .5 * pulse;\n\tfloat V = .2 + .6 * pulse;\n\n\treturn vec4(hsl2rgb(vec3(H,S,V)), 1.);\n}\n"},"complexTrippyShit1":{"title":"[üêë] Complex Trippy Shit #1","src":"// Complex Trippy Shit #1\n// Ben Bartlett\n\n#define PI 3.1415926535897932384626433832795\n#define ii vec2(0.0, 1.0)\n\nuniform float time; // @@Time\nuniform vec2 resolution; // @@Resolution\n\n// Complex multiplication\nvec2 cx_mul(vec2 a, vec2 b) {return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }\n// Complex division\nvec2 cx_div(vec2 a, vec2 b) { return vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y))); }\n// Modulus\nfloat cx_abs(vec2 z) { return length(z); }\n// Complex conjugate\nvec2 cx_conj(vec2 z) { return vec2(z.x, -z.y); }\n// Complex argument\nfloat cx_arg(vec2 z) { return atan(z.y, z.x); }\n// Sin cos and exponential for complex numbers\nvec2 cx_sin(vec2 z) { return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y)); }\nvec2 cx_cos(vec2 z) { return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y)); }\nvec2 cx_exp(vec2 z) { return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y)); }\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Complex math library ==========================\nvec2 cx_pow(vec2 z, float n) {\n    float angle = cx_arg(z);\n    float r = length(z);\n    float re = pow(r, n) * cos(n*angle);\n    float im = pow(r, n) * sin(n*angle);\n    return vec2(re, im);\n}\nvec2 cx_log(vec2 z) {\n    float rpart = sqrt((z.x*z.x)+(z.y*z.y));\n    float ipart = atan(z.y,z.x);\n    if (ipart > PI) ipart=ipart-(2.0*PI);\n    return vec2(log(rpart),ipart);\n}\nvec4 domainColoring (vec2 z, vec2 gridSpacing, float saturation, float gridStrength, float magStrength, float linePower) {\n    // Adapted from https://github.com/rreusser/glsl-domain-coloring\n    float carg = cx_arg(z);\n    float cmod = cx_abs(z);\n\n    float rebrt = pow((fract(z.x / gridSpacing.x) - 0.5) * 2.0, 2.);\n    float imbrt = pow((fract(z.y / gridSpacing.y) - 0.5) * 2.0, 2.);\n\n    float grid = 1.0 - (1.0 - rebrt) * (1.0 - imbrt);\n    grid = pow(abs(grid), linePower);\n\n    float circ = (fract(log2(cmod)) - 0.5) * 2.0;\n    circ = pow(abs(circ), linePower) * magStrength;\n\n    vec3 rgb = hsv2rgb(vec3(carg * 0.5 / PI, saturation, 0.5 + 0.5 * saturation - gridStrength * grid));\n    rgb *= (1.0 - circ);\n    rgb += circ * vec3(1.0);\n    return vec4(rgb, 1.0);\n}\n// =============================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.8 * (2. * fragCoord/resolution.xy - 1.);\n    uv *= vec2(16./9., 1.);\n    uv = vec2(-uv[1] - .2, uv[0]);\n\n    // Function is log(1/4 + iz^-3) + 2 exp(it)\n    vec2 fz = cx_log(vec2(.25, 0.0) + cx_pow(uv, -3.)) + 2. * cx_exp(time * ii);\n\n    float refz = fz[0];\n    float imfz = fz[1];\n    float argfz = cx_arg(fz) / (2.*PI);\n    float absfz = cx_abs(fz);\n\n    //float map = sin(refz + imfz) - log(absfz);\n    //float a=2.;\n    //map = pow(absfz, a) / (pow(absfz, a) + 1.);\n\n    fragColor = domainColoring(fz, vec2(1.0, 1.), 0.9, 1., 1., 1.);\n}"},"baaahzebra":{"title":"[üêë] BAAAHZebra","src":"// Cool zebra pattern looking thing that alternates polarity on the beat\n// Ben Bartlett\n\nuniform float time; // @@Time\nuniform float speed; // @@Slider min=0.0 max=10.0 default=5.0\n\nstruct BeatInfo {\n\tfloat beat;\n\tfloat bpm;\n\tfloat intensity;\n\tfloat confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n// @return color\n// @param uv uv-coordinate\nvec4 main(vec2 uv) {\n\tfloat t = time * .01 * speed / 5.0;\n\tvec2 center = vec2(0.,0.);\n\n\tfloat periods = 4.1;\n\tcenter.y+=sin(uv.y*periods + t * 51.);\n\tcenter.x+=cos(uv.x*periods + t);\n\n\tfloat slantyness = 5.0;\n\tcenter.y+=sin(slantyness*(uv.x + uv.y));\n\tcenter.x+=sin(slantyness*(uv.x + uv.y));\n\n\tfloat d = distance(uv,center);\n\tfloat kFreq = 2.5;\n\n\tfloat k = -sin(d*6.283*kFreq - t);\n\tint beat = int(beatInfo.beat);\n\tif (beat % 2 == 0) {\n\t\tk *= -1.;\n\t}\n\n\tfloat e = smoothstep(0., fwidth(k)*1.5, k);\n\treturn vec4(sqrt(max(e, 0.)));\n}"},"orangeSnowflake":{"title":"Orange Snowflake","src":"// Orange Snowflake\n// Modified from http://glslsandbox.com/e#61105.0\n\n/*\n * Original shader from: https://www.shadertoy.com/view/wl3XW8\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.141592\n#define TAU (2.*PI)\n\n// glslsandbox uniforms\nuniform float time; // @@Time\nuniform vec2 resolution; // @@Resolution\nuniform float speed; // @@Slider default=3.0 min=1.0 max=5.0\nuniform float pulsiness; // @@Slider default=3.0 min=1.0 max=5.0\n\n\n\n\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n/* Returns a value which cycles from 0 to 1 for each beat, with most of the increase occuring near the beat */\nfloat beatIntegral() {\n\tfloat t = mod(beatInfo.beat, 1.);\n\tfloat POWER = 4.; // Adjusts sharpnett of the curve\n\tfloat OFFSET = 0.0; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n\treturn 1. - pow(1. - mod(t + OFFSET, 1.0), POWER);\n}\n\n/* Returns a monotonically increasing time value which with most of the increase occuring near the beat */\nfloat pulsedTime() {\n    float timeAdjustment = beatIntegral() - mod(beatInfo.beat, 1.);\n    return speed * .25 * 0.87 * (time + .1 * pulsiness * timeAdjustment); // 0.87 keeps it from pausing at the same spot each cycle\n}\n\n\n\n\n// --------[ Original ShaderToy begins here ]---------- //\n// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me\n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\nfloat t = pulsedTime();\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.4,18.4)))*1245.4);}\n\nmat2 rot (float a)\n{return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat hd (vec2 uv)\n{\n    uv = abs(uv);\n    return max(uv.x, dot(uv, normalize(vec2(1., sqrt(3.)))));\n}\n\nvec4 hgrid (vec2 uv,float detail)\n{\n    uv *= detail;\n    vec2 ga = mod(uv,vec2(1., sqrt(3.)))-vec2(1., sqrt(3.))*0.5;\n    vec2 gb = mod(uv-vec2(1., sqrt(3.))*0.5,vec2(1., sqrt(3.)))-vec2(1., sqrt(3.))*0.5;\n    vec2 guv = (dot(ga,ga)< dot(gb,gb))? ga: gb;\n\n    vec2 gid = uv-guv;\n\n    guv.y = 0.5-hd(guv);\n\n    return vec4(guv,gid);\n}\n\nfloat hexf (vec2 uv)\n{\n    float det = 3.;\n    float s = 0.5;\n    float d = 0.;\n    for (float i=0.; i<3.; i++)\n    {\n        float ratio = i/5.;\n        uv *= rot(TAU/(5.));\n        uv = (mod(i,2.) == 0.) ? vec2(uv.x+t*s,uv.y) : vec2(uv.x,uv.y+t*s);\n        d += step(hgrid(uv, det).y,0.03);\n        s -= 0.1;\n        det ++;\n    }\n    return d;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat fractal (vec3 p)\n{\n    float size = 1.;\n    float d = box(p,vec3(size));\n    for (float i=0.; i<5.; i++)\n    {\n        float ratio = i/5.;\n        p.yz *= rot(t);\n        mo(p.xz, vec2(2.+ratio));\n        mo(p.xy, vec2(0.5+ratio));\n        p.xy *= rot(t+ratio);\n        size -= ratio*1.5;\n        d= stmin(d,box(p,vec3(size)),1., 4.);\n    }\n    return d;\n}\n\nfloat g1 = 0.;\nfloat SDF (vec3 p)\n{\n    float d = fractal(p);\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-resolution.xy)/resolution.y;\n\n    float mask = 1.0;//step(0.3, abs(sin(length(uv)-PI*t))+0.01);\n    float fx = 0.0;//clamp(mix(1.-hexf(uv), hexf(uv), mask),0.,1.);\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(0.,0.,-10.),\n    p = ro,\n    rd = normalize(vec3(uv,1.)),\n    col = vec3(0.);\n\n    float shad = 0.;\n\n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/64.;\n            break;\n        }\n        d *= 0.7+dither*0.1;\n        p += d*rd;\n    }\n\n    col = vec3(2.,length(uv*0.5),0.1)*g1*0.2;\n    col *= (1.-fx);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n"},"acidAtTheDisco":{"title":"Acid at the Disco","src":"// Acid at the Disco\n// Modified from: https://www.shadertoy.com/view/4sfXRB\n\nuniform float time; // @@Time\nuniform vec2 resolution; // @@Resolution\nuniform float speed; // @@Slider default=3.0 min=1.0 max=5.0\nuniform float pulsiness; // @@Slider default=3.0 min=1.0 max=5.0\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\nfloat beatIntegral() {\n    float t = mod(beatInfo.beat, 1.);\n    float POWER = 4.; // Adjusts sharpnett of the curve\n    float OFFSET = 0.0; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n    return 1. - pow(1. - mod(t + OFFSET, 1.0), POWER);\n}\n\nfloat pulsedTime() {\n    float timeAdjustment = beatIntegral() - mod(beatInfo.beat, 1.);\n    return speed * .25 * 0.87 * (time + .1 * pulsiness * timeAdjustment); // 0.87 keeps it from pausing at the same spot each cycle\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / resolution.xy;\n    float t = pulsedTime();\n    float depth = sin(uv.y*2.0+sin(t)*1.5+1.0+sin(uv.x*3.0+t*1.2))*cos(uv.y*2.0+t)+sin((uv.x*3.0+t));\n    float texey = (uv.x-0.5);\n    float xband = sin(sqrt(uv.y/uv.y)*16.0/(depth)+t*3.0);\n    float final = (\n    sin(texey/abs(depth)*32.0+t*16.0+sin(uv.y*uv.x*32.0*sin(depth*3.0)))*(depth)*xband\n    );\n\n\n    fragColor = vec4(-final*abs(sin(t)),(-final*sin(t)*2.0),(final),1.0)*1.5;\n}"},"picassoSNightmare":{"title":"Picasso's Nightmare","src":"// Picasso's Nightmare\n// From http://glslsandbox.com/e#56499\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nconst float n_circles = 800.0;\nconst float max_radius = 1.0;\nconst float min_radius = 0.5;\nconst float seed1 = 69.7;\nconst float seed2 = 82.4;\nconst float seed3 = 62.5;\n\nfloat rand(float x, float seed) {\n    return fract(sin(x) * seed);\n}\n\nfloat randFromTo(float x, float seed, float min, float max){\n\treturn rand(x, seed) * (max - min) + min;\n}\n\nbool drawCircle(vec2 pos, vec2 center, float radius, inout vec3 color) {\n\tvec2 translatedCenter = vec2(sin(time) * randFromTo(center.x, seed1, -1.8, 1.8) + center.x, sin(time) * randFromTo(center.y, seed1, -1., 1.) + center.y);\n\tfloat distance = distance(pos, translatedCenter);\n\tbool ret =  distance <= radius;\n\tif (ret) {\n\t\tfloat m = max (0.2, smoothstep(radius, radius / 3., distance));\n\t\tcolor = vec3(rand(center.x, seed1) * m,rand(center.y, seed2) * m, rand(center.x + center.y, seed3) * m);\n\t}\n\treturn ret;\n}\n\nvoid drawCircles(vec2 pos, float radiusMultiplier, inout vec3 color) {\n\tfor (float i=0.; i<n_circles; i++){\n\t\tif (drawCircle(pos, vec2(randFromTo(i, seed1, -1.8, 1.8), randFromTo(i, seed2, -1., 1.)), randFromTo(i, seed3, min_radius, max_radius) * radiusMultiplier, color)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid main( void ) {\n\tfloat minRes = min(resolution.x, resolution.y);\n\tvec2 pos = (gl_FragCoord.xy * 2. - resolution) / minRes;\n\tfloat radiusMultiplier = abs(sin(time + 4. * (pos.x * pos.y)));\n\tvec3 color = vec3(pos.y, pos.y, pos.y);\n\tdrawCircles(pos, radiusMultiplier, color);\n\tgl_FragColor = vec4(color, 1);\n}\n"},"plasma":{"title":"Plasma","src":"// Based on https://www.shadertoy.com/view/MdBGzK\n\n#define DPII (3.1415926535*2.0)\n\n// 0 -> Blue / Pink\n// 1 -> Blue / Green\n// 2 -> Black / White\n// 3 -> Blue / Teal / Black\n// 4 -> Black / White\nint GetPlasmaIndex(int t)\n{\n\treturn 0;\n}\n\nconst int initialL1[5] = int[5](1000, 1000, 3500, 1000, 1000);\nconst int initialL2[5] = int[5](2000, 2000, 1000, 2000, 2000);\nconst int initialL3[5] = int[5](3000, 4000, 3000, 3000, 3000);\nconst int initialL4[5] = int[5](4000, 4000, 1000, 4000, 4000);\n\nconst int initialK1[5] = int[5](3500, 1500, 3500, 3500, 3500);\nconst int initialK2[5] = int[5](2300, 2300, 3300, 2300, 2300);\nconst int initialK3[5] = int[5](3900, 3900, 2900, 3900, 3900);\nconst int initialK4[5] = int[5](3670, 1670, 2670, 3670, 3670);\n\nint GetC1(int nXOffset0or1, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\n\tint nResult = 0;\n\tif (nXOffset0or1 == 0)\n\t{\n\t\tnResult = initialK1[nPlasmaIndex] + (-3 * t);\n\t}\n\telse\n\t{\n\t\tnResult = initialL1[nPlasmaIndex] + (-1 * t);\n\t}\n\t\n\tfloat fResult = float(nResult);\n\tfResult = mod(fResult, 4096.0);\n\n\tif (fResult < 0.0)\n\t{\n\t\tfResult += 4096.0;\n\t}\n\tnResult = int(fResult);\n\n\treturn nResult;\n}\n\nint GetC2(int nXOffset0or1, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\n\tint nResult = 0;\n\tif (nXOffset0or1 == 0)\n\t{\n\t\tnResult = initialK2[nPlasmaIndex] + (-2 * t);\n\t}\n\telse\n\t{\n\t\tnResult = initialL2[nPlasmaIndex] + (-2 * t);\n\t}\n\t\n\tfloat fResult = float(nResult);\n\tfResult = mod(fResult, 4096.0);\n\n\tif (fResult < 0.0)\n\t{\n\t\tfResult += 4096.0;\n\t}\n\tnResult = int(fResult);\n\n\treturn nResult;\n}\n\nint GetC3(int nXOffset0or1, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\n\tint nResult = 0;\n\tif (nXOffset0or1 == 0)\n\t{\n\t\tnResult = initialK3[nPlasmaIndex] + (1 * t);\n\t}\n\telse\n\t{\n\t\tnResult = initialL3[nPlasmaIndex] + (2 * t);\n\t}\n\t\n\tfloat fResult = float(nResult);\n\tfResult = mod(fResult, 4096.0);\n\n\tif (fResult < 0.0)\n\t{\n\t\tfResult += 4096.0;\n\t}\n\tnResult = int(fResult);\n\n\treturn nResult;\n}\n\nint GetC4(int nXOffset0or1, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\n\tint nResult = 0;\n\tif (nXOffset0or1 == 0)\n\t{\n\t\tnResult = initialK4[nPlasmaIndex] + (2 * t);\n\t}\n\telse\n\t{\n\t\tnResult = initialL4[nPlasmaIndex] + (3 * t);\n\t}\n\t\n\tfloat fResult = float(nResult);\n\tfResult = mod(fResult, 4096.0);\n\n\tif (fResult < 0.0)\n\t{\n\t\tfResult += 4096.0;\n\t}\n\tnResult = int(fResult);\n\n\treturn nResult;\n}\n\nfloat Palette0_GetRed(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = fIndex;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t\ta = 63.0 - a;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 192.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette0_GetGreen(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette0_GetBlue(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = fIndex;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t\ta = 63.0 - a;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 192.0;\n\t\ta = 63.0 - a;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette1_GetRed(float fIndex)\n{\n\t\treturn 0.0;\n\t\t\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = fIndex;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t\ta = 63.0 - a;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 192.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette1_GetGreen(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t}\n\telse\n\t{\n\t\ta = 63.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette1_GetBlue(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 192.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette2_GetRed(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 2.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette2_GetGreen(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 2.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette2_GetBlue(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 2.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette3_GetRed(float fIndex)\n{\n\t\treturn 0.0;\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = fIndex;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = 63.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette3_GetGreen(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette3_GetBlue(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = 63.0;\n\t}\n\telse\n\t{\n\t\ta = 63.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette4_GetRed(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 75.0))\n\t{\n\t\ta = fIndex;\n\t\ta = 63.0 - a * 64.0 / 75.0;\n\t}\n\telse if ((fIndex >= 75.0) && (fIndex < 181.0))\n\t{\n\t\treturn 0.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 181.0;\n\t\ta = (a * 64.0 / 75.0) * 8.0 / 10.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette4_GetGreen(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 75.0))\n\t{\n\t\ta = fIndex;\n\t\ta = 63.0 - a * 64.0 / 75.0;\n\t}\n\telse if ((fIndex >= 75.0) && (fIndex < 181.0))\n\t{\n\t\treturn 0.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 181.0;\n\t\ta = (a * 64.0 / 75.0) * 9.0 / 10.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette4_GetBlue(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 75.0))\n\t{\n\t\ta = fIndex;\n\t\ta = 63.0 - a * 64.0 / 75.0;\n\t}\n\telse if ((fIndex >= 75.0) && (fIndex < 181.0))\n\t{\n\t\treturn 0.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 181.0;\n\t\ta = (a * 64.0 / 75.0);\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette_GetRed(float fIndex, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\tfloat fResult = 0.0;\n\n\tif (nPlasmaIndex == 0)\n\t{\n\t\tfResult = Palette0_GetRed(fIndex);\n\t}\n\telse if (nPlasmaIndex == 1)\n\t{\n\t\tfResult = Palette1_GetRed(fIndex);\n\t}\n\telse if (nPlasmaIndex == 2)\n\t{\n\t\tfResult = Palette2_GetRed(fIndex);\n\t}\n\telse if (nPlasmaIndex == 3)\n\t{\n\t\tfResult = Palette3_GetRed(fIndex);\n\t}\n\telse if (nPlasmaIndex == 4)\n\t{\n\t\tfResult = Palette4_GetRed(fIndex);\n\t}\n\n\treturn fResult;\n}\nfloat Palette_GetGreen(float fIndex, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\tfloat fResult = 0.0;\n\n\tif (nPlasmaIndex == 0)\n\t{\n\t\tfResult = Palette0_GetGreen(fIndex);\n\t}\n\telse if (nPlasmaIndex == 1)\n\t{\n\t\tfResult = Palette1_GetGreen(fIndex);\n\t}\n\telse if (nPlasmaIndex == 2)\n\t{\n\t\tfResult = Palette2_GetGreen(fIndex);\n\t}\n\telse if (nPlasmaIndex == 3)\n\t{\n\t\tfResult = Palette3_GetGreen(fIndex);\n\t}\n\telse if (nPlasmaIndex == 4)\n\t{\n\t\tfResult = Palette4_GetGreen(fIndex);\n\t}\n\n\treturn fResult;\n}\nfloat Palette_GetBlue(float fIndex, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\tfloat fResult = 0.0;\n\n\tif (nPlasmaIndex == 0)\n\t{\n\t\tfResult = Palette0_GetBlue(fIndex);\n\t}\n\telse if (nPlasmaIndex == 1)\n\t{\n\t\tfResult = Palette1_GetBlue(fIndex);\n\t}\n\telse if (nPlasmaIndex == 2)\n\t{\n\t\tfResult = Palette2_GetBlue(fIndex);\n\t}\n\telse if (nPlasmaIndex == 3)\n\t{\n\t\tfResult = Palette3_GetBlue(fIndex);\n\t}\n\telse if (nPlasmaIndex == 4)\n\t{\n\t\tfResult = Palette4_GetBlue(fIndex);\n\t}\n\n\treturn fResult;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// t is an integer frame count.\n\tint t = int(iTime * 60.0);\n\n\t// fPlasmaX is a float from 0 to 319,\n\t// fPlasmaY is a float from 0 to 399.\n\tfloat fPlasmaX = (fragCoord.x / iResolution.x) * 319.0;\n\tfloat fPlasmaY = (fragCoord.y / iResolution.y) * 399.0;\n\tfPlasmaY = 399.0 - fPlasmaY;\n\n\tfloat fRed = 0.0;\n\tfloat fGreen = 0.0;\n\tfloat fBlue = 0.0;\n\n\tfloat fScreenX = fragCoord.x;\n\tfloat fScreenY = fragCoord.y;\n\tfloat ah = 0.0;\n\tfloat ccc = fPlasmaX / 4.0;\n\tfloat fOffset = 0.0;\n\tfloat bx = 0.0;\n\n\tint nXOffset0or1 = int(mod(fScreenX, 2.0));\n\t// On every odd row, toggle the x offset. This causes different plasma constants to be\n\t// read for these pixels, achieving a chequered overlay of two plasmas.\n\tint xor = int(mod(fScreenY, 2.0));\n\tif (xor == 1)\n\t{\n\t\tif (nXOffset0or1 == 0)\n\t\t{\n\t\t\tnXOffset0or1 = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnXOffset0or1 = 0;\n\t\t}\n\t}\n\n\tfloat c1 = float(GetC1(nXOffset0or1, t));\n\tfloat c2 = float(GetC2(nXOffset0or1, t));\n\tfloat c3 = float(GetC3(nXOffset0or1, t));\n\tfloat c4 = float(GetC4(nXOffset0or1, t));\n\n\tfOffset = ((fPlasmaY * 2.0) + (c2 * 2.0) - (ccc * 8.0) + (80.0 * 8.0)) / 2.0;\n\tbx = ((sin(fOffset*DPII/4096.0)*55.0+sin(fOffset*DPII/4096.0*4.0)*5.0+sin(fOffset*DPII/4096.0*17.0)*3.0+64.0)*16.0);\n\n\tfOffset = bx + c1 + (ccc * 8.0);\n\tah = (sin(fOffset*DPII/4096.0)*55.0+sin(fOffset*DPII/4096.0*6.0)*5.0+sin(fOffset*DPII/4096.0*21.0)*4.0+64.0);\n\n\tfOffset = ((fPlasmaY * 2.0) + (c4 * 2.0) + (ccc * 32.0)) / 2.0;\n\tbx = ((sin(fOffset*DPII/4096.0)*55.0+sin(fOffset*DPII/4096.0*5.0)*8.0+sin(fOffset*DPII/4096.0*15.0)*2.0+64.0)*8.0);\n\n\tfOffset = bx + (fPlasmaY * 2.0) + c3 - (ccc * 4.0) + (80.0 * 4.0);\n\tah += (sin(fOffset*DPII/4096.0)*55.0+sin(fOffset*DPII/4096.0*6.0)*5.0+sin(fOffset*DPII/4096.0*21.0)*4.0+64.0);\n\n\tfloat fPaletteIndex = ah;\n\n\tfRed = Palette_GetRed(fPaletteIndex, t);\n\tfGreen = Palette_GetGreen(fPaletteIndex, t);\n\tfBlue = Palette_GetBlue(fPaletteIndex, t);\n\n\tfragColor = vec4(fRed, fGreen, fBlue, 1.0);\n}\n"},"evolutionOfAcid":{"title":"Evolution of Acid","src":"// Evolution of Acid\n// From http://glslsandbox.com/e#45963\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define PI 3.14159265358979323846\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(1.75)-_size*0.75;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 rotate2D(vec2 _st, float _angle, vec2 shift){\n    _st -= 0.5 + shift.x;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5 + shift.y;\n    return _st;\n}\n\nvoid main(void){\n\tvec2 v = (gl_FragCoord.xy - resolution/2.0) / min(resolution.y,resolution.x) * 5.0;\n\tvec2 vv = v; vec2 vvv = v;\n\tfloat tm = (time + 100.)*0.02;\n\tvec2 mspt = (vec2(\n\t\t\tsin(tm)+cos(tm*0.2)+sin(tm*0.5)+cos(tm*-0.4)+sin(tm*1.3),\n\t\t\tcos(tm)+sin(tm*0.1)+cos(tm*0.8)+sin(tm*-1.1)+cos(tm*1.5)\n\t\t\t)+15.0)*0.03;\n\n\n\tvec2 simple = (vec2(sin(tm), cos(tm)) + 1.5) * 0.15;\n\tfloat R = 0.0;\n\tfloat RR = 0.0;\n\tfloat RRR = 0.0;\n\tfloat a = (.6-simple.x)*6.2;\n\tfloat C = cos(a);\n\tfloat S = sin(a);\n\tvec2 xa=vec2(C, -S);\n\tvec2 ya=vec2(S, C);\n\tvec2 shift = vec2( 1.2, 1.62);\n\tfloat Z = 1.0 + simple.y*6.0;\n\tfloat ZZ = 1.0 + (simple.y)*6.2;\n\tfloat ZZZ = 1.0 + (simple.y)*6.9;\n\n\tvec2 b = gl_FragCoord.xy/(resolution);\n\tb = rotate2D(b, PI*Z, 0.05*xa);\n\t//b = vec2(box(b,vec2(1.1),0.95));\n\n\tfor ( int i = 0; i < 25; i++ ){\n\t\tfloat br = dot(b,b);\n\t\tfloat r = dot(v,v);\n\t\tif ( r > sin(tm) + 3.0 )\n\t\t{\n\t\t\tr = (sin(tm) + 3.0)/r ;\n\t\t\tv.x = v.x * r + 0.;\n\t\t\tv.y = v.y * r + 0.;\n\t\t}\n\t\tif ( br > 0.75 )\n\t\t{\n\t\t\tbr = (0.56)/br ;\n\t\t\t//v.x = v.x * r + 0.;\n\t\t\t//v.y = v.y * r + 0.;\n\t\t}\n\n\t\tR *= 1.05;\n\t\tR += br;//b.x;\n\t\tif(i < 24){\n\t\t\tRR *= 1.05;\n\t\t\tRR += br;//b.x;\n\t\t\tif(i <23){\n\t\t\t\tRRR *= 1.05;\n\t\t\t\tRRR += br;//b.x;\n\t\t\t}\n\t\t}\n\n\t\tv = vec2( dot(v, xa), dot(v, ya)) * Z + shift;\n\t\t//b = vec2( dot(b.xy, xa), dot(b.xy, ya)) * Z + shift;\n\t\t//b = rotate2D(vec2( dot(v, xa), dot(v, ya)), PI*Z, ya);\n\t\t//b = vec2( dot(b, xa), dot(b, ya));\n\t\tb = vec2(box(v,vec2(5.),0.9)) + shift * 0.42;\n\t}\n\tfloat c = ((mod(R,2.0)>1.0)?1.0-fract(R):fract(R));\n\tfloat cc = ((mod(RR,2.0)>1.0)?1.0-fract(RR):fract(RR));\n\tfloat ccc = ((mod(RRR,2.0)>1.0)?1.0-fract(RRR):fract(RRR));\n\tgl_FragColor = vec4(ccc,cc,c, 1.0);\n}\n"},"wobblyColorGrid":{"title":"Wobbly Color Grid","src":"// Wobbly Color Grid\n// From http://glslsandbox.com/e#60808.1\n\n//  modded by Mik - v1.1\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//#extension GL_OES_standard_derivatives : enable\n\n//varying vec2 surfacePosition;\nuniform float time; // @@Time\nuniform vec2 center; // @@XyPad\nuniform vec2 resolution; // @@Resolution\n\nvoid main(void){\n\n    float PI = 3.141592;\n    vec2 p = gl_FragCoord.xy/resolution*2.;\n\n    float time = time + length(p)*cos(time/4. - .0001*length(p)*cos(time/PI + .0001*length(p)*cos(time*time/PI)));\n    vec3 color = vec3(0., length(p), 0.);\n\n    float f = 0.0;\n\n    for(float i = 0.0; i < 15.0; i++){\n\n        float s = sin(center.x +time + center.x * i * PI / 10.0) * .85;\n        float c = cos(center.y + time + center.y * i * PI / 10.0) * .93;\n\n        f += 0.001 / (abs(p.x + c / (.35+length(p))) * abs(p.y + s / (.35+length(p)))) / (.5+length(p));\n        color.r += s * 1.0 * PI;\n        color.b += c * 1.0 * PI;\n    }\n\n\n    gl_FragColor = vec4(vec3(f * color), 1.0);\n}"},"gadzooks":{"title":"Gadzooks","src":"// Gadzooks\n// From: http://glslsandbox.com/e#43036.0\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nvoid main( void ) {\n\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    p = p * 2.0 - 1.0;\n    p.x *= resolution.x / resolution.y;\n\n    float col = 0.0;\n\n    //mandelbrote\n    //vec2 z = vec2(0.0, 0.0);\n    //juillaset\n    vec2 z = p;\n    vec2 ms = mouse.xy * 2.0 - 1.0;\n    ms.x *= resolution.x / resolution.y;\n\n    for(int i = 0; i < 5; i++)\n    {\n        //mandelbrote\n        z = vec2(z.x * z.x - z.y * z.y + cos(time) *2.0, 2.0 * z.x * z.y) + ms;\n        //julliaset\n        //z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + P;\n    }\n    col = length(z);\n\n    gl_FragColor = vec4(vec3(z.x, z.y, col), 1.0);\n\n}\n"},"gaiaSOrgasm":{"title":"Gaia's Orgasm","src":"// Gaia's Orgasm\n// From http://glslsandbox.com/e#46597\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n//from https://www.shadertoy.com/view/4dl3zn\n\nvoid main( void ) {\n\n\tvec2 uv = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;\n\tuv.x *=  resolution.x / resolution.y;\n\n    // background\n\tvec3 color = vec3(0.8 + 0.2*uv.y);\n\n    // bubbles\n\tfor( int i=0; i<40; i++ )\n\t{\n        // bubble seeds\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * resolution.x / resolution.y;\n\n        // buble size, position and color\n\t\tfloat rad = 0.1 + 0.5*siz;\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*time*(0.2+0.8*siz),1.0));\n\t\tfloat dis = length( uv - pos );\n\t\tvec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\n\n        // render\n\t\tfloat f = length(uv-pos)/rad;\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\n\t}\n\n    // vigneting\n\tcolor *= sqrt(1.5-0.5*length(uv));\n\n\tgl_FragColor = vec4(color,1.0);\n}\n"},"faeriePulse":{"title":"Faerie Pulse","src":"// F√¶rie Pulse\n// From http://glslsandbox.com/e#46723\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n\nfloat rand(int seed, float ray) {\n  return mod(sin(float(seed)*1.0+ray*1.0)*1.0, 1.0);\n}\n\nmat2 rotate2d(float _angle) {\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n  vec3 uv3 = vec3(sin(time*0.1), uv);\n  vec2 center = resolution / max(resolution.x, resolution.y) * 0.5;\n\n  //float a = rand(5234, uv.x)*6.2+time*5.0*(rand(2534, uv.y)-rand(3545, uv.x));\n  float a = distance(uv, center)*rand(5234, uv.x)-6.2*(rand(2534, uv.y));\n\n  float ac = cos(time*0.1-a);\n  float as = sin(time*0.1+a);\n  uv3 *= mat3(\n  ac, as, 0.0, -as, ac, 0.0, 0.0, 0.0, 1.0);\n  uv.x = uv3.x;\n  uv.y = uv3.y;\n  //uv = rotate2d(time*0.1)*uv;\n  uv = mod(uv, 0.5) * 2.0;\n  //uv.x = cos(time-a);\n  //uv.y = sin(time+a);\n  gl_FragColor = vec4(uv, cos(distance(uv, center)), 1.0);\n}\n"},"yasQueen":{"title":"Yas Queen","src":"// Yas Queen\n// From http://glslsandbox.com/e#46613\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n// EXAMPLE FROM https://www.shadertoy.com/view/lstfRH\n#define PI 3.141592653589793\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvoid main( void ) {\n\n    vec3 col;\n    float x = gl_FragCoord.x + sin(time/PI) * resolution.x / 4.0;\n    float y = gl_FragCoord.y + cos(time/PI) * resolution.y / 2.0;\n    float hue = sin(x / resolution.x) + cos(y / resolution.y) + sin((x + y) / 500.0) + cos(sqrt(x * x + y * y) / 100.0);\n\n    col = hsv2rgb(vec3(hue + time/8.0, 1.0, mod(time, 1000.0)));\n\n    gl_FragColor = vec4(col, 1);\n}\n"},"geometricSheep":{"title":"[üêë] Geometric Sheep","src":"// Make each physical panel a different color and change the colors on the beat\n// Ben Bartlett\n\n/* Minified color palettes library */\nvec4 mix_color(vec4 color1, vec4 color2, float x) { return mix(color1, color2, vec4(x,x,x,x)); }\nvec4 get_color(vec4 colors[11], float x) { int index = int(10.*x); if (index >= 10) { return colors[10]; } else { float remainder = (10. * x) - floor(10.*x); return mix_color(colors[index], colors[index+1], remainder); } }\nvec4 viridis(float x) { return get_color(vec4[11](vec4(0.267004, 0.004874, 0.329415, 1.0), vec4(0.282623, 0.140926, 0.457517, 1.0), vec4(0.253935, 0.265254, 0.529983, 1.0), vec4(0.206756, 0.371758, 0.553117, 1.0), vec4(0.163625, 0.471133, 0.558148, 1.0), vec4(0.127568, 0.566949, 0.550556, 1.0), vec4(0.134692, 0.658636, 0.517649, 1.0), vec4(0.266941, 0.748751, 0.440573, 1.0), vec4(0.477504, 0.821444, 0.318195, 1.0), vec4(0.741388, 0.873449, 0.149561, 1.0), vec4(0.993248, 0.906157, 0.143936, 1.0)), x); }\nvec4 plasma(float x) { return get_color(vec4[11](vec4(0.050383, 0.029803, 0.527975, 1.0), vec4(0.254627, 0.013882, 0.615419, 1.0), vec4(0.417642, 0.000564, 0.65839, 1.0), vec4(0.562738, 0.051545, 0.641509, 1.0), vec4(0.69284, 0.165141, 0.564522, 1.0), vec4(0.798216, 0.280197, 0.469538, 1.0), vec4(0.881443, 0.392529, 0.383229, 1.0), vec4(0.949217, 0.517763, 0.295662, 1.0), vec4(0.98826, 0.652325, 0.211364, 1.0), vec4(0.988648, 0.809579, 0.145357, 1.0), vec4(0.940015, 0.975158, 0.131326, 1.0)), x); }\nvec4 inferno(float x) { return get_color(vec4[11](vec4(0.001462, 0.000466, 0.013866, 1.0), vec4(0.087411, 0.044556, 0.224813, 1.0), vec4(0.258234, 0.038571, 0.406485, 1.0), vec4(0.416331, 0.090203, 0.432943, 1.0), vec4(0.578304, 0.148039, 0.404411, 1.0), vec4(0.735683, 0.215906, 0.330245, 1.0), vec4(0.865006, 0.316822, 0.226055, 1.0), vec4(0.954506, 0.468744, 0.099874, 1.0), vec4(0.987622, 0.64532, 0.039886, 1.0), vec4(0.964394, 0.843848, 0.273391, 1.0), vec4(0.988362, 0.998364, 0.644924, 1.0)), x); }\nvec4 magma(float x) { return get_color(vec4[11](vec4(0.001462, 0.000466, 0.013866, 1.0), vec4(0.078815, 0.054184, 0.211667, 1.0), vec4(0.232077, 0.059889, 0.437695, 1.0), vec4(0.390384, 0.100379, 0.501864, 1.0), vec4(0.550287, 0.161158, 0.505719, 1.0), vec4(0.716387, 0.214982, 0.47529, 1.0), vec4(0.868793, 0.287728, 0.409303, 1.0), vec4(0.967671, 0.439703, 0.35981, 1.0), vec4(0.994738, 0.62435, 0.427397, 1.0), vec4(0.99568, 0.812706, 0.572645, 1.0), vec4(0.987053, 0.991438, 0.749504, 1.0)), x); }\nvec4 spring(float x) { return get_color(vec4[11](vec4(1.0, 0.0, 1.0, 1.0), vec4(1.0, 0.09803921568627451, 0.9019607843137255, 1.0), vec4(1.0, 0.2, 0.8, 1.0), vec4(1.0, 0.2980392156862745, 0.7019607843137254, 1.0), vec4(1.0, 0.4, 0.6, 1.0), vec4(1.0, 0.5019607843137255, 0.4980392156862745, 1.0), vec4(1.0, 0.6, 0.4, 1.0), vec4(1.0, 0.7019607843137254, 0.29803921568627456, 1.0), vec4(1.0, 0.8, 0.19999999999999996, 1.0), vec4(1.0, 0.9019607843137255, 0.0980392156862745, 1.0), vec4(1.0, 1.0, 0.0, 1.0)), x); }\nvec4 summer(float x) { return get_color(vec4[11](vec4(0.0, 0.5, 0.4, 1.0), vec4(0.09803921568627451, 0.5490196078431373, 0.4, 1.0), vec4(0.2, 0.6, 0.4, 1.0), vec4(0.2980392156862745, 0.6490196078431373, 0.4, 1.0), vec4(0.4, 0.7, 0.4, 1.0), vec4(0.5019607843137255, 0.7509803921568627, 0.4, 1.0), vec4(0.6, 0.8, 0.4, 1.0), vec4(0.7019607843137254, 0.8509803921568627, 0.4, 1.0), vec4(0.8, 0.9, 0.4, 1.0), vec4(0.9019607843137255, 0.9509803921568627, 0.4, 1.0), vec4(1.0, 1.0, 0.4, 1.0)), x); }\nvec4 autumn(float x) { return get_color(vec4[11](vec4(1.0, 0.0, 0.0, 1.0), vec4(1.0, 0.09803921568627451, 0.0, 1.0), vec4(1.0, 0.2, 0.0, 1.0), vec4(1.0, 0.2980392156862745, 0.0, 1.0), vec4(1.0, 0.4, 0.0, 1.0), vec4(1.0, 0.5019607843137255, 0.0, 1.0), vec4(1.0, 0.6, 0.0, 1.0), vec4(1.0, 0.7019607843137254, 0.0, 1.0), vec4(1.0, 0.8, 0.0, 1.0), vec4(1.0, 0.9019607843137255, 0.0, 1.0), vec4(1.0, 1.0, 0.0, 1.0)), x); }\nvec4 winter(float x) { return get_color(vec4[11](vec4(0.0, 0.0, 1.0, 1.0), vec4(0.0, 0.09803921568627451, 0.9509803921568627, 1.0), vec4(0.0, 0.2, 0.9, 1.0), vec4(0.0, 0.2980392156862745, 0.8509803921568627, 1.0), vec4(0.0, 0.4, 0.8, 1.0), vec4(0.0, 0.5019607843137255, 0.7490196078431373, 1.0), vec4(0.0, 0.6, 0.7, 1.0), vec4(0.0, 0.7019607843137254, 0.6490196078431373, 1.0), vec4(0.0, 0.8, 0.6, 1.0), vec4(0.0, 0.9019607843137255, 0.5490196078431373, 1.0), vec4(0.0, 1.0, 0.5, 1.0)), x); }\nvec4 cool(float x) { return get_color(vec4[11](vec4(0.0, 1.0, 1.0, 1.0), vec4(0.09803921568627451, 0.9019607843137255, 1.0, 1.0), vec4(0.2, 0.8, 1.0, 1.0), vec4(0.2980392156862745, 0.7019607843137254, 1.0, 1.0), vec4(0.4, 0.6, 1.0, 1.0), vec4(0.5019607843137255, 0.4980392156862745, 1.0, 1.0), vec4(0.6, 0.4, 1.0, 1.0), vec4(0.7019607843137254, 0.29803921568627456, 1.0, 1.0), vec4(0.8, 0.19999999999999996, 1.0, 1.0), vec4(0.9019607843137255, 0.0980392156862745, 1.0, 1.0), vec4(1.0, 0.0, 1.0, 1.0)), x); }\nvec4 hot(float x) { return get_color(vec4[11](vec4(0.0416, 0.0, 0.0, 1.0), vec4(0.2989711013608711, 0.0, 0.0, 1.0), vec4(0.5666370467761772, 0.0, 0.0, 1.0), vec4(0.8240081481370484, 0.0, 0.0, 1.0), vec4(1.0, 0.09166747604035141, 0.0, 1.0), vec4(1.0, 0.359314099938117, 0.0, 1.0), vec4(1.0, 0.6166666229167378, 0.0, 1.0), vec4(1.0, 0.8843132468145034, 0.0, 1.0), vec4(1.0, 1.0, 0.21249921249921258, 1.0), vec4(1.0, 1.0, 0.6139702022054964, 1.0), vec4(1.0, 1.0, 1.0, 1.0)), x); }\nvec4 jet(float x) { return get_color(vec4[11](vec4(0.0, 0.0, 0.5, 1.0), vec4(0.0, 0.0, 0.945632798573975, 1.0), vec4(0.0, 0.3, 1.0, 1.0), vec4(0.0, 0.692156862745098, 1.0, 1.0), vec4(0.16129032258064513, 1.0, 0.8064516129032259, 1.0), vec4(0.4901960784313725, 1.0, 0.4775458570524984, 1.0), vec4(0.8064516129032256, 1.0, 0.16129032258064513, 1.0), vec4(1.0, 0.7705156136528688, 0.0, 1.0), vec4(1.0, 0.40740740740740755, 0.0, 1.0), vec4(0.9456327985739753, 0.029774872912127992, 0.0, 1.0), vec4(0.5, 0.0, 0.0, 1.0)), x); }\n\n\nuniform float time; // @@Time\nuniform float cycleSpeed; // @@Slider min=0.0 max=10.0 default=1.0\nuniform float hueSpread; // @@Slider min=0.0 max=10.0 default=2.0\n\nstruct BeatInfo {\n\tfloat beat;\n\tfloat bpm;\n\tfloat intensity;\n\tfloat confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\nstruct FixtureInfo {\n\tvec3 boundaryMin;\n\tvec3 boundaryMax;\n};\nuniform FixtureInfo fixtureInfo; // @@FixtureInfo\n\nint getPanelID(FixtureInfo info) {\n\tfloat idX = (info.boundaryMin.x * (info.boundaryMin.x + info.boundaryMax.x));\n\tfloat idY = (info.boundaryMin.y * (info.boundaryMin.y + info.boundaryMax.y));\n\tfloat idZ = (info.boundaryMin.z * (info.boundaryMin.z + info.boundaryMax.z));\n\tint id = int(idX + idY + idZ);\n\treturn id;\n}\n\n/* Linearly slide from min to max by varying x from 0 to 1 */\nfloat linear(float min, float max, float x) {\n\treturn min + (max - min) * x;\n}\n\n/* Replace with color palette of your choice */\nvec4 COLOR(float x) {\n\tfloat colorMin = 0.2;\n\tfloat colorMax = 0.8;\n\treturn plasma(linear(colorMin, colorMax, x));\n}\n\n/* Alternate color option: instead of color palettes, pick hsv values and vary to the beat */\nvec3 hsv2rgb(vec3 c){ vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }\nvec4 COLOR_HSV_EVOLVE(float x) {\n\tfloat hue = (cycleSpeed/20. * time) + (0.05 * hueSpread * x);\n\tfloat value = 1.0 - (0.3 * x);\n\treturn vec4(hsv2rgb(vec3( hue, 1.0, value)), 1.0);\n}\n\n// @return color\n// @param uvIn uv-coordinate\nvec4 main(vec2 uvIn) {\n\tint panelID = getPanelID(fixtureInfo);\n\tint colorIndex = (int(beatInfo.beat) + panelID) % 4;\n\tbool use_hsv = true;\n\tif (use_hsv) {\n\t\treturn COLOR_HSV_EVOLVE(0.33 * float(colorIndex));\n\t} else {\n\t\treturn COLOR(0.33 * float(colorIndex));\n\t}\n}\n"},"aquaticFlood":{"title":"Aquatic Flood","src":"// Aquatic Flood\n// From http://glslsandbox.com/e#46102\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n// SPARKLEMOTION GADGET: Beat { \"name\": \"beat\" }\nuniform float sm_beat;\n\nvoid main(void)\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    //uv.x *= resolution.x/resolution.y;\n    float dist = 0.;\n    uv.x = -2.+4.*uv.x;\n    uv.y = -1.+2.*uv.y;\n    // comment the next line to see the fully zoomed out view\n    uv *=pow(.1,4.+cos(.1*time));\n    uv.x += .275015;//;\n    uv.y += .0060445;//\n    //uv /= 5.;\n    //vec4 col =vec4(1.);\n    vec2 z = vec2(0.0);\n\n    float warp_factor = 1.;\n    float time_warp = sm_beat / (1. / warp_factor) - (warp_factor / 2.) + 1.;\n    vec4 beat_flash = vec4(time_warp);\n\n    int trap=0;\n    for(int i = 0; i < 400; i++){\n        if(dot(z,z)>4.){trap = i;break;}\n        dist = min( 1e20, dot(z,z))+cos(float(i)*12.+3.*time);\n        z = mat2(z,-z.y,z.x)*z + uv;\n    }\n    dist = sqrt(dist);\n\tfloat orb = sqrt(float(trap))/64.;\n    gl_FragColor=vec4(0.,log(dist)*sqrt(dist)-orb-orb,log(dist)*sqrt(dist-abs(sin(time))),1.)*beat_flash;\n    //if(orb == 0.){gl_FragColor = vec4(0.);}\n    //gl_FragColor = (orb!=0. ? 1.-orb*vec4(9.,5.,3.,0.):vec4(0.));\n}\n"},"circularDependency":{"title":"Circular Dependency","src":"// Circular Dependency\n// From http://glslsandbox.com/e#56705\n\n/*\n * Original shader from: https://www.shadertoy.com/view/Wtf3zl\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time; // @@Time\nuniform vec2 center; // @@XyPad\nuniform vec2 resolution; // @@Resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/resolution.xy;\n    uv-=.5;\n    uv.x*= resolution.x/resolution.y;\n\n    vec3 col = vec3(0.5);\n    float d =length(uv)*20.;\n    float a = atan(uv.y, uv.x);\n    col.r = smoothstep(0.1, .2, abs(mod(d+time, 2.)-1.));\n\tcol.g = col.r*floor(mod(d*.5+.5+time*.5, 2.));\n    float f = smoothstep(-.1, .1,sin(a*3.+(sin(time*.5)*2.)*d-time));\n    col.rg = mix(1.-col.rg, col.rg, f);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n"},"redSea":{"title":"Red Sea","src":"// Red Sea\n// From http://glslsandbox.com/e#60816.0\n\n/*\n * Original shader from: https://www.shadertoy.com/view/3ty3Wy\n */\n\n// --------[ Original ShaderToy begins here ]---------- //\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n\n// FBM\nfloat fbm (in vec3 p) {\n    float ret = -1.;\n    float freq = 1.;\n    float amp = 1.;\n    for(int i=0; i<8; i++) {\n        float n = cnoise(p*freq+vec3(0,(iTime*.2),0)*2.);\n        ret = ret + n * amp;\n        amp *= .5;\n        freq *= 1.5 + n * .1;\n    }\n    return ret;\n}\n\nfloat f(vec3 p) {\n    float n = fbm(p);\n    return p.y - 1. - exp(n) * .5;\n}\n\n\n\nvec3 calcNormal(vec3 p, float h) // for function f(p)\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*f( p + k.xyy*h ) +\n    k.yyx*f( p + k.yyx*h ) +\n    k.yxy*f( p + k.yxy*h ) +\n    k.xxx*f( p + k.xxx*h ) );\n}\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0, 2, -4);\n    vec3 rd = normalize(vec3(uv, 1.77) + vec3(0,-1.5,0));\n    /*\n    pR(ro.xz, iTime*.1);\n    pR(rd.xz, iTime*.1);\n\t//*/\n    float t = 0., d;\n\n\n    for(int i=0; i<16; i++) {\n        d = f(ro+rd*t);\n        //if(d<0.) break;\n        t+=d;\n    }\n\n    vec3 n = calcNormal(ro+rd*t, t*t*.0004);\n    // Time varying pixel color\n    vec3 col = -n.yyy *n.y * .5 + .5;\n    col *= vec3(8,4,16);\n    col /= t;\n    col = pow(col, vec3(.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"},"baaahsLogo":{"title":"[üêë] BAAAHS Logo","src":"// Basic GLSL construction of the BAAAHS logo -- you can replace primitives in other shaders with this!\n// Ben Bartlett\n\n#define N 5\n#define COORD_SCALE 0.03\n\nuniform float size; // @@Slider default=1 min=0.25 max=2.\nuniform float horizontalScale; // @@Slider default=.7 min=0.25 max=1.\nuniform vec2 center; // @@XyPad\n\nuniform vec2 resolution; // @@Resolution\nuniform float time; // @@Time\n\n\n// For reference -- determines if a point is in a polygon. Since you can't pass dynamically sized arrays, we need one for each component :(\nbool pointInPoly(vec2 point, float scale, vec2 offset, vec2 vertices[N]){\n\tint i, j;\n\tbool c = false;\n\tvec2 pt = (point - offset)/scale;\n\tfor (i = 0, j = N-1; i < N; j = i++) {\n\t\tif ( ((vertices[i].y > pt.y) != (vertices[j].y > pt.y)) &&\n\t\t(pt.x < (vertices[j].x-vertices[i].x) * (pt.y-vertices[i].y) / (vertices[j].y-vertices[i].y) + vertices[i].x) )\n\t\tc = !c;\n\t}\n\treturn c;\n}\n\n// Coordiantes were obtained from image processing using Wolfram Mathematica. Contact Ben for the notebook source code.\nvec2 HEART[187] = vec2[187](vec2(-1.408e1,2.96),vec2(-1.39e1,3.56),vec2(-1.326e1,3.86),vec2(-1.37e1,4.4),vec2(-1.36e1,5.08),vec2(-1.322e1,5.4),vec2(-1.268e1,5.46),vec2(-13,5.92),vec2(-1.292e1,6.52),vec2(-1.242e1,6.92),vec2(-1.174e1,6.84),vec2(-1.198e1,7.4),vec2(-1.174e1,7.98),vec2(-1.126e1,8.22),vec2(-1.054e1,8.02),vec2(-1.058e1,8.66),vec2(-1.012e1,9.14),vec2(-9.6,9.18),vec2(-9.1,8.88),vec2(-9.08,9.42),vec2(-8.62,9.86),vec2(-8,9.86),vec2(-7.54,9.42),vec2(-7.4,9.94),vec2(-6.88,1.028e1),vec2(-6.22,1.014e1),vec2(-5.9,9.56),vec2(-5.46,1.01e1),vec2(-4.78,1.014e1),vec2(-4.42,9.88),vec2(-4.22,9.32),vec2(-3.86,9.8),vec2(-3.2,9.88),vec2(-2.74,9.54),vec2(-2.6,8.88),vec2(-2.02,9.24),vec2(-1.38,9.04),vec2(-1.12,8.6),vec2(-1.14,8.06),vec2(-0.52,8.28),vec2(0,8.02),vec2(0.58,8.16),vec2(1.04,7.96),vec2(1,8.5),vec2(1.28,8.96),vec2(1.98,9.14),vec2(2.54,8.78),vec2(2.52,9.3),vec2(2.98,9.8),vec2(3.6,9.82),vec2(4.12,9.3),vec2(4.22,9.72),vec2(4.62,1.008e1),vec2(5.32,1.006e1),vec2(5.78,9.52),vec2(6.1,1.014e1),vec2(6.74,1.028e1),vec2(7.24,9.98),vec2(7.4,9.44),vec2(7.98,9.92),vec2(8.64,9.82),vec2(8.98,9.4),vec2(8.98,8.88),vec2(9.5,9.24),vec2(1.02e1,9.1),vec2(1.052e1,8.58),vec2(1.046e1,8.04),vec2(1.11e1,8.3),vec2(1.166e1,8.04),vec2(1.188e1,7.38),vec2(1.166e1,6.92),vec2(1.236e1,7),vec2(1.284e1,6.62),vec2(1.294e1,6.06),vec2(1.268e1,5.54),vec2(1.326e1,5.48),vec2(1.368e1,4.92),vec2(1.364e1,4.44),vec2(1.326e1,3.98),vec2(1.378e1,3.82),vec2(1.41e1,3.24),vec2(1.394e1,2.66),vec2(1.34e1,2.36),vec2(1.386e1,2.08),vec2(1.408e1,1.62),vec2(1.388e1,0.94),vec2(1.32e1,0.68),vec2(1.36e1,0.16),vec2(1.356e1,-0.42),vec2(1.322e1,-0.8),vec2(1.262e1,-0.92),vec2(1.302e1,-1.38),vec2(1.294e1,-2.06),vec2(1.244e1,-2.44),vec2(1.188e1,-2.38),vec2(1.212e1,-2.92),vec2(1.198e1,-3.46),vec2(1.152e1,-3.8),vec2(1.094e1,-3.74),vec2(1.114e1,-4.44),vec2(1.08e1,-5.02),vec2(1.036e1,-5.18),vec2(9.86,-5.06),vec2(1.006e1,-5.66),vec2(9.84,-6.16),vec2(9.3,-6.42),vec2(8.72,-6.22),vec2(8.82,-6.92),vec2(8.46,-7.42),vec2(7.88,-7.54),vec2(7.48,-7.38),vec2(7.62,-8),vec2(7.34,-8.48),vec2(6.74,-8.68),vec2(6.26,-8.46),vec2(6.36,-9.14),vec2(5.88,-9.7),vec2(5.34,-9.74),vec2(4.94,-9.48),vec2(4.98,-1.016e1),vec2(4.64,-1.058e1),vec2(4.18,-1.072e1),vec2(3.56,-1.046e1),vec2(3.64,-1.102e1),vec2(3.3,-1.152e1),vec2(2.76,-1.166e1),vec2(2.22,-1.14e1),vec2(2.28,-1.198e1),vec2(1.92,-1.248e1),vec2(1.34,-1.26e1),vec2(0.86,-1.232e1),vec2(0.9,-13),vec2(0.74,-1.328e1),vec2(0.28,-1.354e1),vec2(-0.24,-1.35e1),vec2(-0.6,-1.324e1),vec2(-0.76,-1.242e1),vec2(-1.22,-1.266e1),vec2(-1.84,-1.25e1),vec2(-2.14,-1.204e1),vec2(-2.08,-1.146e1),vec2(-2.62,-1.172e1),vec2(-3.24,-1.152e1),vec2(-3.52,-11),vec2(-3.42,-1.052e1),vec2(-3.9,-1.076e1),vec2(-4.54,-1.062e1),vec2(-4.88,-1.006e1),vec2(-4.8,-9.54),vec2(-5.32,-9.82),vec2(-5.94,-9.64),vec2(-6.24,-9.1),vec2(-6.1,-8.5),vec2(-6.54,-8.74),vec2(-7.18,-8.58),vec2(-7.5,-8.02),vec2(-7.38,-7.44),vec2(-7.82,-7.62),vec2(-8.36,-7.48),vec2(-8.72,-6.88),vec2(-8.56,-6.32),vec2(-9.08,-6.5),vec2(-9.56,-6.36),vec2(-9.94,-5.72),vec2(-9.74,-5.14),vec2(-1.034e1,-5.26),vec2(-1.086e1,-4.96),vec2(-1.104e1,-4.34),vec2(-1.082e1,-3.82),vec2(-1.128e1,-3.92),vec2(-1.168e1,-3.76),vec2(-1.202e1,-3.1),vec2(-1.18e1,-2.48),vec2(-1.242e1,-2.54),vec2(-1.294e1,-2.02),vec2(-1.294e1,-1.46),vec2(-1.256e1,-1.04),vec2(-1.314e1,-0.92),vec2(-1.352e1,-0.46),vec2(-1.352e1,8.0e-2),vec2(-1.31e1,0.54),vec2(-1.382e1,0.78),vec2(-1.406e1,1.5),vec2(-1.382e1,1.98),vec2(-1.336e1,2.22),vec2(-1.386e1,2.46),vec2(-1.406e1,2.94));\nvec2 HEART_MIN_XY = vec2(-70.5, -67.9);\nvec2 HEART_MAX_XY = vec2(70.6, 51.6);\nvec2 FACE[26] = vec2[26](vec2(-5.24,2.5),vec2(-5.18,3.56),vec2(-5.04,3.84),vec2(-4.8,3.88),vec2(-3.58,3.3),vec2(-1.88,2.12),vec2(2.16,2.12),vec2(4.02,3.68),vec2(4.78,4.04),vec2(5.18,4.02),vec2(5.38,3.64),vec2(5.44,2.72),vec2(5.12,0),vec2(2.84,-7.52),vec2(2.7,-8.46),vec2(2.36,-9.22),vec2(1.86,-9.8),vec2(1.14,-1.026e1),vec2(0.46,-1.046e1),vec2(-0.36,-1.044e1),vec2(-1.28,-1.008e1),vec2(-1.88,-9.58),vec2(-2.38,-8.8),vec2(-2.64,-7.5),vec2(-4.76,-0.72),vec2(-5.22,2.48));\nvec2 MOUTH[35] = vec2[35](vec2(-1.66,-6.76),vec2(-1.56,-6.52),vec2(-1.3,-6.58),vec2(-0.32,-7.72),vec2(0.2,-7.86),vec2(0.58,-7.68),vec2(1.4,-6.66),vec2(1.62,-6.52),vec2(1.84,-6.58),vec2(1.82,-6.84),vec2(1.52,-6.98),vec2(1.22,-7.28),vec2(0.3,-8.66),vec2(0.3,-9.18),vec2(0.4,-9.28),vec2(1.14,-9.04),vec2(1.66,-8.64),vec2(1.8,-8.68),vec2(1.78,-8.82),vec2(1.44,-9.2),vec2(0.98,-9.52),vec2(0.42,-9.78),vec2(2.0e-2,-9.84),vec2(-0.86,-9.46),vec2(-1.54,-8.82),vec2(-1.56,-8.68),vec2(-1.44,-8.64),vec2(-1,-8.98),vec2(-0.18,-9.28),vec2(-8.0e-2,-9.16),vec2(-8.0e-2,-8.74),vec2(-0.14,-8.5),vec2(-0.8,-7.54),vec2(-1.26,-7.02),vec2(-1.64,-6.76));\nvec2 EYE_LEFT[10] = vec2[10](vec2(-4.6,2.4),vec2(-4.6,2.72),vec2(-4.46,2.98),vec2(-4.14,3.02),vec2(-3.82,2.8),vec2(-3.48,2.14),vec2(-3.54,1.6),vec2(-4,1.6),vec2(-4.26,1.72),vec2(-4.58,2.38));\nvec2 EYE_RIGHT[10] = vec2[10](vec2(3.64,1.8),vec2(3.72,2.34),vec2(4,2.8),vec2(4.32,3.02),vec2(4.68,2.94),vec2(4.78,2.42),vec2(4.48,1.76),vec2(4.2,1.6),vec2(3.7,1.6),vec2(3.66,1.78));\nvec2 EAR_LEFT[9] = vec2[9](vec2(-1.092e1,6.08),vec2(-1.084e1,6.26),vec2(-1.058e1,6.3),vec2(-7.02,6.24),vec2(-6.94,4.48),vec2(-7.14,4.38),vec2(-7.84,4.42),vec2(-1.078e1,5.88),vec2(-1.09e1,6.06));\nvec2 EAR_RIGHT[10] = vec2[10](vec2(7.22,4.48),vec2(7.42,4.38),vec2(8.12,4.42),vec2(1.106e1,5.88),vec2(1.12e1,6.14),vec2(1.112e1,6.26),vec2(1.086e1,6.3),vec2(7.36,6.28),vec2(7.26,6.18),vec2(7.22,4.5));\n\nbool pointInHeart(vec2 point, float scale, vec2 offset){\n\tint len = 187;\n\tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE);\n\tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((HEART[i].y > p.y) != (HEART[j].y > p.y)) && (p.x < (HEART[j].x-HEART[i].x) * (p.y-HEART[i].y) / (HEART[j].y-HEART[i].y) + HEART[i].x) ) c = !c; }\n\treturn c;\n}\nbool pointInFace(vec2 point, float scale, vec2 offset){\n\tint len = 26;\n\tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE);\n\tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((FACE[i].y > p.y) != (FACE[j].y > p.y)) && (p.x < (FACE[j].x-FACE[i].x) * (p.y-FACE[i].y) / (FACE[j].y-FACE[i].y) + FACE[i].x) ) c = !c; }\n\treturn c;\n}\nbool pointInMouth(vec2 point, float scale, vec2 offset){\n\tint len = 35;\n\tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE);\n\tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((MOUTH[i].y > p.y) != (MOUTH[j].y > p.y)) && (p.x < (MOUTH[j].x-MOUTH[i].x) * (p.y-MOUTH[i].y) / (MOUTH[j].y-MOUTH[i].y) + MOUTH[i].x) ) c = !c; }\n\treturn c;\n}\nbool pointInEyeLeft(vec2 point, float scale, vec2 offset){\n\tint len = 10;\n\tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE);\n\tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EYE_LEFT[i].y > p.y) != (EYE_LEFT[j].y > p.y)) && (p.x < (EYE_LEFT[j].x-EYE_LEFT[i].x) * (p.y-EYE_LEFT[i].y) / (EYE_LEFT[j].y-EYE_LEFT[i].y) + EYE_LEFT[i].x) ) c = !c; }\n\treturn c;\n}\nbool pointInEyeRight(vec2 point, float scale, vec2 offset){\n\tint len = 10;\n\tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE);\n\tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EYE_RIGHT[i].y > p.y) != (EYE_RIGHT[j].y > p.y)) && (p.x < (EYE_RIGHT[j].x-EYE_RIGHT[i].x) * (p.y-EYE_RIGHT[i].y) / (EYE_RIGHT[j].y-EYE_RIGHT[i].y) + EYE_RIGHT[i].x) ) c = !c; }\n\treturn c;\n}\nbool pointInEarLeft(vec2 point, float scale, vec2 offset){\n\tint len = 9;\n\tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE);\n\tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EAR_LEFT[i].y > p.y) != (EAR_LEFT[j].y > p.y)) && (p.x < (EAR_LEFT[j].x-EAR_LEFT[i].x) * (p.y-EAR_LEFT[i].y) / (EAR_LEFT[j].y-EAR_LEFT[i].y) + EAR_LEFT[i].x) ) c = !c; }\n\treturn c;\n}\nbool pointInEarRight(vec2 point, float scale, vec2 offset){\n\tint len = 10;\n\tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE);\n\tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EAR_RIGHT[i].y > p.y) != (EAR_RIGHT[j].y > p.y)) && (p.x < (EAR_RIGHT[j].x-EAR_RIGHT[i].x) * (p.y-EAR_RIGHT[i].y) / (EAR_RIGHT[j].y-EAR_RIGHT[i].y) + EAR_RIGHT[i].x) ) c = !c; }\n\treturn c;\n}\n\n// Shades only the black regions of the logo\nbool pointInSheep(vec2 point, float scale, vec2 offset) {\n\t// For speed -- check if it's in a bounding box, else return false\n\tvec2 p = (point - offset)/(scale * COORD_SCALE);\n\tif (p.x > HEART_MAX_XY.x || p.y > HEART_MAX_XY.y || p.x < HEART_MIN_XY.x || p.y < HEART_MIN_XY.y) {\n\t\treturn false;\n\t}\n\t// Check if it's in each part\n\tbool inHeart = pointInHeart(point, scale, offset);\n\tbool inFace = pointInFace(point, scale, offset);\n\tbool inMouth = pointInMouth(point, scale, offset);\n\tbool inEyeLeft = pointInEyeLeft(point, scale, offset);\n\tbool inEyeRight = pointInEyeRight(point, scale, offset);\n\tbool inEarLeft = pointInEarLeft(point, scale, offset);\n\tbool inEarRight = pointInEarRight(point, scale, offset);\n\t// Shade the correct regions\n\treturn inHeart && (!(inFace || inEarLeft || inEarRight) || (inMouth || inEyeLeft || inEyeRight));\n}\n\nvec3 drawScene(vec2 uv) {\n\tvec3 col = vec3(1);\n\n\tfloat sheep = -1.0 * float(pointInSheep(uv, .9 + 0.1 * sin(time * 2.), vec2(.15 * sin(time * .47), .1 * sin(time * .37))));\n\n\tcol = mix(vec3(0, 0, 0), col, step(0., sheep));\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\tvec2 uv = fragCoord/iResolution.xy; // <0, 1>\n\n\tvec2 fragPos = fragCoord / resolution.xy;\n\tfragPos = (fragPos - 0.5 + center) / size * 1.5;\n\tfragPos.x *= resolution.x / resolution.y / horizontalScale;\n\t\n//\tuv -= 0.5; // <-0.5,0.5>\n//\tuv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n\tvec3 col = drawScene(fragPos);\n\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}\n\n"},"baaahsEclipse":{"title":"[üêë] BAAAHS Eclipse","src":"// Eclipse of the sheep!\n// based on https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nuniform float time; // @@Time\n\nuniform float size; // @@Slider default=1 min=0.25 max=2.\nuniform float horizontalScale; // @@Slider default=.7 min=0.25 max=1.\nuniform vec2 center; // @@XyPad\n\nuniform vec2 resolution; // @@Resolution\n\n\nstruct SoundAnalysis {\n\tint bucketCount;\n\tint sampleHistoryCount;\n\tsampler2D buckets;\n\tfloat maxMagnitude;\n};\nuniform SoundAnalysis soundAnalysis; // @@baaahs.SoundAnalysis:SoundAnalysis\n\nstruct BeatInfo {\n\tfloat beat;\n\tfloat bpm;\n\tfloat intensity;\n\tfloat confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n\nconst float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.8;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.4;\n\n/* Minified BAAAHS logo code: use pointInSheep(vec2 point, float scale, vec2 offset) to determine if a pixel is in the sheep logo. */ float COORD_SCALE = 0.03; vec2 HEART[187] = vec2[187](vec2(-1.408e1,2.96),vec2(-1.39e1,3.56),vec2(-1.326e1,3.86),vec2(-1.37e1,4.4),vec2(-1.36e1,5.08),vec2(-1.322e1,5.4),vec2(-1.268e1,5.46),vec2(-13,5.92),vec2(-1.292e1,6.52),vec2(-1.242e1,6.92),vec2(-1.174e1,6.84),vec2(-1.198e1,7.4),vec2(-1.174e1,7.98),vec2(-1.126e1,8.22),vec2(-1.054e1,8.02),vec2(-1.058e1,8.66),vec2(-1.012e1,9.14),vec2(-9.6,9.18),vec2(-9.1,8.88),vec2(-9.08,9.42),vec2(-8.62,9.86),vec2(-8,9.86),vec2(-7.54,9.42),vec2(-7.4,9.94),vec2(-6.88,1.028e1),vec2(-6.22,1.014e1),vec2(-5.9,9.56),vec2(-5.46,1.01e1),vec2(-4.78,1.014e1),vec2(-4.42,9.88),vec2(-4.22,9.32),vec2(-3.86,9.8),vec2(-3.2,9.88),vec2(-2.74,9.54),vec2(-2.6,8.88),vec2(-2.02,9.24),vec2(-1.38,9.04),vec2(-1.12,8.6),vec2(-1.14,8.06),vec2(-0.52,8.28),vec2(0,8.02),vec2(0.58,8.16),vec2(1.04,7.96),vec2(1,8.5),vec2(1.28,8.96),vec2(1.98,9.14),vec2(2.54,8.78),vec2(2.52,9.3),vec2(2.98,9.8),vec2(3.6,9.82),vec2(4.12,9.3),vec2(4.22,9.72),vec2(4.62,1.008e1),vec2(5.32,1.006e1),vec2(5.78,9.52),vec2(6.1,1.014e1),vec2(6.74,1.028e1),vec2(7.24,9.98),vec2(7.4,9.44),vec2(7.98,9.92),vec2(8.64,9.82),vec2(8.98,9.4),vec2(8.98,8.88),vec2(9.5,9.24),vec2(1.02e1,9.1),vec2(1.052e1,8.58),vec2(1.046e1,8.04),vec2(1.11e1,8.3),vec2(1.166e1,8.04),vec2(1.188e1,7.38),vec2(1.166e1,6.92),vec2(1.236e1,7),vec2(1.284e1,6.62),vec2(1.294e1,6.06),vec2(1.268e1,5.54),vec2(1.326e1,5.48),vec2(1.368e1,4.92),vec2(1.364e1,4.44),vec2(1.326e1,3.98),vec2(1.378e1,3.82),vec2(1.41e1,3.24),vec2(1.394e1,2.66),vec2(1.34e1,2.36),vec2(1.386e1,2.08),vec2(1.408e1,1.62),vec2(1.388e1,0.94),vec2(1.32e1,0.68),vec2(1.36e1,0.16),vec2(1.356e1,-0.42),vec2(1.322e1,-0.8),vec2(1.262e1,-0.92),vec2(1.302e1,-1.38),vec2(1.294e1,-2.06),vec2(1.244e1,-2.44),vec2(1.188e1,-2.38),vec2(1.212e1,-2.92),vec2(1.198e1,-3.46),vec2(1.152e1,-3.8),vec2(1.094e1,-3.74),vec2(1.114e1,-4.44),vec2(1.08e1,-5.02),vec2(1.036e1,-5.18),vec2(9.86,-5.06),vec2(1.006e1,-5.66),vec2(9.84,-6.16),vec2(9.3,-6.42),vec2(8.72,-6.22),vec2(8.82,-6.92),vec2(8.46,-7.42),vec2(7.88,-7.54),vec2(7.48,-7.38),vec2(7.62,-8),vec2(7.34,-8.48),vec2(6.74,-8.68),vec2(6.26,-8.46),vec2(6.36,-9.14),vec2(5.88,-9.7),vec2(5.34,-9.74),vec2(4.94,-9.48),vec2(4.98,-1.016e1),vec2(4.64,-1.058e1),vec2(4.18,-1.072e1),vec2(3.56,-1.046e1),vec2(3.64,-1.102e1),vec2(3.3,-1.152e1),vec2(2.76,-1.166e1),vec2(2.22,-1.14e1),vec2(2.28,-1.198e1),vec2(1.92,-1.248e1),vec2(1.34,-1.26e1),vec2(0.86,-1.232e1),vec2(0.9,-13),vec2(0.74,-1.328e1),vec2(0.28,-1.354e1),vec2(-0.24,-1.35e1),vec2(-0.6,-1.324e1),vec2(-0.76,-1.242e1),vec2(-1.22,-1.266e1),vec2(-1.84,-1.25e1),vec2(-2.14,-1.204e1),vec2(-2.08,-1.146e1),vec2(-2.62,-1.172e1),vec2(-3.24,-1.152e1),vec2(-3.52,-11),vec2(-3.42,-1.052e1),vec2(-3.9,-1.076e1),vec2(-4.54,-1.062e1),vec2(-4.88,-1.006e1),vec2(-4.8,-9.54),vec2(-5.32,-9.82),vec2(-5.94,-9.64),vec2(-6.24,-9.1),vec2(-6.1,-8.5),vec2(-6.54,-8.74),vec2(-7.18,-8.58),vec2(-7.5,-8.02),vec2(-7.38,-7.44),vec2(-7.82,-7.62),vec2(-8.36,-7.48),vec2(-8.72,-6.88),vec2(-8.56,-6.32),vec2(-9.08,-6.5),vec2(-9.56,-6.36),vec2(-9.94,-5.72),vec2(-9.74,-5.14),vec2(-1.034e1,-5.26),vec2(-1.086e1,-4.96),vec2(-1.104e1,-4.34),vec2(-1.082e1,-3.82),vec2(-1.128e1,-3.92),vec2(-1.168e1,-3.76),vec2(-1.202e1,-3.1),vec2(-1.18e1,-2.48),vec2(-1.242e1,-2.54),vec2(-1.294e1,-2.02),vec2(-1.294e1,-1.46),vec2(-1.256e1,-1.04),vec2(-1.314e1,-0.92),vec2(-1.352e1,-0.46),vec2(-1.352e1,8.0e-2),vec2(-1.31e1,0.54),vec2(-1.382e1,0.78),vec2(-1.406e1,1.5),vec2(-1.382e1,1.98),vec2(-1.336e1,2.22),vec2(-1.386e1,2.46),vec2(-1.406e1,2.94)); vec2 HEART_MIN_XY = vec2(-70.5, -67.9); vec2 HEART_MAX_XY = vec2(70.6, 51.6); vec2 FACE[26] = vec2[26](vec2(-5.24,2.5),vec2(-5.18,3.56),vec2(-5.04,3.84),vec2(-4.8,3.88),vec2(-3.58,3.3),vec2(-1.88,2.12),vec2(2.16,2.12),vec2(4.02,3.68),vec2(4.78,4.04),vec2(5.18,4.02),vec2(5.38,3.64),vec2(5.44,2.72),vec2(5.12,0),vec2(2.84,-7.52),vec2(2.7,-8.46),vec2(2.36,-9.22),vec2(1.86,-9.8),vec2(1.14,-1.026e1),vec2(0.46,-1.046e1),vec2(-0.36,-1.044e1),vec2(-1.28,-1.008e1),vec2(-1.88,-9.58),vec2(-2.38,-8.8),vec2(-2.64,-7.5),vec2(-4.76,-0.72),vec2(-5.22,2.48)); vec2 MOUTH[35] = vec2[35](vec2(-1.66,-6.76),vec2(-1.56,-6.52),vec2(-1.3,-6.58),vec2(-0.32,-7.72),vec2(0.2,-7.86),vec2(0.58,-7.68),vec2(1.4,-6.66),vec2(1.62,-6.52),vec2(1.84,-6.58),vec2(1.82,-6.84),vec2(1.52,-6.98),vec2(1.22,-7.28),vec2(0.3,-8.66),vec2(0.3,-9.18),vec2(0.4,-9.28),vec2(1.14,-9.04),vec2(1.66,-8.64),vec2(1.8,-8.68),vec2(1.78,-8.82),vec2(1.44,-9.2),vec2(0.98,-9.52),vec2(0.42,-9.78),vec2(2.0e-2,-9.84),vec2(-0.86,-9.46),vec2(-1.54,-8.82),vec2(-1.56,-8.68),vec2(-1.44,-8.64),vec2(-1,-8.98),vec2(-0.18,-9.28),vec2(-8.0e-2,-9.16),vec2(-8.0e-2,-8.74),vec2(-0.14,-8.5),vec2(-0.8,-7.54),vec2(-1.26,-7.02),vec2(-1.64,-6.76)); vec2 EYE_LEFT[10] = vec2[10](vec2(-4.6,2.4),vec2(-4.6,2.72),vec2(-4.46,2.98),vec2(-4.14,3.02),vec2(-3.82,2.8),vec2(-3.48,2.14),vec2(-3.54,1.6),vec2(-4,1.6),vec2(-4.26,1.72),vec2(-4.58,2.38)); vec2 EYE_RIGHT[10] = vec2[10](vec2(3.64,1.8),vec2(3.72,2.34),vec2(4,2.8),vec2(4.32,3.02),vec2(4.68,2.94),vec2(4.78,2.42),vec2(4.48,1.76),vec2(4.2,1.6),vec2(3.7,1.6),vec2(3.66,1.78)); vec2 EAR_LEFT[9] = vec2[9](vec2(-1.092e1,6.08),vec2(-1.084e1,6.26),vec2(-1.058e1,6.3),vec2(-7.02,6.24),vec2(-6.94,4.48),vec2(-7.14,4.38),vec2(-7.84,4.42),vec2(-1.078e1,5.88),vec2(-1.09e1,6.06)); vec2 EAR_RIGHT[10] = vec2[10](vec2(7.22,4.48),vec2(7.42,4.38),vec2(8.12,4.42),vec2(1.106e1,5.88),vec2(1.12e1,6.14),vec2(1.112e1,6.26),vec2(1.086e1,6.3),vec2(7.36,6.28),vec2(7.26,6.18),vec2(7.22,4.5));  bool pointInHeart(vec2 point, float scale, vec2 offset){ \tint len = 187; \tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE); \tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((HEART[i].y > p.y) != (HEART[j].y > p.y)) && (p.x < (HEART[j].x-HEART[i].x) * (p.y-HEART[i].y) / (HEART[j].y-HEART[i].y) + HEART[i].x) ) c = !c; } \treturn c; } bool pointInFace(vec2 point, float scale, vec2 offset){ \tint len = 26; \tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE); \tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((FACE[i].y > p.y) != (FACE[j].y > p.y)) && (p.x < (FACE[j].x-FACE[i].x) * (p.y-FACE[i].y) / (FACE[j].y-FACE[i].y) + FACE[i].x) ) c = !c; } \treturn c; } bool pointInMouth(vec2 point, float scale, vec2 offset){ \tint len = 35; \tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE); \tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((MOUTH[i].y > p.y) != (MOUTH[j].y > p.y)) && (p.x < (MOUTH[j].x-MOUTH[i].x) * (p.y-MOUTH[i].y) / (MOUTH[j].y-MOUTH[i].y) + MOUTH[i].x) ) c = !c; } \treturn c; } bool pointInEyeLeft(vec2 point, float scale, vec2 offset){ \tint len = 10; \tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE); \tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EYE_LEFT[i].y > p.y) != (EYE_LEFT[j].y > p.y)) && (p.x < (EYE_LEFT[j].x-EYE_LEFT[i].x) * (p.y-EYE_LEFT[i].y) / (EYE_LEFT[j].y-EYE_LEFT[i].y) + EYE_LEFT[i].x) ) c = !c; } \treturn c; } bool pointInEyeRight(vec2 point, float scale, vec2 offset){ \tint len = 10; \tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE); \tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EYE_RIGHT[i].y > p.y) != (EYE_RIGHT[j].y > p.y)) && (p.x < (EYE_RIGHT[j].x-EYE_RIGHT[i].x) * (p.y-EYE_RIGHT[i].y) / (EYE_RIGHT[j].y-EYE_RIGHT[i].y) + EYE_RIGHT[i].x) ) c = !c; } \treturn c; } bool pointInEarLeft(vec2 point, float scale, vec2 offset){ \tint len = 9; \tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE); \tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EAR_LEFT[i].y > p.y) != (EAR_LEFT[j].y > p.y)) && (p.x < (EAR_LEFT[j].x-EAR_LEFT[i].x) * (p.y-EAR_LEFT[i].y) / (EAR_LEFT[j].y-EAR_LEFT[i].y) + EAR_LEFT[i].x) ) c = !c; } \treturn c; } bool pointInEarRight(vec2 point, float scale, vec2 offset){ \tint len = 10; \tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE); \tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EAR_RIGHT[i].y > p.y) != (EAR_RIGHT[j].y > p.y)) && (p.x < (EAR_RIGHT[j].x-EAR_RIGHT[i].x) * (p.y-EAR_RIGHT[i].y) / (EAR_RIGHT[j].y-EAR_RIGHT[i].y) + EAR_RIGHT[i].x) ) c = !c; } \treturn c; }  bool pointInSheep(vec2 point, float scale, vec2 offset) { \tvec2 p = (point - offset)/(scale * COORD_SCALE); \tif (p.x > HEART_MAX_XY.x || p.y > HEART_MAX_XY.y || p.x < HEART_MIN_XY.x || p.y < HEART_MIN_XY.y) { \t\treturn false; \t} \tbool inHeart = pointInHeart(point, scale, offset); \tbool inFace = pointInFace(point, scale, offset); \tbool inMouth = pointInMouth(point, scale, offset); \tbool inEyeLeft = pointInEyeLeft(point, scale, offset); \tbool inEyeRight = pointInEyeRight(point, scale, offset); \tbool inEarLeft = pointInEarLeft(point, scale, offset); \tbool inEarRight = pointInEarRight(point, scale, offset); \treturn inHeart && (!(inFace || inEarLeft || inEarRight) || (inMouth || inEyeLeft || inEyeRight)); }\n\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n\treturn dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn .2 + .3 * beatInfo.intensity;  //texture(soundAnalysis.buckets, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n} \n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n\tfloat next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n\treturn mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float scale) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - scale);\n\n\tfloat sheepScale = 1.5;\n\tvec2 sheepXY = vec2(0.0, 0.00);\n\n\t//float b = pointInSheep(fragment, sheepScale, sheepXY) ? BRIGHTNESS : 0.1 * BRIGHTNESS; // dist < scale ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\tfloat b = dist < scale ? BRIGHTNESS * 0.2 : BRIGHTNESS;\n\n\n\tif (pointInSheep(fragment, sheepScale, sheepXY)) { b = 50. * b; }\n\n\tvec3 col = vec3(0.0);\n\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + time * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + time * 0.12, 1.0, 1.0));\n\n\tfloat freq = abs(fragment.x * 0.5);\n\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 fragPos = fragCoord / resolution.xy;\n\tfragPos = (fragPos - 0.5 + center) / size * 2.5;\n\tfragPos.x *= resolution.x / resolution.y / horizontalScale;\n\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n\tfloat c = cos(time * SPEED);\n\tfloat s = sin(time * SPEED);\n\tvec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\n\tcolor += max(luma(color) - 1.0, 0.0);\n\n\tfragColor = vec4(color, 1.0);\n\n}\n"},"ripple":{"title":"Ripple","src":"uniform float time;\nuniform float rippleAmount; // @type float\n\n// @return uv-coordinate\n// @param uvIn uv-coordinate\nvec2 main(vec2 uvIn) {\n  vec2 p = -1.0 + 2.0 * uvIn;\n  float len = length(p);\n  return uvIn + (p/len)*sin(len*12.0-time*4.0)*0.1 * rippleAmount;\n}"},"sparklez":{"title":"Sparklez‚Ñ¢","src":"//Based on https://www.youtube.com/watch?v=3CycKKJiwis\n\nfloat random(vec2 par){\n    return fract(sin(dot(par.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 random2(vec2 par){\n    float rand = random(par);\n    return vec2(rand, random(par+rand));\n}\n\n// @param fragCoord uv-coordinate\n// @return color\nvec4 upstreamColor(vec2 fragCoord);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //The ratio of the width and height of the screen\n    float widthHeightRatio = iResolution.x/iResolution.y;\n\n    float t = iTime * 0.01;\n    float dist = 0.0;\n    float layers = 16.0;\n    float scale = 32.0;\n    float depth;\n    float phase;\n    float rotationAngle = iTime * -0.01;\n\n    vec2 offset;\n    vec2 local_uv;\n    vec2 index;\n    vec2 pos;\n    vec2 seed;\n    vec2 centre = vec2(0.5, 0.5);\n\n    mat2 rotation = mat2(cos(rotationAngle), -sin(rotationAngle),\n    sin(rotationAngle),  cos(rotationAngle));\n\n    for(float i = 0.0; i < layers; i++){\n        depth = fract(i/layers + t);\n\n        //Move centre in a circle depending on the depth of the layer\n        centre.x = 0.5 + 0.1 * cos(t) * depth;\n        centre.y = 0.5 + 0.1 * sin(t) * depth;\n\n        //Get uv from the fragment coordinates, rotation and depth\n        uv = centre-fragCoord/iResolution.xy;\n        uv.y /= widthHeightRatio;\n        uv *= rotation;\n        uv *= mix(scale, 0.0, depth);\n\n        //The local cell\n        index = floor(uv);\n\n        //Local cell seed;\n        seed = 20.0 * i + index;\n\n        //The local cell coordinates\n        local_uv = fract(i + uv) - 0.5;\n\n        //Get a random position for the local cell\n        pos = 1.8 * (random2(seed) - 0.5);\n\n        //Get a random phase\n        phase = 128.0 * random(seed);\n\n        //Get distance to the generated point, add fading to distant points\n        //Add the distance to the sum\n        dist += pow(abs(1.0-length(local_uv-pos)), 50.0 + 20.0 * sin(phase + 8.0 * iTime))\n        * min(1.0, depth*2.0);\n\n    }\n    fragColor = upstreamColor(fragCoord) + vec4(vec3(dist),1.0) * 10.;\n}"},"heart":{"title":"Heart","src":"// Heart\n// From http://mathworld.wolfram.com/HeartSurface.html\n\nuniform float heartSize; // @@Slider default=1. min=0.25 max=2\nuniform vec2 heartCenter; // @@XyPad\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\n\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n// @param fragCoord uv-coordinate\n// @return color\nvec4 upstreamColor(vec2 fragCoord);\n\nfloat f(vec3 p) {\n    vec3 pp = p * p;\n    vec3 ppp = pp * p;\n    float a = pp.x + 2.25 * pp.y + pp.z - 1.0;\n    return a * a * a - (pp.x + 0.1125 * pp.y) * ppp.z;\n}\n\n// Bisection solver for y\nfloat h(float x, float z) {\n    float a = 0.0, b = 0.75, y = 0.5;\n    for (int i = 0; i < 10; i++) {\n        if (f(vec3(x, y, z)) <= 0.0)\n        a = y;\n        else\n        b = y;\n        y = (a + b) * 0.5;\n    }\n    return y;\n}\n\n// Analytical gradient\n// (-2 x z^3+6 x (-1.+x^2+2.25 y^2+z^2)^2)\n// (-0.225 y z^3+13.5 y (-1.+x^2+2.25 y^2+z^2)^2)\n// (z (-3 x^2 z-0.3375 y^2 z+6 (-1.+x^2+2.25 y^2+z^2)^2))\nvec3 normal(vec2 p) {\n    vec3 v = vec3(p.x, h(p.x, p.y), p.y);\n    vec3 vv = v * v;\n    vec3 vvv = vv * v;\n    float a = -1.0 + dot(vv, vec3(1, 2.25, 1));\n    a *= a;\n\n    return normalize(vec3(\n    -2.0 * v.x * vvv.z +  6.0 * v.x * a,\n    -0.225 * v.y * vvv.z + 13.5 * v.y * a,\n    v.z * (-3.0 * vv.x * v.z - 0.3375 * vv.y * v.z + 6.0 * a)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 p = (vec3((2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x), 0) - vec3(heartCenter.xy, 0.)) * 4. / heartSize * .5;\n    float beat = beatInfo.beat;\n    float s = sin(beat * 4.0);\n    s *= s;\n    s *= s;\n    s *= s;\n    s *= s;\n    s *= 0.1;\n    vec3 tp = p * vec3(1.0 + s, 1.0 - s, 0.0) * 2.0;\n\n    if (f(tp.xzy) <= 0.0) {\n        vec3 n = normal(tp.xy);\n        float diffuse = dot(n, normalize(vec3(-1, 1, 1))) * 0.5 + 0.5;\n        float specular = pow(max(dot(n, normalize(vec3(-1, 2, 1))), 0.0), 64.0);\n        float rim = 0.; //1.0 - dot(n, vec3(0.0, 1.0, 0.0));\n        fragColor = vec4(diffuse * vec3(1.0, 0, 0) + specular * vec3(0.8) + rim * vec3(0.5), 1.);\n    }\n    else\n    fragColor = upstreamColor(fragCoord);\n}"},"thatSAllFolks":{"title":"That's all, folks!","src":"uniform float time;\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\nuniform float speed; // @@Slider default=10. min=5 max=20\nuniform float ringDensity; // @@Slider default=60. min=10 max=120\nuniform vec2 thatsAllFolksCenter; // @@XyPad\nuniform float finality; // @@Slider default=.5 min=0 max=1\n\n// @param fragCoord uv-coordinate\n// @return color\nvec4 upstreamColor(vec2 fragCoord);\n\n// @return color\n// @param uvIn uv-coordinate\n// @param inColor color\nvec4 main(vec2 uvIn) {\n    vec4 inColor = upstreamColor(uvIn);\n    vec2 p = uvIn - .5 + vec2(thatsAllFolksCenter.x, -thatsAllFolksCenter.y) * 2.;\n    float directMod = sin(time * 0.01);\n    float d = mix(1. - finality, 1., sin(-length(p) * ringDensity * (0.8+ beatInfo.intensity * 0.2) + time * speed)); // * beatInfo.intensity;\n    return vec4(inColor.rgb * d, 1.0);\n}"},"soundBrightness":{"title":"Sound Brightness","src":"uniform float soundBrightness; // @@Slider min=0. max=2. default=0.5\n\nstruct SoundAnalysis {\n    int bucketCount;\n    int sampleHistoryCount;\n    sampler2D buckets;\n    float maxMagnitude;\n};\nuniform SoundAnalysis soundAnalysis; // @@baaahs.SoundAnalysis:SoundAnalysis\n\n// @return color\n// @param inColor color\nvec4 main(vec4 inColor) {\n    vec4 clampedColor = clamp(inColor, 0., 1.);\n    return vec4(clampedColor.rgb * mix(soundAnalysis.maxMagnitude, 1., soundBrightness) , clampedColor.a);\n}\n"},"blackout":{"title":"Blackout","src":"// @return color\n// @param uvIn uv-coordinate\nvec4 main(vec2 uvIn) {\n    return vec4(0., 0., 0., 1.);\n}"},"none":{"title":"None","src":"// @return color\n// @param inColor color\nvec4 main(vec4 inColor) {\n    return inColor;\n}"}},"patches":{"xyProjection-patch":{"shaderId":"xyProjection","incomingLinks":{"modelInfo":{"type":"datasource","dataSourceId":"modelInfo"},"pixelLocation":{"type":"datasource","dataSourceId":"pixelLocation"}}},"darkness-patch":{"shaderId":"darkness","incomingLinks":{}},"hsb-patch":{"shaderId":"hsb","incomingLinks":{"hueShift":{"type":"datasource","dataSourceId":"hueShiftSlider"},"brightness":{"type":"datasource","dataSourceId":"brightnessSlider"},"inColor":{"type":"stream","stream":"main"},"saturation":{"type":"datasource","dataSourceId":"saturationSlider"}},"priority":-1.0},"squarezzz-patch":{"shaderId":"squarezzz","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"speed":{"type":"datasource","dataSourceId":"speedSlider"},"fragCoord":{"type":"stream","stream":"main"},"iResolution":{"type":"datasource","dataSourceId":"resolution"},"beatInfo":{"type":"datasource","dataSourceId":"beatInfo"},"resolution":{"type":"datasource","dataSourceId":"resolution"}}},"colorPulse-patch":{"shaderId":"colorPulse","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"uvIn":{"type":"stream","stream":"main"},"hueRange":{"type":"datasource","dataSourceId":"hueRangeSlider"},"beatInfo":{"type":"datasource","dataSourceId":"beatInfo"},"fromCenter":{"type":"datasource","dataSourceId":"fromCenterSwitch"},"pulseSpeed":{"type":"datasource","dataSourceId":"pulseSpeedSlider"},"center":{"type":"datasource","dataSourceId":"center"}}},"geometricColorPulse-patch":{"shaderId":"geometricColorPulse","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"uvIn":{"type":"stream","stream":"main"},"fixtureInfo":{"type":"datasource","dataSourceId":"fixtureInfo"},"hueRange":{"type":"datasource","dataSourceId":"hueRangeSlider"},"beatInfo":{"type":"datasource","dataSourceId":"beatInfo"},"cycleSpeed":{"type":"datasource","dataSourceId":"cycleSpeedSlider"},"pulseSpeed":{"type":"datasource","dataSourceId":"pulseSpeedSlider"}}},"complexTrippyShit1-patch":{"shaderId":"complexTrippyShit1","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"fragCoord":{"type":"stream","stream":"main"},"resolution":{"type":"datasource","dataSourceId":"resolution"}}},"baaahzebra-patch":{"shaderId":"baaahzebra","incomingLinks":{"uv":{"type":"stream","stream":"main"},"time":{"type":"datasource","dataSourceId":"time"},"speed":{"type":"datasource","dataSourceId":"speedSlider2"},"beatInfo":{"type":"datasource","dataSourceId":"beatInfo"}}},"orangeSnowflake-patch":{"shaderId":"orangeSnowflake","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"speed":{"type":"datasource","dataSourceId":"speedSlider"},"fragCoord":{"type":"stream","stream":"main"},"beatInfo":{"type":"datasource","dataSourceId":"beatInfo"},"pulsiness":{"type":"datasource","dataSourceId":"pulsinessSlider"},"resolution":{"type":"datasource","dataSourceId":"resolution"}}},"acidAtTheDisco-patch":{"shaderId":"acidAtTheDisco","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"speed":{"type":"datasource","dataSourceId":"speedSlider"},"fragCoord":{"type":"stream","stream":"main"},"beatInfo":{"type":"datasource","dataSourceId":"beatInfo"},"pulsiness":{"type":"datasource","dataSourceId":"pulsinessSlider"},"resolution":{"type":"datasource","dataSourceId":"resolution"}}},"picassoSNightmare-patch":{"shaderId":"picassoSNightmare","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"mouse":{"type":"stream","stream":"main"},"gl_FragCoord":{"type":"stream","stream":"main"},"resolution":{"type":"datasource","dataSourceId":"resolution"}}},"plasma-patch":{"shaderId":"plasma","incomingLinks":{"iTime":{"type":"datasource","dataSourceId":"time"},"fragCoord":{"type":"stream","stream":"main"},"iResolution":{"type":"datasource","dataSourceId":"resolution"}}},"evolutionOfAcid-patch":{"shaderId":"evolutionOfAcid","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"mouse":{"type":"stream","stream":"main"},"gl_FragCoord":{"type":"stream","stream":"main"},"resolution":{"type":"datasource","dataSourceId":"resolution"}}},"wobblyColorGrid-patch":{"shaderId":"wobblyColorGrid","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"gl_FragCoord":{"type":"stream","stream":"main"},"center":{"type":"datasource","dataSourceId":"center"},"resolution":{"type":"datasource","dataSourceId":"resolution"}}},"gadzooks-patch":{"shaderId":"gadzooks","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"mouse":{"type":"stream","stream":"main"},"gl_FragCoord":{"type":"stream","stream":"main"},"resolution":{"type":"datasource","dataSourceId":"resolution"}}},"gaiaSOrgasm-patch":{"shaderId":"gaiaSOrgasm","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"gl_FragCoord":{"type":"stream","stream":"main"},"resolution":{"type":"datasource","dataSourceId":"resolution"}}},"faeriePulse-patch":{"shaderId":"faeriePulse","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"gl_FragCoord":{"type":"stream","stream":"main"},"resolution":{"type":"datasource","dataSourceId":"resolution"}}},"yasQueen-patch":{"shaderId":"yasQueen","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"mouse":{"type":"stream","stream":"main"},"gl_FragCoord":{"type":"stream","stream":"main"},"resolution":{"type":"datasource","dataSourceId":"resolution"}}},"geometricSheep-patch":{"shaderId":"geometricSheep","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"uvIn":{"type":"stream","stream":"main"},"fixtureInfo":{"type":"datasource","dataSourceId":"fixtureInfo"},"hueSpread":{"type":"datasource","dataSourceId":"hueSpreadSlider"},"beatInfo":{"type":"datasource","dataSourceId":"beatInfo"},"cycleSpeed":{"type":"datasource","dataSourceId":"cycleSpeedSlider2"}}},"aquaticFlood-patch":{"shaderId":"aquaticFlood","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"gl_FragCoord":{"type":"stream","stream":"main"},"resolution":{"type":"datasource","dataSourceId":"resolution"},"sm_beat":{"type":"datasource","dataSourceId":"smBeatSlider"}}},"circularDependency-patch":{"shaderId":"circularDependency","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"fragCoord":{"type":"stream","stream":"main"},"center":{"type":"datasource","dataSourceId":"center"},"resolution":{"type":"datasource","dataSourceId":"resolution"}}},"redSea-patch":{"shaderId":"redSea","incomingLinks":{"iTime":{"type":"datasource","dataSourceId":"time"},"fragCoord":{"type":"stream","stream":"main"},"iResolution":{"type":"datasource","dataSourceId":"resolution"}}},"baaahsLogo-patch":{"shaderId":"baaahsLogo","incomingLinks":{"size":{"type":"datasource","dataSourceId":"sizeSlider"},"time":{"type":"datasource","dataSourceId":"time"},"iTime":{"type":"datasource","dataSourceId":"time"},"fragCoord":{"type":"stream","stream":"main"},"iResolution":{"type":"datasource","dataSourceId":"resolution"},"horizontalScale":{"type":"datasource","dataSourceId":"horizontalScaleSlider"},"center":{"type":"datasource","dataSourceId":"center"},"resolution":{"type":"datasource","dataSourceId":"resolution"}}},"baaahsEclipse-patch":{"shaderId":"baaahsEclipse","incomingLinks":{"size":{"type":"datasource","dataSourceId":"sizeSlider"},"time":{"type":"datasource","dataSourceId":"time"},"iTime":{"type":"datasource","dataSourceId":"time"},"fragCoord":{"type":"stream","stream":"main"},"iResolution":{"type":"datasource","dataSourceId":"resolution"},"soundAnalysis":{"type":"datasource","dataSourceId":"soundAnalysis"},"horizontalScale":{"type":"datasource","dataSourceId":"horizontalScaleSlider"},"beatInfo":{"type":"datasource","dataSourceId":"beatInfo"},"center":{"type":"datasource","dataSourceId":"center"},"resolution":{"type":"datasource","dataSourceId":"resolution"}}},"ripple-patch":{"shaderId":"ripple","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"uvIn":{"type":"stream","stream":"main"},"rippleAmount":{"type":"datasource","dataSourceId":"rippleAmountSlider"}}},"sparklez-patch":{"shaderId":"sparklez","incomingLinks":{"iTime":{"type":"datasource","dataSourceId":"time"},"fragCoord":{"type":"stream","stream":"main"},"iResolution":{"type":"datasource","dataSourceId":"resolution"},"upstreamColor":{"type":"stream","stream":"main"}}},"heart-patch":{"shaderId":"heart","incomingLinks":{"heartSize":{"type":"datasource","dataSourceId":"heartSizeSlider"},"fragCoord":{"type":"stream","stream":"main"},"iResolution":{"type":"datasource","dataSourceId":"resolution"},"beatInfo":{"type":"datasource","dataSourceId":"beatInfo"},"heartCenter":{"type":"datasource","dataSourceId":"heartCenter"},"upstreamColor":{"type":"stream","stream":"main"}}},"thatSAllFolks-patch":{"shaderId":"thatSAllFolks","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"uvIn":{"type":"stream","stream":"main"},"speed":{"type":"datasource","dataSourceId":"speedSlider3"},"thatsAllFolksCenter":{"type":"datasource","dataSourceId":"thatsAllFolksCenter"},"beatInfo":{"type":"datasource","dataSourceId":"beatInfo"},"ringDensity":{"type":"datasource","dataSourceId":"ringDensitySlider"},"finality":{"type":"datasource","dataSourceId":"finalitySlider"},"upstreamColor":{"type":"stream","stream":"main"}}},"soundBrightness-patch":{"shaderId":"soundBrightness","incomingLinks":{"soundAnalysis":{"type":"datasource","dataSourceId":"soundAnalysis"},"soundBrightness":{"type":"datasource","dataSourceId":"soundBrightnessSlider"},"inColor":{"type":"stream","stream":"main"}}},"blackout-patch":{"shaderId":"blackout","incomingLinks":{"uvIn":{"type":"stream","stream":"main"},"inColor":{"type":"stream","stream":"main"}},"priority":100.0},"none-patch":{"shaderId":"none","incomingLinks":{"uvIn":{"type":"stream","stream":"main"},"inColor":{"type":"stream","stream":"main"}}}},"controls":{"shaderControls":{"type":"baaahs.Core:ButtonGroup","title":"Shader Controls","showTitle":true,"buttonIds":[]},"vacuity":{"type":"baaahs.Core:Vacuity","title":"Vacuity"},"shaders":{"type":"baaahs.Core:ButtonGroup","title":"Shaders","direction":"Vertical","showTitle":true,"buttonIds":[]},"squarezzz":{"type":"baaahs.Core:Button","title":"[üêë] Squarezzz","patchIds":["squarezzz-patch"]},"colorPulse":{"type":"baaahs.Core:Button","title":"[üêë] ColorPulse","patchIds":["colorPulse-patch"]},"geometricColorPulse":{"type":"baaahs.Core:Button","title":"[üêë] Geometric ColorPulse","patchIds":["geometricColorPulse-patch"]},"complexTrippyShit1":{"type":"baaahs.Core:Button","title":"[üêë] Complex Trippy Shit #1","patchIds":["complexTrippyShit1-patch"]},"baaahzebra":{"type":"baaahs.Core:Button","title":"[üêë] BAAAHZebra","patchIds":["baaahzebra-patch"]},"orangeSnowflake":{"type":"baaahs.Core:Button","title":"Orange Snowflake","patchIds":["orangeSnowflake-patch"]},"acidAtTheDisco":{"type":"baaahs.Core:Button","title":"Acid at the Disco","patchIds":["acidAtTheDisco-patch"]},"picassoSNightmare":{"type":"baaahs.Core:Button","title":"Picasso's Nightmare","patchIds":["picassoSNightmare-patch"]},"plasma":{"type":"baaahs.Core:Button","title":"Plasma","patchIds":["plasma-patch"]},"evolutionOfAcid":{"type":"baaahs.Core:Button","title":"Evolution of Acid","patchIds":["evolutionOfAcid-patch"]},"wobblyColorGrid":{"type":"baaahs.Core:Button","title":"Wobbly Color Grid","patchIds":["wobblyColorGrid-patch"]},"gadzooks":{"type":"baaahs.Core:Button","title":"Gadzooks","patchIds":["gadzooks-patch"]},"gaiaSOrgasm":{"type":"baaahs.Core:Button","title":"Gaia's Orgasm","patchIds":["gaiaSOrgasm-patch"]},"faeriePulse":{"type":"baaahs.Core:Button","title":"Faerie Pulse","patchIds":["faeriePulse-patch"]},"yasQueen":{"type":"baaahs.Core:Button","title":"Yas Queen","patchIds":["yasQueen-patch"]},"geometricSheep":{"type":"baaahs.Core:Button","title":"[üêë] Geometric Sheep","patchIds":["geometricSheep-patch"]},"aquaticFlood":{"type":"baaahs.Core:Button","title":"Aquatic Flood","patchIds":["aquaticFlood-patch"]},"circularDependency":{"type":"baaahs.Core:Button","title":"Circular Dependency","patchIds":["circularDependency-patch"]},"redSea":{"type":"baaahs.Core:Button","title":"Red Sea","patchIds":["redSea-patch"]},"baaahsLogo":{"type":"baaahs.Core:Button","title":"[üêë] BAAAHS Logo","patchIds":["baaahsLogo-patch"]},"baaahsEclipse":{"type":"baaahs.Core:Button","title":"[üêë] BAAAHS Eclipse","patchIds":["baaahsEclipse-patch"]},"effects":{"type":"baaahs.Core:ButtonGroup","title":"Effects","direction":"Vertical","showTitle":true,"allowMultiple":true,"buttonIds":[]},"wobble":{"type":"baaahs.Core:Button","title":"Wobble","patchIds":["ripple-patch"]},"sparklez":{"type":"baaahs.Core:Button","title":"Sparklez‚Ñ¢","patchIds":["sparklez-patch"]},"heart":{"type":"baaahs.Core:Button","title":"Heart","patchIds":["heart-patch"]},"thatSAllFolks":{"type":"baaahs.Core:Button","title":"That's all, folks!","patchIds":["thatSAllFolks-patch"]},"soundBrightness":{"type":"baaahs.Core:Button","title":"Sound Brightness","patchIds":["soundBrightness-patch"]},"blackout":{"type":"baaahs.Core:Button","title":"Blackout","activationType":"Momentary","patchIds":["blackout-patch"]},"globalControls":{"type":"baaahs.Core:ButtonGroup","title":"Global Controls","showTitle":true,"buttonIds":[]},"brightness":{"type":"baaahs.Core:Slider","title":"Brightness","maxValue":1.25,"controlledDataSourceId":"brightnessSlider"},"saturation":{"type":"baaahs.Core:Slider","title":"Saturation","maxValue":1.25,"controlledDataSourceId":"saturationSlider"},"visualizer":{"type":"baaahs.Core:Visualizer"},"beatLink":{"type":"baaahs.BeatLink:BeatLink"},"none":{"type":"baaahs.Core:Button","title":"None","patchIds":["none-patch"]}},"dataSources":{"modelInfo":{"type":"baaahs.Core:ModelInfo"},"pixelLocation":{"type":"baaahs.Core:PixelLocation"},"hueShiftSlider":{"type":"baaahs.Core:Slider","title":"Hue Shift","initialValue":1.0,"minValue":0.0,"maxValue":2.0},"brightnessSlider":{"type":"baaahs.Core:Slider","title":"Brightness","initialValue":1.0,"minValue":0.0,"maxValue":1.25},"saturationSlider":{"type":"baaahs.Core:Slider","title":"Saturation","initialValue":1.0,"minValue":0.0,"maxValue":1.25},"time":{"type":"baaahs.Core:Time"},"speedSlider":{"type":"baaahs.Core:Slider","title":"Speed","initialValue":3.0,"minValue":1.0,"maxValue":5.0},"resolution":{"type":"baaahs.Core:Resolution"},"beatInfo":{"type":"baaahs.BeatLink:BeatInfo"},"hueRangeSlider":{"type":"baaahs.Core:Slider","title":"Hue Range","initialValue":0.3,"minValue":0.0,"maxValue":1.0},"fromCenterSwitch":{"type":"baaahs.Core:Switch","title":"From Center","initiallyEnabled":true},"pulseSpeedSlider":{"type":"baaahs.Core:Slider","title":"Pulse Speed","initialValue":1.0,"minValue":1.0,"maxValue":3.0},"center":{"type":"baaahs.Core:XyPad","title":"Center"},"fixtureInfo":{"type":"baaahs.Core:FixtureInfo"},"cycleSpeedSlider":{"type":"baaahs.Core:Slider","title":"Cycle Speed","initialValue":1.0,"minValue":0.0,"maxValue":5.0},"speedSlider2":{"type":"baaahs.Core:Slider","title":"Speed","initialValue":5.0,"minValue":0.0,"maxValue":10.0},"pulsinessSlider":{"type":"baaahs.Core:Slider","title":"Pulsiness","initialValue":3.0,"minValue":1.0,"maxValue":5.0},"hueSpreadSlider":{"type":"baaahs.Core:Slider","title":"Hue Spread","initialValue":2.0,"minValue":0.0,"maxValue":10.0},"cycleSpeedSlider2":{"type":"baaahs.Core:Slider","title":"Cycle Speed","initialValue":1.0,"minValue":0.0,"maxValue":10.0},"smBeatSlider":{"type":"baaahs.Core:Slider","title":"Sm_beat","initialValue":1.0,"minValue":0.0,"maxValue":1.0},"sizeSlider":{"type":"baaahs.Core:Slider","title":"Size","initialValue":1.0,"minValue":0.25,"maxValue":2.0},"horizontalScaleSlider":{"type":"baaahs.Core:Slider","title":"Horizontal Scale","initialValue":0.7,"minValue":0.25,"maxValue":1.0},"soundAnalysis":{"type":"baaahs.SoundAnalysis:SoundAnalysis"},"rippleAmountSlider":{"type":"baaahs.Core:Slider","title":"Ripple Amount","initialValue":1.0,"minValue":0.0,"maxValue":1.0},"heartSizeSlider":{"type":"baaahs.Core:Slider","title":"Heart Size","initialValue":1.0,"minValue":0.25,"maxValue":2.0},"heartCenter":{"type":"baaahs.Core:XyPad","title":"Heart Center"},"speedSlider3":{"type":"baaahs.Core:Slider","title":"Speed","initialValue":10.0,"minValue":5.0,"maxValue":20.0},"thatsAllFolksCenter":{"type":"baaahs.Core:XyPad","title":"Thats All Folks Center"},"ringDensitySlider":{"type":"baaahs.Core:Slider","title":"Ring Density","initialValue":60.0,"minValue":10.0,"maxValue":120.0},"finalitySlider":{"type":"baaahs.Core:Slider","title":"Finality","initialValue":0.5,"minValue":0.0,"maxValue":1.0},"soundBrightnessSlider":{"type":"baaahs.Core:Slider","title":"Sound Brightness","initialValue":0.5,"minValue":0.0,"maxValue":2.0}},"version":8}