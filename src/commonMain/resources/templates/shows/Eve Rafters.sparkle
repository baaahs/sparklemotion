{
    "title": "Ewe Ravterds",
    "patchIds": [
        "xyProjection-patch",
        "darkness-patch",
        "hsb-patch"
    ],
    "layouts": {
        "panels": {
            "backdrops": {
                "title": "Backdrops"
            }
        },
        "formats": {
            "default": {
                "mediaQuery": null,
                "tabs": [
                    {
                        "type": "Grid",
                        "title": "Main",
                        "columns": 12,
                        "rows": 10,
                        "items": [
                            {
                                "controlId": "shaderControls",
                                "column": 0,
                                "row": 0,
                                "width": 9,
                                "height": 3,
                                "layout": {
                                    "columns": 1,
                                    "rows": 1,
                                    "items": [
                                        {
                                            "controlId": "vacuity",
                                            "column": 0,
                                            "row": 0
                                        }
                                    ]
                                }
                            },
                            {
                                "controlId": "shaders",
                                "column": 0,
                                "row": 3,
                                "width": 7,
                                "height": 7,
                                "layout": {
                                    "columns": 8,
                                    "rows": 7,
                                    "items": [
                                        {
                                            "controlId": "squarezzz",
                                            "column": 2,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "colorPulse",
                                            "column": 0,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "geometricColorPulse",
                                            "column": 0,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "complexTrippyShit1",
                                            "column": 2,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "baaahzebra",
                                            "column": 3,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "orangeSnowflake",
                                            "column": 1,
                                            "row": 2
                                        },
                                        {
                                            "controlId": "acidAtTheDisco",
                                            "column": 2,
                                            "row": 3
                                        },
                                        {
                                            "controlId": "picassoSNightmare",
                                            "column": 0,
                                            "row": 3
                                        },
                                        {
                                            "controlId": "plasma",
                                            "column": 3,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "wobblyColorGrid",
                                            "column": 2,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "gadzooks",
                                            "column": 4,
                                            "row": 5
                                        },
                                        {
                                            "controlId": "gaiaSOrgasm",
                                            "column": 0,
                                            "row": 5
                                        },
                                        {
                                            "controlId": "faeriePulse",
                                            "column": 4,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "yasQueen",
                                            "column": 2,
                                            "row": 6
                                        },
                                        {
                                            "controlId": "geometricSheep",
                                            "column": 0,
                                            "row": 2
                                        },
                                        {
                                            "controlId": "aquaticFlood",
                                            "column": 3,
                                            "row": 3
                                        },
                                        {
                                            "controlId": "circularDependency",
                                            "column": 1,
                                            "row": 6
                                        },
                                        {
                                            "controlId": "redSea",
                                            "column": 0,
                                            "row": 6
                                        },
                                        {
                                            "controlId": "baaahsEclipse",
                                            "column": 1,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "firstRaymarches",
                                            "column": 3,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "fireball",
                                            "column": 1,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "blueHearts",
                                            "column": 4,
                                            "row": 3
                                        },
                                        {
                                            "controlId": "blueSClues",
                                            "column": 5,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "checkerboard",
                                            "column": 0,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "colorDiffusionFlow",
                                            "column": 3,
                                            "row": 6
                                        },
                                        {
                                            "controlId": "danceyCubes",
                                            "column": 4,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "plaid",
                                            "column": 3,
                                            "row": 5
                                        },
                                        {
                                            "controlId": "primeWaves",
                                            "column": 4,
                                            "row": 2
                                        },
                                        {
                                            "controlId": "quiver",
                                            "column": 5,
                                            "row": 3
                                        },
                                        {
                                            "controlId": "spaceRings",
                                            "column": 5,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "waves",
                                            "column": 5,
                                            "row": 6
                                        },
                                        {
                                            "controlId": "sunsetDelight",
                                            "column": 7,
                                            "row": 5
                                        },
                                        {
                                            "controlId": "huerthquake",
                                            "column": 3,
                                            "row": 2
                                        },
                                        {
                                            "controlId": "jacobianUndistortion",
                                            "column": 1,
                                            "row": 3
                                        },
                                        {
                                            "controlId": "solidColor",
                                            "column": 7,
                                            "row": 6
                                        },
                                        {
                                            "controlId": "sunsetClouds",
                                            "column": 6,
                                            "row": 5
                                        },
                                        {
                                            "controlId": "oceanClouds",
                                            "column": 6,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "clouds",
                                            "column": 6,
                                            "row": 3
                                        },
                                        {
                                            "controlId": "electricEelUniverse",
                                            "column": 5,
                                            "row": 2
                                        },
                                        {
                                            "controlId": "rainbows",
                                            "column": 5,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "voronoi",
                                            "column": 1,
                                            "row": 5
                                        },
                                        {
                                            "controlId": "voxelEdges",
                                            "column": 1,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "octagrams",
                                            "column": 6,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "phantomStar",
                                            "column": 6,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "baseWarp",
                                            "column": 6,
                                            "row": 2
                                        },
                                        {
                                            "controlId": "sdfs",
                                            "column": 7,
                                            "row": 2
                                        },
                                        {
                                            "controlId": "randomSin",
                                            "column": 5,
                                            "row": 5
                                        },
                                        {
                                            "controlId": "diveToCloud",
                                            "column": 7,
                                            "row": 3
                                        },
                                        {
                                            "controlId": "proteanClouds",
                                            "column": 6,
                                            "row": 6
                                        },
                                        {
                                            "controlId": "sincos3d",
                                            "column": 4,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "midCentruy",
                                            "column": 7,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "fractalTrees",
                                            "column": 7,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "monitorsAndFractalLife",
                                            "column": 7,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "raymarchingBasic",
                                            "column": 2,
                                            "row": 5
                                        },
                                        {
                                            "controlId": "discoteq2",
                                            "column": 2,
                                            "row": 2
                                        },
                                        {
                                            "controlId": "devilGlass",
                                            "column": 4,
                                            "row": 6
                                        }
                                    ]
                                }
                            },
                            {
                                "controlId": "effects",
                                "column": 7,
                                "row": 3,
                                "width": 2,
                                "height": 7,
                                "layout": {
                                    "columns": 2,
                                    "rows": 7,
                                    "items": [
                                        {
                                            "controlId": "ripple",
                                            "column": 0,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "sparklez",
                                            "column": 0,
                                            "row": 2
                                        },
                                        {
                                            "controlId": "heart",
                                            "column": 1,
                                            "row": 5
                                        },
                                        {
                                            "controlId": "thatSAllFolks",
                                            "column": 1,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "beatShift",
                                            "column": 0,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "imageOverlay",
                                            "column": 0,
                                            "row": 5
                                        },
                                        {
                                            "controlId": "zigZag",
                                            "column": 1,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "blackout",
                                            "column": 1,
                                            "row": 6
                                        },
                                        {
                                            "controlId": "baaahsLogo",
                                            "column": 1,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "static",
                                            "column": 0,
                                            "row": 6
                                        },
                                        {
                                            "controlId": "rotateTwist",
                                            "column": 0,
                                            "row": 1
                                        }
                                    ]
                                }
                            },
                            {
                                "controlId": "globalControls",
                                "column": 9,
                                "row": 6,
                                "width": 3,
                                "height": 4,
                                "layout": {
                                    "columns": 4,
                                    "rows": 2,
                                    "matchParent": true,
                                    "items": [
                                        {
                                            "controlId": "brightness",
                                            "column": 0,
                                            "row": 0,
                                            "height": 4
                                        },
                                        {
                                            "controlId": "saturation",
                                            "column": 1,
                                            "row": 0,
                                            "height": 4
                                        },
                                        {
                                            "controlId": "hueShift",
                                            "column": 2,
                                            "row": 0,
                                            "height": 4
                                        }
                                    ]
                                }
                            },
                            {
                                "controlId": "visualizer",
                                "column": 9,
                                "row": 0,
                                "width": 3,
                                "height": 3
                            },
                            {
                                "controlId": "beatLink",
                                "column": 9,
                                "row": 3,
                                "width": 3,
                                "height": 3
                            }
                        ]
                    }
                ]
            }
        }
    },
    "shaders": {
        "xyProjection": {
            "title": "XY Projection",
            "src": "// XY Projection\n\nstruct ModelInfo {\n    vec3 center;\n    vec3 extents;\n};\nuniform ModelInfo modelInfo;\n\n// @return uv-coordinate\n// @param pixelLocation xyz-coordinate\nvec2 main(vec3 pixelLocation) {\n    vec3 pixelOffset = (pixelLocation - modelInfo.center) / modelInfo.extents + .5;\n    return vec2(pixelOffset.x, pixelOffset.y);\n}"
        },
        "darkness": {
            "title": "Darkness",
            "src": "void main(void) {\n    gl_FragColor = vec4(0., 0., 0., 1.);\n}"
        },
        "hsb": {
            "title": "HSB",
            "src": "// HSB\n\nuniform float brightness; // @@Slider min=0 max=1.25 default=1\nuniform float saturation; // @@Slider min=0 max=1.25 default=1\nuniform float hueShift; // @@Slider min=0 max=2 default=1\n\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// @return color\n// @param inColor color\nvec4 main(vec4 inColor) {\n    vec4 clampedColor = clamp(inColor, 0., 1.);\n    vec3 hsv = rgb2hsv(clampedColor.rgb);\n    hsv.x += hueShift;\n    hsv.y *= saturation;\n    hsv.z *= brightness;\n    return vec4(hsv2rgb(hsv), clampedColor.a);\n}"
        },
        "squarezzz": {
            "title": "[🐑] Squarezzz",
            "src": "// Square pulse thingy optimized for BAAAHS\n// originally based on https://www.shadertoy.com/view/XsBfRW\n\nuniform float time; // @@Time\nuniform vec2 resolution; // @@Resolution\nuniform float speed; // @@Slider default=3.0 min=1.0 max=5.0\n\n\nstruct BeatInfo {\n\tfloat beat;\n\tfloat bpm;\n\tfloat intensity;\n\tfloat confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n/* Returns a value which cycles from 0 to 1 for each beat, with most of the increase occuring near the beat */\nfloat beatIntegral() {\n\tfloat t = mod(beatInfo.beat, 1.);\n\tfloat POWER = 4.; // Adjusts sharpnett of the curve\n\tfloat OFFSET = 0.0; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n\treturn 1. - pow(1. - mod(t + OFFSET, 1.0), POWER);\n}\n\n/* Returns a monotonically increasing time value which with most of the increase occuring near the beat */\nfloat pulsedTime() {\n\tfloat timeAdjustment = beatIntegral() - mod(beatInfo.beat, 1.);\n\treturn speed * 0.87 * (time + .4 * timeAdjustment); // 0.87 keeps it from pausing at the same spot each cycle\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tfloat t = pulsedTime();\n\n\tfloat aspect = resolution.y/resolution.x;\n\tfloat value;\n\tvec2 uv = fragCoord.xy / iResolution.x;\n\tuv -= vec2(0.5, 0.5 * aspect);\n\tuv *= .6;\n\n\tfloat rot = radians(45.0); // radians(45.0*sin(t));\n\tmat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n\n\tuv = m * uv;\n\tuv += vec2(0.5, 0.5 * aspect);\n\tuv.y+=0.5*(1.0 - aspect);\n\tvec2 pos = 10.0 * uv;\n\tvec2 rep = fract(pos);\n\tfloat dist = 2.0*min(min(rep.x, 1.0-rep.x), min(rep.y, 1.0-rep.y));\n\tfloat squareDist = length((floor(pos)+vec2(0.5)) - vec2(5.0) );\n\n\tfloat edge = sin(t-squareDist*0.5)*0.5+0.5;\n\n\tedge = (t-squareDist*0.5)*0.5;\n\tedge = 2.0*fract(edge*0.5);\n\n\tvalue = fract (dist*2.0);\n\tvalue = mix(value, 1.0-value, step(1.0, edge));\n\n\tedge = pow(abs(1.0-edge), 2.0);\n\n\tvalue = smoothstep( edge-0.05, edge, 0.95*value);\n\n\n\tvalue += squareDist*.1;\n\n\tvec4 baseColor = vec4(0.5 + 0.5*cos(t+uv.xyx+vec3(0,2,4)), 1.0);\n\tfragColor = mix(vec4(1.0,1.0,1.0,1.0), baseColor, value);\n\tfragColor.a = 0.25*clamp(value, 0.0, 1.0);\n}\n\n"
        },
        "colorPulse": {
            "title": "[🐑] ColorPulse",
            "src": "// Color pulses sweeping from front to back of the sheep synchronized to the beat\n// Ben Bartlett\n\nuniform float time; // @@Time\nuniform float hueRange; // @@Slider default=0.3 min=0.0 max=1.0\nuniform float pulseSpeed; // @@Slider default=1.0 min=1.0 max=3.0\nuniform bool fromCenter; // @@Switch\nuniform vec2 center; // @@XyPad\n\n\nstruct BeatInfo {\n\tfloat beat;\n\tfloat bpm;\n\tfloat intensity;\n\tfloat confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n/* Returns a value which cycles from 0 to 1 for each beat, with most of the increase occuring near the beat */\nfloat beatIntegral() {\n\tfloat t = mod(beatInfo.beat, 1.);\n\tfloat POWER = 4.; // Adjusts sharpnett of the curve\n\tfloat OFFSET = 0.0; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n\treturn 1. - pow(1. - mod(t + OFFSET, 1.0), POWER);\n}\n\nvec3 hsl2rgb(in vec3 c) {\n\tvec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 hsv2rgb(vec3 c){\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// A pulse from 0 to 1 back to 0 with adjustable ramp and width\nfloat smoothstepPulse(float t) {\n\tfloat riseTime = 0.3;\n\tfloat peakTime = 0.2;\n\treturn smoothstep(0., 1., t / riseTime) - smoothstep(0., 1., (t - peakTime) / riseTime);\n}\n\n// @return color\n// @param uvIn uv-coordinate\nvec4 main(vec2 uvIn) {\n\n\tfloat s = uvIn.x;\n\tif (fromCenter) {\n\t\ts = distance(uvIn, center);\n\t}\n\n\tfloat pulse = smoothstepPulse(mod(beatIntegral() - s / (2.5*pulseSpeed), 1.));\n\n\tfloat H = .2 * time + s * hueRange;\n\tfloat S = .5 + .5 * pulse;\n\tfloat V = .2 + .6 * pulse;\n\n\treturn vec4(hsl2rgb(vec3(H,S,V)), 1.);\n}\n"
        },
        "geometricColorPulse": {
            "title": "[🐑] Geometric ColorPulse",
            "src": "// Make each physical panel a different color and swipe color pulses along the panels\n// Ben Bartlett\n\n// Color pulses sweeping from front to back of the sheep synchronized to the beat\n// Ben Bartlett\n\nuniform float time; // @@Time\nuniform float hueRange; // @@Slider default=0.3 min=0.0 max=1.0\nuniform float cycleSpeed; // @@Slider min=0.0 max=5.0 default=1.0\nuniform float pulseSpeed; // @@Slider default=1.0 min=1.0 max=3.0\n\nstruct FixtureInfo {\n\tvec3 boundaryMin;\n\tvec3 boundaryMax;\n};\nuniform FixtureInfo fixtureInfo; // @@FixtureInfo\n\nint getPanelID(FixtureInfo info) {\n\tfloat idX = (info.boundaryMin.x * (info.boundaryMin.x + info.boundaryMax.x));\n\tfloat idY = (info.boundaryMin.y * (info.boundaryMin.y + info.boundaryMax.y));\n\tfloat idZ = (info.boundaryMin.z * (info.boundaryMin.z + info.boundaryMax.z));\n\tint id = int(idX + idY + idZ);\n\treturn id;\n}\n\nstruct BeatInfo {\n\tfloat beat;\n\tfloat bpm;\n\tfloat intensity;\n\tfloat confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n/* Returns a value which cycles from 0 to 1 for each beat, with most of the increase occuring near the beat */\nfloat beatIntegral() {\n\tfloat t = mod(beatInfo.beat, 1.);\n\tfloat POWER = 4.; // Adjusts sharpness of the curve\n\tfloat OFFSET = 0.0; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n\treturn 1. - pow(1. - mod(t + OFFSET, 1.0), POWER);\n}\n\nvec3 hsl2rgb(in vec3 c) {\n\tvec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 hsv2rgb(vec3 c){\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// A pulse from 0 to 1 back to 0 with adjustable ramp and width\nfloat smoothstepPulse(float t) {\n\tfloat riseTime = 0.3;\n\tfloat peakTime = 0.2;\n\treturn smoothstep(0., 1., t / riseTime) - smoothstep(0., 1., (t - peakTime) / riseTime);\n}\n\n// @return color\n// @param uvIn uv-coordinate\nvec4 main(vec2 uvIn) {\n\n\tint panelID = getPanelID(fixtureInfo);\n\n\tfloat pulse = smoothstepPulse(mod(beatIntegral() - uvIn.x / (2.5*pulseSpeed), 1.));\n\n\tfloat H = .2 * time + hueRange * (uvIn.x + 0.3 * float((panelID % 6)) / 6.);\n\tfloat S = .5 + .5 * pulse;\n\tfloat V = .2 + .6 * pulse;\n\n\treturn vec4(hsl2rgb(vec3(H,S,V)), 1.);\n}\n"
        },
        "complexTrippyShit1": {
            "title": "[🐑] Complex Trippy Shit #1",
            "src": "// Complex Trippy Shit #1\n// Ben Bartlett\n\n#define PI 3.1415926535897932384626433832795\n#define ii vec2(0.0, 1.0)\n\nuniform float time; // @@Time\nuniform vec2 resolution; // @@Resolution\n\n// Complex multiplication\nvec2 cx_mul(vec2 a, vec2 b) {return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }\n// Complex division\nvec2 cx_div(vec2 a, vec2 b) { return vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y))); }\n// Modulus\nfloat cx_abs(vec2 z) { return length(z); }\n// Complex conjugate\nvec2 cx_conj(vec2 z) { return vec2(z.x, -z.y); }\n// Complex argument\nfloat cx_arg(vec2 z) { return atan(z.y, z.x); }\n// Sin cos and exponential for complex numbers\nvec2 cx_sin(vec2 z) { return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y)); }\nvec2 cx_cos(vec2 z) { return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y)); }\nvec2 cx_exp(vec2 z) { return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y)); }\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Complex math library ==========================\nvec2 cx_pow(vec2 z, float n) {\n    float angle = cx_arg(z);\n    float r = length(z);\n    float re = pow(r, n) * cos(n*angle);\n    float im = pow(r, n) * sin(n*angle);\n    return vec2(re, im);\n}\nvec2 cx_log(vec2 z) {\n    float rpart = sqrt((z.x*z.x)+(z.y*z.y));\n    float ipart = atan(z.y,z.x);\n    if (ipart > PI) ipart=ipart-(2.0*PI);\n    return vec2(log(rpart),ipart);\n}\nvec4 domainColoring (vec2 z, vec2 gridSpacing, float saturation, float gridStrength, float magStrength, float linePower) {\n    // Adapted from https://github.com/rreusser/glsl-domain-coloring\n    float carg = cx_arg(z);\n    float cmod = cx_abs(z);\n\n    float rebrt = pow((fract(z.x / gridSpacing.x) - 0.5) * 2.0, 2.);\n    float imbrt = pow((fract(z.y / gridSpacing.y) - 0.5) * 2.0, 2.);\n\n    float grid = 1.0 - (1.0 - rebrt) * (1.0 - imbrt);\n    grid = pow(abs(grid), linePower);\n\n    float circ = (fract(log2(cmod)) - 0.5) * 2.0;\n    circ = pow(abs(circ), linePower) * magStrength;\n\n    vec3 rgb = hsv2rgb(vec3(carg * 0.5 / PI, saturation, 0.5 + 0.5 * saturation - gridStrength * grid));\n    rgb *= (1.0 - circ);\n    rgb += circ * vec3(1.0);\n    return vec4(rgb, 1.0);\n}\n// =============================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.8 * (2. * fragCoord/resolution.xy - 1.);\n    uv *= vec2(16./9., 1.);\n    uv = vec2(-uv[1] - .2, uv[0]);\n\n    // Function is log(1/4 + iz^-3) + 2 exp(it)\n    vec2 fz = cx_log(vec2(.25, 0.0) + cx_pow(uv, -3.)) + 2. * cx_exp(time * ii);\n\n    float refz = fz[0];\n    float imfz = fz[1];\n    float argfz = cx_arg(fz) / (2.*PI);\n    float absfz = cx_abs(fz);\n\n    //float map = sin(refz + imfz) - log(absfz);\n    //float a=2.;\n    //map = pow(absfz, a) / (pow(absfz, a) + 1.);\n\n    fragColor = domainColoring(fz, vec2(1.0, 1.), 0.9, 1., 1., 1.);\n}"
        },
        "baaahzebra": {
            "title": "[🐑] BAAAHZebra",
            "src": "// Cool zebra pattern looking thing that alternates polarity on the beat\n// Ben Bartlett\n\nuniform float time; // @@Time\nuniform float speed; // @@Slider min=0.0 max=10.0 default=5.0\n\nstruct BeatInfo {\n\tfloat beat;\n\tfloat bpm;\n\tfloat intensity;\n\tfloat confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n// @return color\n// @param uv uv-coordinate\nvec4 main(vec2 uv) {\n\tfloat t = time * .01 * speed / 5.0;\n\tvec2 center = vec2(0.,0.);\n\n\tfloat periods = 4.1;\n\tcenter.y+=sin(uv.y*periods + t * 51.);\n\tcenter.x+=cos(uv.x*periods + t);\n\n\tfloat slantyness = 5.0;\n\tcenter.y+=sin(slantyness*(uv.x + uv.y));\n\tcenter.x+=sin(slantyness*(uv.x + uv.y));\n\n\tfloat d = distance(uv,center);\n\tfloat kFreq = 2.5;\n\n\tfloat k = -sin(d*6.283*kFreq - t);\n\tint beat = int(beatInfo.beat);\n\tif (beat % 2 == 0) {\n\t\tk *= -1.;\n\t}\n\n\tfloat e = smoothstep(0., fwidth(k)*1.5, k);\n\treturn vec4(sqrt(max(e, 0.)));\n}"
        },
        "orangeSnowflake": {
            "title": "Orange Snowflake",
            "src": "// Orange Snowflake\n// Modified from http://glslsandbox.com/e#61105.0\n\n/*\n * Original shader from: https://www.shadertoy.com/view/wl3XW8\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.141592\n#define TAU (2.*PI)\n\n// glslsandbox uniforms\nuniform float time; // @@Time\nuniform vec2 resolution; // @@Resolution\nuniform float speed; // @@Slider default=3.0 min=1.0 max=5.0\nuniform float pulsiness; // @@Slider default=3.0 min=1.0 max=5.0\n\n\n\n\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n/* Returns a value which cycles from 0 to 1 for each beat, with most of the increase occuring near the beat */\nfloat beatIntegral() {\n\tfloat t = mod(beatInfo.beat, 1.);\n\tfloat POWER = 4.; // Adjusts sharpnett of the curve\n\tfloat OFFSET = 0.0; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n\treturn 1. - pow(1. - mod(t + OFFSET, 1.0), POWER);\n}\n\n/* Returns a monotonically increasing time value which with most of the increase occuring near the beat */\nfloat pulsedTime() {\n    float timeAdjustment = beatIntegral() - mod(beatInfo.beat, 1.);\n    return speed * .25 * 0.87 * (time + .1 * pulsiness * timeAdjustment); // 0.87 keeps it from pausing at the same spot each cycle\n}\n\n\n\n\n// --------[ Original ShaderToy begins here ]---------- //\n// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me\n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\nfloat t = pulsedTime();\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.4,18.4)))*1245.4);}\n\nmat2 rot (float a)\n{return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat hd (vec2 uv)\n{\n    uv = abs(uv);\n    return max(uv.x, dot(uv, normalize(vec2(1., sqrt(3.)))));\n}\n\nvec4 hgrid (vec2 uv,float detail)\n{\n    uv *= detail;\n    vec2 ga = mod(uv,vec2(1., sqrt(3.)))-vec2(1., sqrt(3.))*0.5;\n    vec2 gb = mod(uv-vec2(1., sqrt(3.))*0.5,vec2(1., sqrt(3.)))-vec2(1., sqrt(3.))*0.5;\n    vec2 guv = (dot(ga,ga)< dot(gb,gb))? ga: gb;\n\n    vec2 gid = uv-guv;\n\n    guv.y = 0.5-hd(guv);\n\n    return vec4(guv,gid);\n}\n\nfloat hexf (vec2 uv)\n{\n    float det = 3.;\n    float s = 0.5;\n    float d = 0.;\n    for (float i=0.; i<3.; i++)\n    {\n        float ratio = i/5.;\n        uv *= rot(TAU/(5.));\n        uv = (mod(i,2.) == 0.) ? vec2(uv.x+t*s,uv.y) : vec2(uv.x,uv.y+t*s);\n        d += step(hgrid(uv, det).y,0.03);\n        s -= 0.1;\n        det ++;\n    }\n    return d;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat fractal (vec3 p)\n{\n    float size = 1.;\n    float d = box(p,vec3(size));\n    for (float i=0.; i<5.; i++)\n    {\n        float ratio = i/5.;\n        p.yz *= rot(t);\n        mo(p.xz, vec2(2.+ratio));\n        mo(p.xy, vec2(0.5+ratio));\n        p.xy *= rot(t+ratio);\n        size -= ratio*1.5;\n        d= stmin(d,box(p,vec3(size)),1., 4.);\n    }\n    return d;\n}\n\nfloat g1 = 0.;\nfloat SDF (vec3 p)\n{\n    float d = fractal(p);\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-resolution.xy)/resolution.y;\n\n    float mask = 1.0;//step(0.3, abs(sin(length(uv)-PI*t))+0.01);\n    float fx = 0.0;//clamp(mix(1.-hexf(uv), hexf(uv), mask),0.,1.);\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(0.,0.,-10.),\n    p = ro,\n    rd = normalize(vec3(uv,1.)),\n    col = vec3(0.);\n\n    float shad = 0.;\n\n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/64.;\n            break;\n        }\n        d *= 0.7+dither*0.1;\n        p += d*rd;\n    }\n\n    col = vec3(2.,length(uv*0.5),0.1)*g1*0.2;\n    col *= (1.-fx);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n"
        },
        "acidAtTheDisco": {
            "title": "Acid at the Disco",
            "src": "// Acid at the Disco\n// Modified from: https://www.shadertoy.com/view/4sfXRB\n\nuniform float time; // @@Time\nuniform vec2 resolution; // @@Resolution\nuniform float speed; // @@Slider default=3.0 min=1.0 max=5.0\nuniform float pulsiness; // @@Slider default=3.0 min=1.0 max=5.0\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\nfloat beatIntegral() {\n    float t = mod(beatInfo.beat, 1.);\n    float POWER = 4.; // Adjusts sharpnett of the curve\n    float OFFSET = 0.0; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n    return 1. - pow(1. - mod(t + OFFSET, 1.0), POWER);\n}\n\nfloat pulsedTime() {\n    float timeAdjustment = beatIntegral() - mod(beatInfo.beat, 1.);\n    return speed * .25 * 0.87 * (time + .1 * pulsiness * timeAdjustment); // 0.87 keeps it from pausing at the same spot each cycle\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / resolution.xy;\n    float t = pulsedTime();\n    float depth = sin(uv.y*2.0+sin(t)*1.5+1.0+sin(uv.x*3.0+t*1.2))*cos(uv.y*2.0+t)+sin((uv.x*3.0+t));\n    float texey = (uv.x-0.5);\n    float xband = sin(sqrt(uv.y/uv.y)*16.0/(depth)+t*3.0);\n    float final = (\n    sin(texey/abs(depth)*32.0+t*16.0+sin(uv.y*uv.x*32.0*sin(depth*3.0)))*(depth)*xband\n    );\n\n\n    fragColor = vec4(-final*abs(sin(t)),(-final*sin(t)*2.0),(final),1.0)*1.5;\n}"
        },
        "picassoSNightmare": {
            "title": "Picasso's Nightmare",
            "src": "// Picasso's Nightmare\n// From http://glslsandbox.com/e#56499\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nconst float n_circles = 800.0;\nconst float max_radius = 1.0;\nconst float min_radius = 0.5;\nconst float seed1 = 69.7;\nconst float seed2 = 82.4;\nconst float seed3 = 62.5;\n\nfloat rand(float x, float seed) {\n    return fract(sin(x) * seed);\n}\n\nfloat randFromTo(float x, float seed, float min, float max){\n\treturn rand(x, seed) * (max - min) + min;\n}\n\nbool drawCircle(vec2 pos, vec2 center, float radius, inout vec3 color) {\n\tvec2 translatedCenter = vec2(sin(time) * randFromTo(center.x, seed1, -1.8, 1.8) + center.x, sin(time) * randFromTo(center.y, seed1, -1., 1.) + center.y);\n\tfloat distance = distance(pos, translatedCenter);\n\tbool ret =  distance <= radius;\n\tif (ret) {\n\t\tfloat m = max (0.2, smoothstep(radius, radius / 3., distance));\n\t\tcolor = vec3(rand(center.x, seed1) * m,rand(center.y, seed2) * m, rand(center.x + center.y, seed3) * m);\n\t}\n\treturn ret;\n}\n\nvoid drawCircles(vec2 pos, float radiusMultiplier, inout vec3 color) {\n\tfor (float i=0.; i<n_circles; i++){\n\t\tif (drawCircle(pos, vec2(randFromTo(i, seed1, -1.8, 1.8), randFromTo(i, seed2, -1., 1.)), randFromTo(i, seed3, min_radius, max_radius) * radiusMultiplier, color)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid main( void ) {\n\tfloat minRes = min(resolution.x, resolution.y);\n\tvec2 pos = (gl_FragCoord.xy * 2. - resolution) / minRes;\n\tfloat radiusMultiplier = abs(sin(time + 4. * (pos.x * pos.y)));\n\tvec3 color = vec3(pos.y, pos.y, pos.y);\n\tdrawCircles(pos, radiusMultiplier, color);\n\tgl_FragColor = vec4(color, 1);\n}\n"
        },
        "plasma": {
            "title": "Plasma",
            "src": "// Based on https://www.shadertoy.com/view/MdBGzK\n\n#define DPII (3.1415926535*2.0)\n\n// 0 -> Blue / Pink\n// 1 -> Blue / Green\n// 2 -> Black / White\n// 3 -> Blue / Teal / Black\n// 4 -> Black / White\nint GetPlasmaIndex(int t)\n{\n\treturn 0;\n}\n\nconst int initialL1[5] = int[5](1000, 1000, 3500, 1000, 1000);\nconst int initialL2[5] = int[5](2000, 2000, 1000, 2000, 2000);\nconst int initialL3[5] = int[5](3000, 4000, 3000, 3000, 3000);\nconst int initialL4[5] = int[5](4000, 4000, 1000, 4000, 4000);\n\nconst int initialK1[5] = int[5](3500, 1500, 3500, 3500, 3500);\nconst int initialK2[5] = int[5](2300, 2300, 3300, 2300, 2300);\nconst int initialK3[5] = int[5](3900, 3900, 2900, 3900, 3900);\nconst int initialK4[5] = int[5](3670, 1670, 2670, 3670, 3670);\n\nint GetC1(int nXOffset0or1, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\n\tint nResult = 0;\n\tif (nXOffset0or1 == 0)\n\t{\n\t\tnResult = initialK1[nPlasmaIndex] + (-3 * t);\n\t}\n\telse\n\t{\n\t\tnResult = initialL1[nPlasmaIndex] + (-1 * t);\n\t}\n\t\n\tfloat fResult = float(nResult);\n\tfResult = mod(fResult, 4096.0);\n\n\tif (fResult < 0.0)\n\t{\n\t\tfResult += 4096.0;\n\t}\n\tnResult = int(fResult);\n\n\treturn nResult;\n}\n\nint GetC2(int nXOffset0or1, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\n\tint nResult = 0;\n\tif (nXOffset0or1 == 0)\n\t{\n\t\tnResult = initialK2[nPlasmaIndex] + (-2 * t);\n\t}\n\telse\n\t{\n\t\tnResult = initialL2[nPlasmaIndex] + (-2 * t);\n\t}\n\t\n\tfloat fResult = float(nResult);\n\tfResult = mod(fResult, 4096.0);\n\n\tif (fResult < 0.0)\n\t{\n\t\tfResult += 4096.0;\n\t}\n\tnResult = int(fResult);\n\n\treturn nResult;\n}\n\nint GetC3(int nXOffset0or1, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\n\tint nResult = 0;\n\tif (nXOffset0or1 == 0)\n\t{\n\t\tnResult = initialK3[nPlasmaIndex] + (1 * t);\n\t}\n\telse\n\t{\n\t\tnResult = initialL3[nPlasmaIndex] + (2 * t);\n\t}\n\t\n\tfloat fResult = float(nResult);\n\tfResult = mod(fResult, 4096.0);\n\n\tif (fResult < 0.0)\n\t{\n\t\tfResult += 4096.0;\n\t}\n\tnResult = int(fResult);\n\n\treturn nResult;\n}\n\nint GetC4(int nXOffset0or1, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\n\tint nResult = 0;\n\tif (nXOffset0or1 == 0)\n\t{\n\t\tnResult = initialK4[nPlasmaIndex] + (2 * t);\n\t}\n\telse\n\t{\n\t\tnResult = initialL4[nPlasmaIndex] + (3 * t);\n\t}\n\t\n\tfloat fResult = float(nResult);\n\tfResult = mod(fResult, 4096.0);\n\n\tif (fResult < 0.0)\n\t{\n\t\tfResult += 4096.0;\n\t}\n\tnResult = int(fResult);\n\n\treturn nResult;\n}\n\nfloat Palette0_GetRed(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = fIndex;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t\ta = 63.0 - a;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 192.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette0_GetGreen(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette0_GetBlue(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = fIndex;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t\ta = 63.0 - a;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 192.0;\n\t\ta = 63.0 - a;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette1_GetRed(float fIndex)\n{\n\t\treturn 0.0;\n\t\t\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = fIndex;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t\ta = 63.0 - a;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 192.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette1_GetGreen(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t}\n\telse\n\t{\n\t\ta = 63.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette1_GetBlue(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 192.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette2_GetRed(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 2.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette2_GetGreen(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 2.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette2_GetBlue(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 2.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette3_GetRed(float fIndex)\n{\n\t\treturn 0.0;\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = fIndex;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = 63.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette3_GetGreen(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette3_GetBlue(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = 63.0;\n\t}\n\telse\n\t{\n\t\ta = 63.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette4_GetRed(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 75.0))\n\t{\n\t\ta = fIndex;\n\t\ta = 63.0 - a * 64.0 / 75.0;\n\t}\n\telse if ((fIndex >= 75.0) && (fIndex < 181.0))\n\t{\n\t\treturn 0.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 181.0;\n\t\ta = (a * 64.0 / 75.0) * 8.0 / 10.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette4_GetGreen(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 75.0))\n\t{\n\t\ta = fIndex;\n\t\ta = 63.0 - a * 64.0 / 75.0;\n\t}\n\telse if ((fIndex >= 75.0) && (fIndex < 181.0))\n\t{\n\t\treturn 0.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 181.0;\n\t\ta = (a * 64.0 / 75.0) * 9.0 / 10.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette4_GetBlue(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 75.0))\n\t{\n\t\ta = fIndex;\n\t\ta = 63.0 - a * 64.0 / 75.0;\n\t}\n\telse if ((fIndex >= 75.0) && (fIndex < 181.0))\n\t{\n\t\treturn 0.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 181.0;\n\t\ta = (a * 64.0 / 75.0);\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette_GetRed(float fIndex, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\tfloat fResult = 0.0;\n\n\tif (nPlasmaIndex == 0)\n\t{\n\t\tfResult = Palette0_GetRed(fIndex);\n\t}\n\telse if (nPlasmaIndex == 1)\n\t{\n\t\tfResult = Palette1_GetRed(fIndex);\n\t}\n\telse if (nPlasmaIndex == 2)\n\t{\n\t\tfResult = Palette2_GetRed(fIndex);\n\t}\n\telse if (nPlasmaIndex == 3)\n\t{\n\t\tfResult = Palette3_GetRed(fIndex);\n\t}\n\telse if (nPlasmaIndex == 4)\n\t{\n\t\tfResult = Palette4_GetRed(fIndex);\n\t}\n\n\treturn fResult;\n}\nfloat Palette_GetGreen(float fIndex, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\tfloat fResult = 0.0;\n\n\tif (nPlasmaIndex == 0)\n\t{\n\t\tfResult = Palette0_GetGreen(fIndex);\n\t}\n\telse if (nPlasmaIndex == 1)\n\t{\n\t\tfResult = Palette1_GetGreen(fIndex);\n\t}\n\telse if (nPlasmaIndex == 2)\n\t{\n\t\tfResult = Palette2_GetGreen(fIndex);\n\t}\n\telse if (nPlasmaIndex == 3)\n\t{\n\t\tfResult = Palette3_GetGreen(fIndex);\n\t}\n\telse if (nPlasmaIndex == 4)\n\t{\n\t\tfResult = Palette4_GetGreen(fIndex);\n\t}\n\n\treturn fResult;\n}\nfloat Palette_GetBlue(float fIndex, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\tfloat fResult = 0.0;\n\n\tif (nPlasmaIndex == 0)\n\t{\n\t\tfResult = Palette0_GetBlue(fIndex);\n\t}\n\telse if (nPlasmaIndex == 1)\n\t{\n\t\tfResult = Palette1_GetBlue(fIndex);\n\t}\n\telse if (nPlasmaIndex == 2)\n\t{\n\t\tfResult = Palette2_GetBlue(fIndex);\n\t}\n\telse if (nPlasmaIndex == 3)\n\t{\n\t\tfResult = Palette3_GetBlue(fIndex);\n\t}\n\telse if (nPlasmaIndex == 4)\n\t{\n\t\tfResult = Palette4_GetBlue(fIndex);\n\t}\n\n\treturn fResult;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// t is an integer frame count.\n\tint t = int(iTime * 60.0);\n\n\t// fPlasmaX is a float from 0 to 319,\n\t// fPlasmaY is a float from 0 to 399.\n\tfloat fPlasmaX = (fragCoord.x / iResolution.x) * 319.0;\n\tfloat fPlasmaY = (fragCoord.y / iResolution.y) * 399.0;\n\tfPlasmaY = 399.0 - fPlasmaY;\n\n\tfloat fRed = 0.0;\n\tfloat fGreen = 0.0;\n\tfloat fBlue = 0.0;\n\n\tfloat fScreenX = fragCoord.x;\n\tfloat fScreenY = fragCoord.y;\n\tfloat ah = 0.0;\n\tfloat ccc = fPlasmaX / 4.0;\n\tfloat fOffset = 0.0;\n\tfloat bx = 0.0;\n\n\tint nXOffset0or1 = int(mod(fScreenX, 2.0));\n\t// On every odd row, toggle the x offset. This causes different plasma constants to be\n\t// read for these pixels, achieving a chequered overlay of two plasmas.\n\tint xor = int(mod(fScreenY, 2.0));\n\tif (xor == 1)\n\t{\n\t\tif (nXOffset0or1 == 0)\n\t\t{\n\t\t\tnXOffset0or1 = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnXOffset0or1 = 0;\n\t\t}\n\t}\n\n\tfloat c1 = float(GetC1(nXOffset0or1, t));\n\tfloat c2 = float(GetC2(nXOffset0or1, t));\n\tfloat c3 = float(GetC3(nXOffset0or1, t));\n\tfloat c4 = float(GetC4(nXOffset0or1, t));\n\n\tfOffset = ((fPlasmaY * 2.0) + (c2 * 2.0) - (ccc * 8.0) + (80.0 * 8.0)) / 2.0;\n\tbx = ((sin(fOffset*DPII/4096.0)*55.0+sin(fOffset*DPII/4096.0*4.0)*5.0+sin(fOffset*DPII/4096.0*17.0)*3.0+64.0)*16.0);\n\n\tfOffset = bx + c1 + (ccc * 8.0);\n\tah = (sin(fOffset*DPII/4096.0)*55.0+sin(fOffset*DPII/4096.0*6.0)*5.0+sin(fOffset*DPII/4096.0*21.0)*4.0+64.0);\n\n\tfOffset = ((fPlasmaY * 2.0) + (c4 * 2.0) + (ccc * 32.0)) / 2.0;\n\tbx = ((sin(fOffset*DPII/4096.0)*55.0+sin(fOffset*DPII/4096.0*5.0)*8.0+sin(fOffset*DPII/4096.0*15.0)*2.0+64.0)*8.0);\n\n\tfOffset = bx + (fPlasmaY * 2.0) + c3 - (ccc * 4.0) + (80.0 * 4.0);\n\tah += (sin(fOffset*DPII/4096.0)*55.0+sin(fOffset*DPII/4096.0*6.0)*5.0+sin(fOffset*DPII/4096.0*21.0)*4.0+64.0);\n\n\tfloat fPaletteIndex = ah;\n\n\tfRed = Palette_GetRed(fPaletteIndex, t);\n\tfGreen = Palette_GetGreen(fPaletteIndex, t);\n\tfBlue = Palette_GetBlue(fPaletteIndex, t);\n\n\tfragColor = vec4(fRed, fGreen, fBlue, 1.0);\n}\n"
        },
        "wobblyColorGrid": {
            "title": "Wobbly Color Grid",
            "src": "// Wobbly Color Grid\n// From http://glslsandbox.com/e#60808.1\n\n//  modded by Mik - v1.1\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//#extension GL_OES_standard_derivatives : enable\n\n//varying vec2 surfacePosition;\nuniform float time; // @@Time\nuniform vec2 center; // @@XyPad\nuniform vec2 resolution; // @@Resolution\n\nvoid main(void){\n\n    float PI = 3.141592;\n    vec2 p = gl_FragCoord.xy/resolution*2.;\n\n    float time = time + length(p)*cos(time/4. - .0001*length(p)*cos(time/PI + .0001*length(p)*cos(time*time/PI)));\n    vec3 color = vec3(0., length(p), 0.);\n\n    float f = 0.0;\n\n    for(float i = 0.0; i < 15.0; i++){\n        float s = sin(center.x + time + center.x * i * PI / 10.0) * .85;\n        float c = cos(center.y + time + center.y * i * PI / 10.0) * .93;\n\n        f += 0.001 / (abs(p.x + c / (.35+length(p))) * abs(p.y + s / (.35+length(p)))) / (.5+length(p));\n        color.r += s * 1.0 * PI;\n        color.b += c * 1.0 * PI;\n    }\n\n\n    gl_FragColor = vec4(vec3(f * color), 1.0);\n}"
        },
        "gadzooks": {
            "title": "Gadzooks",
            "src": "// Gadzooks\n// From: http://glslsandbox.com/e#43036.0\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nvoid main( void ) {\n\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    p = p * 2.0 - 1.0;\n    p.x *= resolution.x / resolution.y;\n\n    float col = 0.0;\n\n    //mandelbrote\n    //vec2 z = vec2(0.0, 0.0);\n    //juillaset\n    vec2 z = p;\n    vec2 ms = mouse.xy * 2.0 - 1.0;\n    ms.x *= resolution.x / resolution.y;\n\n    for(int i = 0; i < 5; i++)\n    {\n        //mandelbrote\n        z = vec2(z.x * z.x - z.y * z.y + cos(time) *2.0, 2.0 * z.x * z.y) + ms;\n        //julliaset\n        //z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + P;\n    }\n    col = length(z);\n\n    gl_FragColor = vec4(vec3(z.x, z.y, col), 1.0);\n\n}\n"
        },
        "gaiaSOrgasm": {
            "title": "Gaia's Orgasm",
            "src": "// Gaia's Orgasm\n// From http://glslsandbox.com/e#46597\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n//from https://www.shadertoy.com/view/4dl3zn\n\nvoid main( void ) {\n\n\tvec2 uv = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;\n\tuv.x *=  resolution.x / resolution.y;\n\n    // background\n\tvec3 color = vec3(0.8 + 0.2*uv.y);\n\n    // bubbles\n\tfor( int i=0; i<40; i++ )\n\t{\n        // bubble seeds\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * resolution.x / resolution.y;\n\n        // buble size, position and color\n\t\tfloat rad = 0.1 + 0.5*siz;\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*time*(0.2+0.8*siz),1.0));\n\t\tfloat dis = length( uv - pos );\n\t\tvec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\n\n        // render\n\t\tfloat f = length(uv-pos)/rad;\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\n\t}\n\n    // vigneting\n\tcolor *= sqrt(1.5-0.5*length(uv));\n\n\tgl_FragColor = vec4(color,1.0);\n}\n"
        },
        "faeriePulse": {
            "title": "Faerie Pulse",
            "src": "// Færie Pulse\n// From http://glslsandbox.com/e#46723\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n\nfloat rand(int seed, float ray) {\n  return mod(sin(float(seed)*1.0+ray*1.0)*1.0, 1.0);\n}\n\nmat2 rotate2d(float _angle) {\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n  vec3 uv3 = vec3(sin(time*0.1), uv);\n  vec2 center = resolution / max(resolution.x, resolution.y) * 0.5;\n\n  //float a = rand(5234, uv.x)*6.2+time*5.0*(rand(2534, uv.y)-rand(3545, uv.x));\n  float a = distance(uv, center)*rand(5234, uv.x)-6.2*(rand(2534, uv.y));\n\n  float ac = cos(time*0.1-a);\n  float as = sin(time*0.1+a);\n  uv3 *= mat3(\n  ac, as, 0.0, -as, ac, 0.0, 0.0, 0.0, 1.0);\n  uv.x = uv3.x;\n  uv.y = uv3.y;\n  //uv = rotate2d(time*0.1)*uv;\n  uv = mod(uv, 0.5) * 2.0;\n  //uv.x = cos(time-a);\n  //uv.y = sin(time+a);\n  gl_FragColor = vec4(uv, cos(distance(uv, center)), 1.0);\n}\n"
        },
        "yasQueen": {
            "title": "Yas Queen",
            "src": "// Yas Queen\n// From http://glslsandbox.com/e#46613\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n// EXAMPLE FROM https://www.shadertoy.com/view/lstfRH\n#define PI 3.141592653589793\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvoid main( void ) {\n\n    vec3 col;\n    float x = gl_FragCoord.x + sin(time/PI) * resolution.x / 4.0;\n    float y = gl_FragCoord.y + cos(time/PI) * resolution.y / 2.0;\n    float hue = sin(x / resolution.x) + cos(y / resolution.y) + sin((x + y) / 500.0) + cos(sqrt(x * x + y * y) / 100.0);\n\n    col = hsv2rgb(vec3(hue + time/8.0, 1.0, mod(time, 1000.0)));\n\n    gl_FragColor = vec4(col, 1);\n}\n"
        },
        "geometricSheep": {
            "title": "[🐑] Geometric Sheep",
            "src": "// Make each physical panel a different color and change the colors on the beat\n// Ben Bartlett\n\n/* Minified color palettes library */\nvec4 mix_color(vec4 color1, vec4 color2, float x) { return mix(color1, color2, vec4(x,x,x,x)); }\nvec4 get_color(vec4 colors[11], float x) { int index = int(10.*x); if (index >= 10) { return colors[10]; } else { float remainder = (10. * x) - floor(10.*x); return mix_color(colors[index], colors[index+1], remainder); } }\nvec4 viridis(float x) { return get_color(vec4[11](vec4(0.267004, 0.004874, 0.329415, 1.0), vec4(0.282623, 0.140926, 0.457517, 1.0), vec4(0.253935, 0.265254, 0.529983, 1.0), vec4(0.206756, 0.371758, 0.553117, 1.0), vec4(0.163625, 0.471133, 0.558148, 1.0), vec4(0.127568, 0.566949, 0.550556, 1.0), vec4(0.134692, 0.658636, 0.517649, 1.0), vec4(0.266941, 0.748751, 0.440573, 1.0), vec4(0.477504, 0.821444, 0.318195, 1.0), vec4(0.741388, 0.873449, 0.149561, 1.0), vec4(0.993248, 0.906157, 0.143936, 1.0)), x); }\nvec4 plasma(float x) { return get_color(vec4[11](vec4(0.050383, 0.029803, 0.527975, 1.0), vec4(0.254627, 0.013882, 0.615419, 1.0), vec4(0.417642, 0.000564, 0.65839, 1.0), vec4(0.562738, 0.051545, 0.641509, 1.0), vec4(0.69284, 0.165141, 0.564522, 1.0), vec4(0.798216, 0.280197, 0.469538, 1.0), vec4(0.881443, 0.392529, 0.383229, 1.0), vec4(0.949217, 0.517763, 0.295662, 1.0), vec4(0.98826, 0.652325, 0.211364, 1.0), vec4(0.988648, 0.809579, 0.145357, 1.0), vec4(0.940015, 0.975158, 0.131326, 1.0)), x); }\nvec4 inferno(float x) { return get_color(vec4[11](vec4(0.001462, 0.000466, 0.013866, 1.0), vec4(0.087411, 0.044556, 0.224813, 1.0), vec4(0.258234, 0.038571, 0.406485, 1.0), vec4(0.416331, 0.090203, 0.432943, 1.0), vec4(0.578304, 0.148039, 0.404411, 1.0), vec4(0.735683, 0.215906, 0.330245, 1.0), vec4(0.865006, 0.316822, 0.226055, 1.0), vec4(0.954506, 0.468744, 0.099874, 1.0), vec4(0.987622, 0.64532, 0.039886, 1.0), vec4(0.964394, 0.843848, 0.273391, 1.0), vec4(0.988362, 0.998364, 0.644924, 1.0)), x); }\nvec4 magma(float x) { return get_color(vec4[11](vec4(0.001462, 0.000466, 0.013866, 1.0), vec4(0.078815, 0.054184, 0.211667, 1.0), vec4(0.232077, 0.059889, 0.437695, 1.0), vec4(0.390384, 0.100379, 0.501864, 1.0), vec4(0.550287, 0.161158, 0.505719, 1.0), vec4(0.716387, 0.214982, 0.47529, 1.0), vec4(0.868793, 0.287728, 0.409303, 1.0), vec4(0.967671, 0.439703, 0.35981, 1.0), vec4(0.994738, 0.62435, 0.427397, 1.0), vec4(0.99568, 0.812706, 0.572645, 1.0), vec4(0.987053, 0.991438, 0.749504, 1.0)), x); }\nvec4 spring(float x) { return get_color(vec4[11](vec4(1.0, 0.0, 1.0, 1.0), vec4(1.0, 0.09803921568627451, 0.9019607843137255, 1.0), vec4(1.0, 0.2, 0.8, 1.0), vec4(1.0, 0.2980392156862745, 0.7019607843137254, 1.0), vec4(1.0, 0.4, 0.6, 1.0), vec4(1.0, 0.5019607843137255, 0.4980392156862745, 1.0), vec4(1.0, 0.6, 0.4, 1.0), vec4(1.0, 0.7019607843137254, 0.29803921568627456, 1.0), vec4(1.0, 0.8, 0.19999999999999996, 1.0), vec4(1.0, 0.9019607843137255, 0.0980392156862745, 1.0), vec4(1.0, 1.0, 0.0, 1.0)), x); }\nvec4 summer(float x) { return get_color(vec4[11](vec4(0.0, 0.5, 0.4, 1.0), vec4(0.09803921568627451, 0.5490196078431373, 0.4, 1.0), vec4(0.2, 0.6, 0.4, 1.0), vec4(0.2980392156862745, 0.6490196078431373, 0.4, 1.0), vec4(0.4, 0.7, 0.4, 1.0), vec4(0.5019607843137255, 0.7509803921568627, 0.4, 1.0), vec4(0.6, 0.8, 0.4, 1.0), vec4(0.7019607843137254, 0.8509803921568627, 0.4, 1.0), vec4(0.8, 0.9, 0.4, 1.0), vec4(0.9019607843137255, 0.9509803921568627, 0.4, 1.0), vec4(1.0, 1.0, 0.4, 1.0)), x); }\nvec4 autumn(float x) { return get_color(vec4[11](vec4(1.0, 0.0, 0.0, 1.0), vec4(1.0, 0.09803921568627451, 0.0, 1.0), vec4(1.0, 0.2, 0.0, 1.0), vec4(1.0, 0.2980392156862745, 0.0, 1.0), vec4(1.0, 0.4, 0.0, 1.0), vec4(1.0, 0.5019607843137255, 0.0, 1.0), vec4(1.0, 0.6, 0.0, 1.0), vec4(1.0, 0.7019607843137254, 0.0, 1.0), vec4(1.0, 0.8, 0.0, 1.0), vec4(1.0, 0.9019607843137255, 0.0, 1.0), vec4(1.0, 1.0, 0.0, 1.0)), x); }\nvec4 winter(float x) { return get_color(vec4[11](vec4(0.0, 0.0, 1.0, 1.0), vec4(0.0, 0.09803921568627451, 0.9509803921568627, 1.0), vec4(0.0, 0.2, 0.9, 1.0), vec4(0.0, 0.2980392156862745, 0.8509803921568627, 1.0), vec4(0.0, 0.4, 0.8, 1.0), vec4(0.0, 0.5019607843137255, 0.7490196078431373, 1.0), vec4(0.0, 0.6, 0.7, 1.0), vec4(0.0, 0.7019607843137254, 0.6490196078431373, 1.0), vec4(0.0, 0.8, 0.6, 1.0), vec4(0.0, 0.9019607843137255, 0.5490196078431373, 1.0), vec4(0.0, 1.0, 0.5, 1.0)), x); }\nvec4 cool(float x) { return get_color(vec4[11](vec4(0.0, 1.0, 1.0, 1.0), vec4(0.09803921568627451, 0.9019607843137255, 1.0, 1.0), vec4(0.2, 0.8, 1.0, 1.0), vec4(0.2980392156862745, 0.7019607843137254, 1.0, 1.0), vec4(0.4, 0.6, 1.0, 1.0), vec4(0.5019607843137255, 0.4980392156862745, 1.0, 1.0), vec4(0.6, 0.4, 1.0, 1.0), vec4(0.7019607843137254, 0.29803921568627456, 1.0, 1.0), vec4(0.8, 0.19999999999999996, 1.0, 1.0), vec4(0.9019607843137255, 0.0980392156862745, 1.0, 1.0), vec4(1.0, 0.0, 1.0, 1.0)), x); }\nvec4 hot(float x) { return get_color(vec4[11](vec4(0.0416, 0.0, 0.0, 1.0), vec4(0.2989711013608711, 0.0, 0.0, 1.0), vec4(0.5666370467761772, 0.0, 0.0, 1.0), vec4(0.8240081481370484, 0.0, 0.0, 1.0), vec4(1.0, 0.09166747604035141, 0.0, 1.0), vec4(1.0, 0.359314099938117, 0.0, 1.0), vec4(1.0, 0.6166666229167378, 0.0, 1.0), vec4(1.0, 0.8843132468145034, 0.0, 1.0), vec4(1.0, 1.0, 0.21249921249921258, 1.0), vec4(1.0, 1.0, 0.6139702022054964, 1.0), vec4(1.0, 1.0, 1.0, 1.0)), x); }\nvec4 jet(float x) { return get_color(vec4[11](vec4(0.0, 0.0, 0.5, 1.0), vec4(0.0, 0.0, 0.945632798573975, 1.0), vec4(0.0, 0.3, 1.0, 1.0), vec4(0.0, 0.692156862745098, 1.0, 1.0), vec4(0.16129032258064513, 1.0, 0.8064516129032259, 1.0), vec4(0.4901960784313725, 1.0, 0.4775458570524984, 1.0), vec4(0.8064516129032256, 1.0, 0.16129032258064513, 1.0), vec4(1.0, 0.7705156136528688, 0.0, 1.0), vec4(1.0, 0.40740740740740755, 0.0, 1.0), vec4(0.9456327985739753, 0.029774872912127992, 0.0, 1.0), vec4(0.5, 0.0, 0.0, 1.0)), x); }\n\n\nuniform float time; // @@Time\nuniform float cycleSpeed; // @@Slider min=0.0 max=10.0 default=1.0\nuniform float hueSpread; // @@Slider min=0.0 max=10.0 default=2.0\n\nstruct BeatInfo {\n\tfloat beat;\n\tfloat bpm;\n\tfloat intensity;\n\tfloat confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\nstruct FixtureInfo {\n\tvec3 boundaryMin;\n\tvec3 boundaryMax;\n};\nuniform FixtureInfo fixtureInfo; // @@FixtureInfo\n\nint getPanelID(FixtureInfo info) {\n\tfloat idX = (info.boundaryMin.x * (info.boundaryMin.x + info.boundaryMax.x));\n\tfloat idY = (info.boundaryMin.y * (info.boundaryMin.y + info.boundaryMax.y));\n\tfloat idZ = (info.boundaryMin.z * (info.boundaryMin.z + info.boundaryMax.z));\n\tint id = int(idX + idY + idZ);\n\treturn id;\n}\n\n/* Linearly slide from min to max by varying x from 0 to 1 */\nfloat linear(float min, float max, float x) {\n\treturn min + (max - min) * x;\n}\n\n/* Replace with color palette of your choice */\nvec4 COLOR(float x) {\n\tfloat colorMin = 0.2;\n\tfloat colorMax = 0.8;\n\treturn plasma(linear(colorMin, colorMax, x));\n}\n\n/* Alternate color option: instead of color palettes, pick hsv values and vary to the beat */\nvec3 hsv2rgb(vec3 c){ vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }\nvec4 COLOR_HSV_EVOLVE(float x) {\n\tfloat hue = (cycleSpeed/20. * time) + (0.05 * hueSpread * x);\n\tfloat value = 1.0 - (0.3 * x);\n\treturn vec4(hsv2rgb(vec3( hue, 1.0, value)), 1.0);\n}\n\n// @return color\n// @param uvIn uv-coordinate\nvec4 main(vec2 uvIn) {\n\tint panelID = getPanelID(fixtureInfo);\n\tint colorIndex = (int(beatInfo.beat) + panelID) % 4;\n\tbool use_hsv = true;\n\tif (use_hsv) {\n\t\treturn COLOR_HSV_EVOLVE(0.33 * float(colorIndex));\n\t} else {\n\t\treturn COLOR(0.33 * float(colorIndex));\n\t}\n}\n"
        },
        "aquaticFlood": {
            "title": "Aquatic Flood",
            "src": "// Aquatic Flood\n// From http://glslsandbox.com/e#46102\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\nuniform float sm_beat;\n\nvoid main(void)\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    //uv.x *= resolution.x/resolution.y;\n    float dist = 0.;\n    uv.x = -2.+4.*uv.x;\n    uv.y = -1.+2.*uv.y;\n    // comment the next line to see the fully zoomed out view\n    uv *=pow(.1,4.+cos(.1*time));\n    uv.x += .275015;//;\n    uv.y += .0060445;//\n    //uv /= 5.;\n    //vec4 col =vec4(1.);\n    vec2 z = vec2(0.0);\n\n    float warp_factor = 1.;\n    float time_warp = sm_beat / (1. / warp_factor) - (warp_factor / 2.) + 1.;\n    vec4 beat_flash = vec4(time_warp);\n\n    int trap=0;\n    for(int i = 0; i < 400; i++){\n        if(dot(z,z)>4.){trap = i;break;}\n        dist = min( 1e20, dot(z,z))+cos(float(i)*12.+3.*time);\n        z = mat2(z,-z.y,z.x)*z + uv;\n    }\n    dist = sqrt(dist);\n\tfloat orb = sqrt(float(trap))/64.;\n    gl_FragColor=vec4(0.,log(dist)*sqrt(dist)-orb-orb,log(dist)*sqrt(dist-abs(sin(time))),1.)*beat_flash;\n    //if(orb == 0.){gl_FragColor = vec4(0.);}\n    //gl_FragColor = (orb!=0. ? 1.-orb*vec4(9.,5.,3.,0.):vec4(0.));\n}\n"
        },
        "circularDependency": {
            "title": "Circular Dependency",
            "src": "// Circular Dependency\n// From http://glslsandbox.com/e#56705\n\n/*\n * Original shader from: https://www.shadertoy.com/view/Wtf3zl\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time; // @@Time\nuniform vec2 resolution; // @@Resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/resolution.xy;\n    uv-=.5;\n    uv.x*= resolution.x/resolution.y;\n\n    vec3 col = vec3(0.5);\n    float d =length(uv)*20.;\n    float a = atan(uv.y, uv.x);\n    col.r = smoothstep(0.1, .2, abs(mod(d+time, 2.)-1.));\n\tcol.g = col.r*floor(mod(d*.5+.5+time*.5, 2.));\n    float f = smoothstep(-.1, .1,sin(a*3.+(sin(time*.5)*2.)*d-time));\n    col.rg = mix(1.-col.rg, col.rg, f);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n"
        },
        "redSea": {
            "title": "Red Sea",
            "src": "// Red Sea\n// From http://glslsandbox.com/e#60816.0\n\n/*\n * Original shader from: https://www.shadertoy.com/view/3ty3Wy\n */\n\n// --------[ Original ShaderToy begins here ]---------- //\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n\n// FBM\nfloat fbm (in vec3 p) {\n    float ret = -1.;\n    float freq = 1.;\n    float amp = 1.;\n    for(int i=0; i<8; i++) {\n        float n = cnoise(p*freq+vec3(0,(iTime*.2),0)*2.);\n        ret = ret + n * amp;\n        amp *= .5;\n        freq *= 1.5 + n * .1;\n    }\n    return ret;\n}\n\nfloat f(vec3 p) {\n    float n = fbm(p);\n    return p.y - 1. - exp(n) * .5;\n}\n\n\n\nvec3 calcNormal(vec3 p, float h) // for function f(p)\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*f( p + k.xyy*h ) +\n    k.yyx*f( p + k.yyx*h ) +\n    k.yxy*f( p + k.yxy*h ) +\n    k.xxx*f( p + k.xxx*h ) );\n}\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0, 2, -4);\n    vec3 rd = normalize(vec3(uv, 1.77) + vec3(0,-1.5,0));\n    /*\n    pR(ro.xz, iTime*.1);\n    pR(rd.xz, iTime*.1);\n\t//*/\n    float t = 0., d;\n\n\n    for(int i=0; i<16; i++) {\n        d = f(ro+rd*t);\n        //if(d<0.) break;\n        t+=d;\n    }\n\n    vec3 n = calcNormal(ro+rd*t, t*t*.0004);\n    // Time varying pixel color\n    vec3 col = -n.yyy *n.y * .5 + .5;\n    col *= vec3(8,4,16);\n    col /= t;\n    col = pow(col, vec3(.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"
        },
        "baaahsEclipse": {
            "title": "[🐑] BAAAHS Eclipse",
            "src": "// Eclipse of the sheep!\n// based on https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nuniform float time; // @@Time\n\nuniform float horizontalScale; // @@Slider default=.7 min=0.25 max=1.\n\nuniform vec2 resolution; // @@Resolution\n\n\nstruct SoundAnalysis {\n\tint bucketCount;\n\tint sampleHistoryCount;\n\tsampler2D buckets;\n\tfloat maxMagnitude;\n};\nuniform SoundAnalysis soundAnalysis; // @@baaahs.SoundAnalysis:SoundAnalysis\n\nstruct BeatInfo {\n\tfloat beat;\n\tfloat bpm;\n\tfloat intensity;\n\tfloat confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\nstruct Midi {\n\tint sustainPedalCount;\n\tint noteCount;\n};\nuniform Midi midi; // @@baaahs.Midi:Midi\n\n\nconst float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.8;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.4;\n\n/* Minified BAAAHS logo code: use pointInSheep(vec2 point, float scale, vec2 offset) to determine if a pixel is in the sheep logo. */ float COORD_SCALE = 0.03; vec2 HEART[187] = vec2[187](vec2(-1.408e1,2.96),vec2(-1.39e1,3.56),vec2(-1.326e1,3.86),vec2(-1.37e1,4.4),vec2(-1.36e1,5.08),vec2(-1.322e1,5.4),vec2(-1.268e1,5.46),vec2(-13,5.92),vec2(-1.292e1,6.52),vec2(-1.242e1,6.92),vec2(-1.174e1,6.84),vec2(-1.198e1,7.4),vec2(-1.174e1,7.98),vec2(-1.126e1,8.22),vec2(-1.054e1,8.02),vec2(-1.058e1,8.66),vec2(-1.012e1,9.14),vec2(-9.6,9.18),vec2(-9.1,8.88),vec2(-9.08,9.42),vec2(-8.62,9.86),vec2(-8,9.86),vec2(-7.54,9.42),vec2(-7.4,9.94),vec2(-6.88,1.028e1),vec2(-6.22,1.014e1),vec2(-5.9,9.56),vec2(-5.46,1.01e1),vec2(-4.78,1.014e1),vec2(-4.42,9.88),vec2(-4.22,9.32),vec2(-3.86,9.8),vec2(-3.2,9.88),vec2(-2.74,9.54),vec2(-2.6,8.88),vec2(-2.02,9.24),vec2(-1.38,9.04),vec2(-1.12,8.6),vec2(-1.14,8.06),vec2(-0.52,8.28),vec2(0,8.02),vec2(0.58,8.16),vec2(1.04,7.96),vec2(1,8.5),vec2(1.28,8.96),vec2(1.98,9.14),vec2(2.54,8.78),vec2(2.52,9.3),vec2(2.98,9.8),vec2(3.6,9.82),vec2(4.12,9.3),vec2(4.22,9.72),vec2(4.62,1.008e1),vec2(5.32,1.006e1),vec2(5.78,9.52),vec2(6.1,1.014e1),vec2(6.74,1.028e1),vec2(7.24,9.98),vec2(7.4,9.44),vec2(7.98,9.92),vec2(8.64,9.82),vec2(8.98,9.4),vec2(8.98,8.88),vec2(9.5,9.24),vec2(1.02e1,9.1),vec2(1.052e1,8.58),vec2(1.046e1,8.04),vec2(1.11e1,8.3),vec2(1.166e1,8.04),vec2(1.188e1,7.38),vec2(1.166e1,6.92),vec2(1.236e1,7),vec2(1.284e1,6.62),vec2(1.294e1,6.06),vec2(1.268e1,5.54),vec2(1.326e1,5.48),vec2(1.368e1,4.92),vec2(1.364e1,4.44),vec2(1.326e1,3.98),vec2(1.378e1,3.82),vec2(1.41e1,3.24),vec2(1.394e1,2.66),vec2(1.34e1,2.36),vec2(1.386e1,2.08),vec2(1.408e1,1.62),vec2(1.388e1,0.94),vec2(1.32e1,0.68),vec2(1.36e1,0.16),vec2(1.356e1,-0.42),vec2(1.322e1,-0.8),vec2(1.262e1,-0.92),vec2(1.302e1,-1.38),vec2(1.294e1,-2.06),vec2(1.244e1,-2.44),vec2(1.188e1,-2.38),vec2(1.212e1,-2.92),vec2(1.198e1,-3.46),vec2(1.152e1,-3.8),vec2(1.094e1,-3.74),vec2(1.114e1,-4.44),vec2(1.08e1,-5.02),vec2(1.036e1,-5.18),vec2(9.86,-5.06),vec2(1.006e1,-5.66),vec2(9.84,-6.16),vec2(9.3,-6.42),vec2(8.72,-6.22),vec2(8.82,-6.92),vec2(8.46,-7.42),vec2(7.88,-7.54),vec2(7.48,-7.38),vec2(7.62,-8),vec2(7.34,-8.48),vec2(6.74,-8.68),vec2(6.26,-8.46),vec2(6.36,-9.14),vec2(5.88,-9.7),vec2(5.34,-9.74),vec2(4.94,-9.48),vec2(4.98,-1.016e1),vec2(4.64,-1.058e1),vec2(4.18,-1.072e1),vec2(3.56,-1.046e1),vec2(3.64,-1.102e1),vec2(3.3,-1.152e1),vec2(2.76,-1.166e1),vec2(2.22,-1.14e1),vec2(2.28,-1.198e1),vec2(1.92,-1.248e1),vec2(1.34,-1.26e1),vec2(0.86,-1.232e1),vec2(0.9,-13),vec2(0.74,-1.328e1),vec2(0.28,-1.354e1),vec2(-0.24,-1.35e1),vec2(-0.6,-1.324e1),vec2(-0.76,-1.242e1),vec2(-1.22,-1.266e1),vec2(-1.84,-1.25e1),vec2(-2.14,-1.204e1),vec2(-2.08,-1.146e1),vec2(-2.62,-1.172e1),vec2(-3.24,-1.152e1),vec2(-3.52,-11),vec2(-3.42,-1.052e1),vec2(-3.9,-1.076e1),vec2(-4.54,-1.062e1),vec2(-4.88,-1.006e1),vec2(-4.8,-9.54),vec2(-5.32,-9.82),vec2(-5.94,-9.64),vec2(-6.24,-9.1),vec2(-6.1,-8.5),vec2(-6.54,-8.74),vec2(-7.18,-8.58),vec2(-7.5,-8.02),vec2(-7.38,-7.44),vec2(-7.82,-7.62),vec2(-8.36,-7.48),vec2(-8.72,-6.88),vec2(-8.56,-6.32),vec2(-9.08,-6.5),vec2(-9.56,-6.36),vec2(-9.94,-5.72),vec2(-9.74,-5.14),vec2(-1.034e1,-5.26),vec2(-1.086e1,-4.96),vec2(-1.104e1,-4.34),vec2(-1.082e1,-3.82),vec2(-1.128e1,-3.92),vec2(-1.168e1,-3.76),vec2(-1.202e1,-3.1),vec2(-1.18e1,-2.48),vec2(-1.242e1,-2.54),vec2(-1.294e1,-2.02),vec2(-1.294e1,-1.46),vec2(-1.256e1,-1.04),vec2(-1.314e1,-0.92),vec2(-1.352e1,-0.46),vec2(-1.352e1,8.0e-2),vec2(-1.31e1,0.54),vec2(-1.382e1,0.78),vec2(-1.406e1,1.5),vec2(-1.382e1,1.98),vec2(-1.336e1,2.22),vec2(-1.386e1,2.46),vec2(-1.406e1,2.94)); vec2 HEART_MIN_XY = vec2(-70.5, -67.9); vec2 HEART_MAX_XY = vec2(70.6, 51.6); vec2 FACE[26] = vec2[26](vec2(-5.24,2.5),vec2(-5.18,3.56),vec2(-5.04,3.84),vec2(-4.8,3.88),vec2(-3.58,3.3),vec2(-1.88,2.12),vec2(2.16,2.12),vec2(4.02,3.68),vec2(4.78,4.04),vec2(5.18,4.02),vec2(5.38,3.64),vec2(5.44,2.72),vec2(5.12,0),vec2(2.84,-7.52),vec2(2.7,-8.46),vec2(2.36,-9.22),vec2(1.86,-9.8),vec2(1.14,-1.026e1),vec2(0.46,-1.046e1),vec2(-0.36,-1.044e1),vec2(-1.28,-1.008e1),vec2(-1.88,-9.58),vec2(-2.38,-8.8),vec2(-2.64,-7.5),vec2(-4.76,-0.72),vec2(-5.22,2.48)); vec2 MOUTH[35] = vec2[35](vec2(-1.66,-6.76),vec2(-1.56,-6.52),vec2(-1.3,-6.58),vec2(-0.32,-7.72),vec2(0.2,-7.86),vec2(0.58,-7.68),vec2(1.4,-6.66),vec2(1.62,-6.52),vec2(1.84,-6.58),vec2(1.82,-6.84),vec2(1.52,-6.98),vec2(1.22,-7.28),vec2(0.3,-8.66),vec2(0.3,-9.18),vec2(0.4,-9.28),vec2(1.14,-9.04),vec2(1.66,-8.64),vec2(1.8,-8.68),vec2(1.78,-8.82),vec2(1.44,-9.2),vec2(0.98,-9.52),vec2(0.42,-9.78),vec2(2.0e-2,-9.84),vec2(-0.86,-9.46),vec2(-1.54,-8.82),vec2(-1.56,-8.68),vec2(-1.44,-8.64),vec2(-1,-8.98),vec2(-0.18,-9.28),vec2(-8.0e-2,-9.16),vec2(-8.0e-2,-8.74),vec2(-0.14,-8.5),vec2(-0.8,-7.54),vec2(-1.26,-7.02),vec2(-1.64,-6.76)); vec2 EYE_LEFT[10] = vec2[10](vec2(-4.6,2.4),vec2(-4.6,2.72),vec2(-4.46,2.98),vec2(-4.14,3.02),vec2(-3.82,2.8),vec2(-3.48,2.14),vec2(-3.54,1.6),vec2(-4,1.6),vec2(-4.26,1.72),vec2(-4.58,2.38)); vec2 EYE_RIGHT[10] = vec2[10](vec2(3.64,1.8),vec2(3.72,2.34),vec2(4,2.8),vec2(4.32,3.02),vec2(4.68,2.94),vec2(4.78,2.42),vec2(4.48,1.76),vec2(4.2,1.6),vec2(3.7,1.6),vec2(3.66,1.78)); vec2 EAR_LEFT[9] = vec2[9](vec2(-1.092e1,6.08),vec2(-1.084e1,6.26),vec2(-1.058e1,6.3),vec2(-7.02,6.24),vec2(-6.94,4.48),vec2(-7.14,4.38),vec2(-7.84,4.42),vec2(-1.078e1,5.88),vec2(-1.09e1,6.06)); vec2 EAR_RIGHT[10] = vec2[10](vec2(7.22,4.48),vec2(7.42,4.38),vec2(8.12,4.42),vec2(1.106e1,5.88),vec2(1.12e1,6.14),vec2(1.112e1,6.26),vec2(1.086e1,6.3),vec2(7.36,6.28),vec2(7.26,6.18),vec2(7.22,4.5));  bool pointInHeart(vec2 point, float scale, vec2 offset){ \tint len = 187; \tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE); \tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((HEART[i].y > p.y) != (HEART[j].y > p.y)) && (p.x < (HEART[j].x-HEART[i].x) * (p.y-HEART[i].y) / (HEART[j].y-HEART[i].y) + HEART[i].x) ) c = !c; } \treturn c; } bool pointInFace(vec2 point, float scale, vec2 offset){ \tint len = 26; \tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE); \tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((FACE[i].y > p.y) != (FACE[j].y > p.y)) && (p.x < (FACE[j].x-FACE[i].x) * (p.y-FACE[i].y) / (FACE[j].y-FACE[i].y) + FACE[i].x) ) c = !c; } \treturn c; } bool pointInMouth(vec2 point, float scale, vec2 offset){ \tint len = 35; \tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE); \tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((MOUTH[i].y > p.y) != (MOUTH[j].y > p.y)) && (p.x < (MOUTH[j].x-MOUTH[i].x) * (p.y-MOUTH[i].y) / (MOUTH[j].y-MOUTH[i].y) + MOUTH[i].x) ) c = !c; } \treturn c; } bool pointInEyeLeft(vec2 point, float scale, vec2 offset){ \tint len = 10; \tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE); \tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EYE_LEFT[i].y > p.y) != (EYE_LEFT[j].y > p.y)) && (p.x < (EYE_LEFT[j].x-EYE_LEFT[i].x) * (p.y-EYE_LEFT[i].y) / (EYE_LEFT[j].y-EYE_LEFT[i].y) + EYE_LEFT[i].x) ) c = !c; } \treturn c; } bool pointInEyeRight(vec2 point, float scale, vec2 offset){ \tint len = 10; \tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE); \tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EYE_RIGHT[i].y > p.y) != (EYE_RIGHT[j].y > p.y)) && (p.x < (EYE_RIGHT[j].x-EYE_RIGHT[i].x) * (p.y-EYE_RIGHT[i].y) / (EYE_RIGHT[j].y-EYE_RIGHT[i].y) + EYE_RIGHT[i].x) ) c = !c; } \treturn c; } bool pointInEarLeft(vec2 point, float scale, vec2 offset){ \tint len = 9; \tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE); \tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EAR_LEFT[i].y > p.y) != (EAR_LEFT[j].y > p.y)) && (p.x < (EAR_LEFT[j].x-EAR_LEFT[i].x) * (p.y-EAR_LEFT[i].y) / (EAR_LEFT[j].y-EAR_LEFT[i].y) + EAR_LEFT[i].x) ) c = !c; } \treturn c; } bool pointInEarRight(vec2 point, float scale, vec2 offset){ \tint len = 10; \tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE); \tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EAR_RIGHT[i].y > p.y) != (EAR_RIGHT[j].y > p.y)) && (p.x < (EAR_RIGHT[j].x-EAR_RIGHT[i].x) * (p.y-EAR_RIGHT[i].y) / (EAR_RIGHT[j].y-EAR_RIGHT[i].y) + EAR_RIGHT[i].x) ) c = !c; } \treturn c; }  bool pointInSheep(vec2 point, float scale, vec2 offset) { \tvec2 p = (point - offset)/(scale * COORD_SCALE); \tif (p.x > HEART_MAX_XY.x || p.y > HEART_MAX_XY.y || p.x < HEART_MIN_XY.x || p.y < HEART_MIN_XY.y) { \t\treturn false; \t} \tbool inHeart = pointInHeart(point, scale, offset); \tbool inFace = pointInFace(point, scale, offset); \tbool inMouth = pointInMouth(point, scale, offset); \tbool inEyeLeft = pointInEyeLeft(point, scale, offset); \tbool inEyeRight = pointInEyeRight(point, scale, offset); \tbool inEarLeft = pointInEarLeft(point, scale, offset); \tbool inEarRight = pointInEarRight(point, scale, offset); \treturn inHeart && (!(inFace || inEarLeft || inEarRight) || (inMouth || inEyeLeft || inEyeRight)); }\n\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n\treturn dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn .2 + .3 * beatInfo.intensity;  //texture(soundAnalysis.buckets, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n} \n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n\tfloat next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n\treturn mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float scale) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - scale);\n\n\tfloat sheepScale = 1.5;\n\tvec2 sheepXY = vec2(0.0, 0.00);\n\n\t//float b = pointInSheep(fragment, sheepScale, sheepXY) ? BRIGHTNESS : 0.1 * BRIGHTNESS; // dist < scale ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\tfloat b = dist < scale ? BRIGHTNESS * 0.2 : BRIGHTNESS;\n\n\n\tif (pointInSheep(fragment, sheepScale, sheepXY)) { b = 50. * b; }\n\n\tvec3 col = vec3(0.0);\n\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + time * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + time * 0.12, 1.0, 1.0));\n\n\tfloat freq = abs(fragment.x * 0.5);\n\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 fragPos = fragCoord / resolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.5;\n\tfragPos.x *= resolution.x / resolution.y / horizontalScale;\n\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n\tfloat c = cos(time * SPEED);\n\tfloat s = sin(time * SPEED);\n\tvec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\n\tcolor += max(luma(color) - 1.0, 0.0);\n\n\tfragColor = vec4(color, 1.0);\n\n}\n"
        },
        "firstRaymarches": {
            "title": "First Raymarches",
            "src": "// First Raymarches\n// From https://www.shadertoy.com/view/XdGGzw\n\n#define ITERATIONS 128\n\nuniform float thing; // @@Slider default=0.866025 max=2\n\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*thing+q.y*0.5),q.y)-h.x);\n}\n\nfloat opRep( vec3 p, vec3 spacing ) {\n    vec3 q = mod(p, spacing) - 0.5 * spacing;\n    return sdHexPrism( q, vec2( 0.2 + 0.1 * cos(iTime/2.), 1.0 + 0.9 * sin(3.14 + iTime/2.) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 1 : retrieve the fragment's coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\t\t// Correct for aspect ratio\n\n    // 2 : camera position and ray direction\n    // vec3 pos = vec3( sin(iTime), 0, sin(iTime) * 5. );\n    vec3 pos = vec3( sin(iTime), 0, iTime / 20. );\n    vec3 dir = normalize( vec3( uv, 1. ) );\n\n    // 3 : ray march loop\n    // ip will store where the ray hits the surface\n    vec3 ip;\n\n    // variable step size\n    float t = 0.0;\n    float findThresh = 0.001;\n    int found = 0;\n    int last_i = 0;\n\n    for(int i = 0; i < ITERATIONS; i++) {\n        last_i = i;\n\n        //update position along path\n        ip = pos + dir * t;\n\n        //gets the shortest distance to the scene\n        //break the loop if the distance was too small\n        //this means that we are close enough to the surface\n        float temp;\n\n        // make a repeating SDF shape\n        temp = opRep( ip, vec3(2.5 + 2.0 * sin(iTime/2.) ) );\n        if( temp < findThresh ) {\n            float r = 0.7 + 0.3 * sin(ip.z/8. + ip.x/2.);\n            float g = 0.6 + 0.3 * cos(ip.z/8. + ip.y/2.);\n            float b = 0.5 + 0.4 * sin(ip.z/8. + ip.x);\n            ip = vec3(r, g, b);\n            found = 1;\n            break;\n        }\n\n        //increment the step along the ray path\n        t += temp;\n    }\n\n    // make background black if no shape was hit\n    if(found == 0) {\n        ip = vec3(0,0,0);\n    }\n\n    // 4 : apply color to this fragment\n    // subtract from color as distance increases\n    fragColor = vec4(ip - float(last_i) / float(ITERATIONS), 1.0 );\n}"
        },
        "fireball": {
            "title": "Fireball",
            "src": "// Fire Ball\n// From http://glslsandbox.com/e#61108.0\n\n// Fire ball by David Robles\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//#extension GL_OES_standard_derivatives : enable\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n\nconst float PI = 3.141592;\n\nuniform float conflagration; // @@Slider min=5 max=20 default=15.\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x);\n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n    vec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat circleShape(vec2 coord, vec2 pos){\n    float dist = distance(coord, pos);\n    return clamp(   log(dist*(15.+conflagration+4.*noise(vec2(time*.8))))  ,0.,1.);\n}\n\nvec2 sineWave(vec2 p){\n    float Ax = .05;\n    float wx = 1.50 * PI;\n    float x = sin(wx * p.x) * Ax * sin(noise(vec2(time)));\n\n    float Ay = .05;\n    float wy = PI * 10.;\n    float y = sin(wy*p.y) * Ay * noise(vec2(time));\n\n    return vec2(p.x + x, p.y + y);\n}\n\nvoid main( void ) {\n\n    vec2 pos = gl_FragCoord.xy / resolution.xy;\n    vec2 uv = pos;\n\n    uv += vec2(-.5, -.5);\n    uv *= vec2(2.3, 1.3);\n\n    float luz = clamp(1.05 - (pow(uv.x, 2.) + pow(uv.y * 1.6, 6.))*2., 0., 1.);\n    //vec3 color = vec3(0.3059, 0.1922, 0.0431);\n    vec3 color = vec3(0.7333, 0.2902, 0.0314);\n    //vec3 color = vec3(0.3882, 0.1686, 0.251);\n    float grad = circleShape(sineWave(pos), vec2(.5, .32));\n\n    float ruido = 0.;\n\n    pos *= 5.0;\n    float xoff = 1.05;\n    float yoff = 2.1;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    ruido = 0.7500*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido += 0.2500*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido += 0.5000*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido += 0.1250*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n\n\n    ruido = 0.5 + 0.5*ruido;\n    ruido = clamp(ruido, 0., 1.);\n\n    /////////////////////////////////////////////////////////////\n    pos = uv;\n    pos *= 3.0;\n    float ruido2 = 0.;\n    xoff = 1.5;\n    yoff = 1.5;\n    m = mat2( -2.1,  .5, -.5,  2.1 );\n    ruido2 = 0.2500*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido2 += 0.5000*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido2 += 0.1250*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido2 += 0.0625*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n\n    ruido2 = 0.5 + 0.5*ruido2;\n    ruido2 = clamp(ruido2, 0., 1.);\n\n    float f = 0.;\n    f += 1.0 - ( (1.0-luz) / (ruido2 + 0.001) );\n    f /= grad;\n    f /= ruido;\n\n    gl_FragColor = vec4(f*color*luz*(.5-.5*noise(vec2(time*.8))), 1.);\n    //gl_FragColor = vec4(color/grad, 1.);\n\n}"
        },
        "blueHearts": {
            "title": "Blue Hearts",
            "src": "// Blue Hearts\n// From https://www.shadertoy.com/view/wt2GWK\n\n#define t iTime\n\nvec2 hash22(vec2 p)\n{\n\treturn fract(sin(vec2(dot(p,vec2(263.135,198.742)),dot(p,vec2(624.235,321.217))))*13.635);\n}\n\nfloat vorohearts( vec2 x)\n{\n\tvec2 n = floor(-x);\n\tvec2 f = fract(-x);\n\n\tfloat md = 1.0;\n\n\tfor( int j=-1; j<=1; j++ )\n\t{\n\t\tfor( int i=-1; i<=1; i++ )\n\t\t{\n\t\t\tvec2  g = vec2(float(i), float(j));\n\t\t\tvec2  o = hash22( n + g );\n\t\t\tvec2  r = g - f + (.5+.5*sin(t+o*6.28));\n\t\t\tr.x *= .8*(1.+sin(.5+sin(6.*t))*.03);\n\t\t\tr.y *= .95+sin(1.5+sin(3.*t))*.07;\n\t\t\tr.y += .08;\n\t\t\tr.y -= sqrt(abs(r.x))*.52;\n\t\t\tfloat d = length(r);\n\t\t\tif( d < md ) {md = d;}\n\t\t}\n\t}\n\treturn md;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n\t//Heart uv\n\tuv = uv*3.;\n\tfloat d = vorohearts(uv);\n\td = smoothstep(.58, .25, d);\n\n\t//Heart color\n\tvec3 p = vec3(1.6*d*(.6+sin(.5+sin(6.*t))*.1), d*(1.8+sin(.5+sin(6.*t))*.3), 2.1*(1.+sin(.5+sin(6.*t))*.3));\n\tvec3 col = vec3(d) * p;\n\n\t//Background\n\tcol += vorohearts(uv) * .35 * p;\n\n\tfragColor = vec4(col,1.);\n}"
        },
        "blueSClues": {
            "title": "Blue's Clues",
            "src": "// Blue's Clues\n// From https://www.shadertoy.com/view/wljSzR\n\n// Sphere tracer by mzeo\n//\n// inspired by http://www.youtube.com/watch?v=kuesTvUYsSc#t=377\n//\n// waves by @hintz\n\n#ifdef GL_ES\nprecision mediump float;\nconst vec3 df = vec3(0.05, 0.0, 0.0);\n#else\nconst vec3 df = vec3(0.01, 0.0, 0.0);\n#endif\n\n#define AUTO_CAMERA\n\n// input\n\n// Constants\n// Camera\nconst vec3 origin = vec3(0, 0, 0);\nconst int steps = 128;\nconst vec3 sun = vec3(1.0, .5, -1.0);\n\nconst int miterations = 32;\n\n// Ball\nstruct Ball\n{\n    vec3 pos;\n    float size;\n};\n\nconst Ball ball = Ball(vec3(0, 0, 5), 0.5);\n\nstruct Balls\n{\n    vec3 dir;\n    vec3 p;\n    float dist;\n};\n\nconst Balls balls = Balls(vec3(1, 0, 0), vec3(0, 0, 0), 1.0);\n\n// Floor\n\nstruct Plane\n{\n    vec3 n;\n    float d;\n};\n\nconst Plane plane = Plane(vec3(0, 1, 0), -1.0);\n\n// Distance\nstruct Dist\n{\n    float dist;\n    int id;\n};\n\n\nDist and(Dist a, Dist b)\n{\n    if (a.dist < b.dist)\n    {\n        return a;\n    }\n\n    return b;\n}\n\nDist fBall(Ball ball, vec3 p)\n{\n    return Dist(length(ball.pos - p) - ball.size, 0);\n}\n\nBall get(Balls balls, float t)\n{\n    float a = abs(mod(t, 6.0) - 3.0);\n    vec3 p = balls.p + balls.dir * t * balls.dist + a * a * vec3(0, -0.15, 0);\n    return Ball(p, ball.size);\n}\n\nDist fBalls(Balls balls, vec3 p)\n{\n    float t = dot(p - balls.p, balls.dir) / balls.dist;\n    float t0 = t - fract(t + fract(iTime) * 2.0);\n    float t1 = t0 + 1.0;\n\n    return and(\n    fBall(get(balls, t0), p),\n    fBall(get(balls, t1), p));\n}\n\nDist fPlane(Plane plane, vec3 p)\n{\n    return Dist(dot(plane.n, p) - plane.d - 0.4*cos(length(p.xz) - iTime), 1);\n}\n\nDist f(vec3 p)\n{\n    return and(\n    fBalls(balls, p),\n    fPlane(plane, p));\n}\n\nvec3 grad(vec3 p)\n{\n    float f0 = f(p).dist;\n\n    return normalize(vec3(\n    f(p + df.xyz).dist,\n    f(p + df.yxz).dist,\n    f(p + df.yzx).dist) - f0);\n}\n\nfloat mandel(vec2 c)\n{\n    vec2 z = c;\n\n    for(int i = 0; i < miterations; ++i)\n    {\n        z = vec2(z.x*z.x - z.y*z.y, 1.5*z.x*z.y) + c;\n        if (length(z) > 40.0) return float(i) / float(miterations);\n    }\n\n    return 0.0;\n}\n\nvec3 floorTexture(vec3 p)\n{\n    mat2 rot = mat2(vec2(1, 1), vec2(1, -1));\n    vec2 c = rot * (p.xz + vec2(-0.7, -1.0)) * 0.2;\n    float i = mandel(c);\n    return clamp(vec3(i * 10.0, i * i *10.0, i*i*i*5.0).zyx, vec3(0,0,0), vec3(2,2,2));\n}\n\n\nvec4 shade(vec3 p, vec3 ray, int id)\n{\n    vec3 n = grad(p);\n    float diffuse = clamp(dot(normalize(sun), n), 0.0, 1.0);\n\n    vec3 color;\n    float ref;\n\n    if (id == 0)\n    {\n        color = vec3(0,1,0);\n        ref = 0.1;\n    }\n    else\n    {\n        color = floorTexture(p);\n        ref = 0.5;\n    }\n\n    return vec4(color * diffuse, 1) * ref;\n}\n\nvec4 combine(vec4 a, vec4 b)\n{\n    return a + b * (1.0 - a.w);\n}\n\nvec4 sky(vec3 ray)\n{\n    float sun = dot(ray, normalize(sun));\n    sun = (sun > 0.0) ? pow(sun, 150.0) * 3.0 : 0.0;\n    float horizon = 1.0 - abs(ray.y);\n    vec3 blue = vec3(0.1, 0.3, 0.6);\n    vec3 red = vec3(0.6, 0.3, 0.) * 2.0;\n    return vec4(vec3(0.9, 0.8, 0.5) * sun + blue * horizon + red * pow(horizon, 8.0), 1);\n}\n\nvec4 trace(vec3 origin, vec3 ray)\n{\n    vec3 p = origin;\n    Dist dist = Dist(10.0, 2);\n    vec4 result = vec4(0, 0, 0, 0);\n\n    for(int i = 0; i < steps; ++i)\n    {\n        dist = f(p);\n        if (dist.dist > 0.01)\n        {\n            p += ray * dist.dist;\n            float absorb = exp(-dist.dist * 0.05);\n            vec4 s = sky(ray) * (1.0 - absorb);\n\n            result = combine(result, s);\n        }\n        else if (result.w < 0.99)\n        {\n            vec3 n = grad(p);\n            vec4 s = shade(p, ray, dist.id);\n            ray = reflect(ray, n);\n            p += n * 0.01;\n\n            result = combine(result, s);\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    return combine(result, sky(ray));\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float scale = 2.0 / max(iResolution.x, iResolution.y);\n    vec3 ray = vec3((fragCoord.xy - iResolution.xy / 2.0) * scale, 1);\n\n    //#ifdef AUTO_CAMERA\n    float yaw = cos(iTime) * -0.25 + 0.1;\n    float angle = iTime * 0.5;\n    //#else\n    //float yaw = iMouse.y - 0.15;\n    //float angle = iMouse.x * 8.0;\n    //#endif\n\n    vec3 from = (vec3(sin(angle), 0, cos(angle)) * cos(yaw) + vec3(0, sin(yaw) * 1.0, 0)) * 5.0;\n    //vec3 from = origin + vec3((iMouse.xy - vec2(0.5,0.0)) * vec2(15.0, 3.0), -5);\n    vec3 to = vec3(0, -1, 0);\n    vec3 up = vec3(0, 1, 0);\n    vec3 dir = normalize(to - from);\n    vec3 left = normalize(cross(up, dir));\n    mat3 rot = mat3(left, cross(dir, left), dir);\n\n    fragColor = trace(from, rot * normalize(ray));\n}"
        },
        "checkerboard": {
            "title": "Checkerboard",
            "src": "// Checkerboard\n\nuniform float checkerboardSize = 10.0; // @@Slider min=.001 max=1 default=.125\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = floor(fragCoord / checkerboardSize);\n    vec3 patternMask = vec3(mod(pos.x + mod(pos.y, 2.0), 2.0));\n    fragColor = vec4(patternMask.xy, 1., 1.);\n}"
        },
        "colorDiffusionFlow": {
            "title": "Color Diffusion Flow",
            "src": "/*{\n  \"CREDIT\": \"by mojovideotech\",\n  \"DESCRIPTION\": \"from http://glslsandbox.com/e#35553.0\",\n  \"CATEGORIES\": [\n    \"fluid\",\n    \"liquid\"\n  ],\n  \"INPUTS\": [\n  \t{\n\t\t\t\"NAME\" :\t\"rate1\",\n\t\t\t\"TYPE\" :\t\"float\",\n\t\t\t\"DEFAULT\" :\t1.9,\n\t\t\t\"MIN\" :\t-3.0,\n\t\t\t\"MAX\" :\t3.0\n\t},\n\t {\n\t\t\t\"NAME\" :\t\"rate2\",\n\t\t\t\"TYPE\" :\t\"float\",\n\t\t\t\"DEFAULT\" :\t0.6,\n\t\t\t\"MIN\" :\t-3.0,\n\t\t\t\"MAX\" :\t3.0\n\t},\n\t{\n\t\t\t\"NAME\" :\t\"loopcycle\",\n\t\t\t\"TYPE\" :\t\"float\",\n\t\t\t\"DEFAULT\" :\t85.0,\n\t\t\t\"MIN\" :\t20.0,\n\t\t\t\"MAX\" :\t100.0\n\t},\n\t{\n\t\t\t\"NAME\" :\t\"color1\",\n\t\t\t\"TYPE\" :\t\"float\",\n\t\t\t\"DEFAULT\" :\t0.45,\n\t\t\t\"MIN\" :\t-2.5,\n\t\t\t\"MAX\" :\t2.5\n\t},\n\t{\n\t\t\t\"NAME\" :\t\"color2\",\n\t\t\t\"TYPE\" :\t\"float\",\n\t\t\t\"DEFAULT\" :\t1.0,\n\t\t\t\"MIN\" :\t-1.25,\n\t\t\t\"MAX\" :\t1.125\n\t},\n\t{\n\t\t\t\"NAME\" :\t\"cycle1\",\n\t\t\t\"TYPE\" :\t\"float\",\n\t\t\t\"DEFAULT\" :\t1.33,\n\t\t\t\"MIN\" :\t0.01,\n\t\t\t\"MAX\" :\t3.1459\n\t},\n\t{\n\t\t\t\"NAME\" :\t\"cycle2\",\n\t\t\t\"TYPE\" :\t\"float\",\n\t\t\t\"DEFAULT\" :\t0.22,\n\t\t\t\"MIN\" :\t-0.497,\n\t\t\t\"MAX\" :\t0.497\n\t},\n\t{\n\t\t\t\"NAME\" :\t\"nudge\",\n\t\t\t\"TYPE\" :\t\"float\",\n\t\t\t\"DEFAULT\" :\t0.095,\n\t\t\t\"MIN\" :\t0.001,\n\t\t\t\"MAX\" :\t0.01\n\t},\n\t{\n      \t\t\t\"NAME\" :\t\"depthX\",\n      \t\t\t\"TYPE\" : \t\"float\",\n      \t\t\t\"DEFAULT\" :\t0.85,\n      \t\t\t\"MIN\" : \t0.001,\n      \t\t\t\"MAX\" :\t\t0.9\n    \t},\n    \t{\n      \t\t\t\"NAME\" :\t\"depthY\",\n      \t\t\t\"TYPE\" :\t\"float\",\n      \t\t\t\"DEFAULT\" :\t0.25,\n      \t\t\t\"MIN\" : \t0.001,\n      \t\t\t\"MAX\" :\t\t0.9\n    \t}\n  ]\n}*/\n\n///////////////////////////////////////////\n// ColorDiffusionFlow  by mojovideotech\n//\n// based on :\n// glslsandbox.com/\\e#35553.0\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n///////////////////////////////////////////\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define \tpi   \t3.141592653589793\n\nvoid main() {\n    float T = TIME * rate1;\n    float TT = TIME * rate2;\n    vec2 p=(2.*isf_FragNormCoord);\n    for(int i=1;i<11;i++) {\n        vec2 newp = p;\n        float ii = float(i);\n        newp.x+=depthX/ii*sin(ii*pi*p.y+T*nudge+cos((TT/(5.0*ii))*ii));\n        newp.y+=depthY/ii*cos(ii*pi*p.x+TT+nudge+sin((T/(5.0*ii))*ii));\n        p = newp +log(DATE.w)/loopcycle;\n    }\n    vec3 col=vec3(cos(p.x+p.y+3.0*color1)*0.5+0.5,sin(p.x+p.y+6.0*cycle1)*0.5+0.5,(sin(p.x+p.y+9.0*color2)+cos(p.x+p.y+12.0*cycle2))*0.25+.5);\n    gl_FragColor=vec4(col*col, 1.0);\n}"
        },
        "danceyCubes": {
            "title": "Dancey Cubes",
            "src": "// Dancey Cubes\n\nuniform float mysterNumber;\n\nvec3 palette(float d){\n    return mix(vec3(0.2,0.7,0.9),vec3(1.,0.,1.),d);\n}\n\nvec2 rotate(vec2 p,float a){\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p){\n    for( int i = 0; i<8; ++i){\n        float t = iTime*0.2;\n        p.xz =rotate(p.xz,t);\n        p.xy =rotate(p.xy,t*mysterNumber);\n        p.xz = abs(p.xz);\n        p.xz-=.5;\n    }\n    return dot(sign(p),p)/5.;\n}\n\nvec4 rm (vec3 ro, vec3 rd){\n    float t = 0.;\n    vec3 col = vec3(0.);\n    float d;\n    for(float i =0.; i<64.; i++){\n        vec3 p = ro + rd*t;\n        d = map(p)*.5;\n        if(d<0.02){\n            break;\n        }\n        if(d>100.){\n            break;\n        }\n        //col+=vec3(0.6,0.8,0.8)/(400.*(d));\n        col+=palette(length(p)*.1)/(400.*(d));\n        t+=d;\n    }\n    return vec4(col,1./(d*100.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n    vec3 ro = vec3(0.,0.,-50.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cf,cs));\n\n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n\n    vec3 rd = normalize(uuv-ro);\n\n    vec4 col = rm(ro,rd);\n\n\n    fragColor = col;\n    fragColor.a = 1.;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"fractal pyramid\",\n\t\"description\": \"coding my new screensaver\",\n\t\"model\": \"car\"\n}\n*/"
        },
        "plaid": {
            "title": "Plaid",
            "src": "// Plaid\n\n// #extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\n\nvoid main( void ) {\n\n    vec2 position = ( gl_FragCoord.xy / resolution.xy ) + 4.0;\n\n    float color = 0.0;\n    color += sin( position.x * cos( time / 15.0 ) * 80.0 ) + cos( position.y * cos( time / 15.0 ) * 10.0 );\n    color += sin( position.y * sin( time / 10.0 ) * 40.0 ) + cos( position.x * sin( time / 25.0 ) * 40.0 );\n    color += sin( position.x * sin( time / 5.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 80.0 );\n    color *= sin( time / 10.0 ) * 0.5;\n\n    gl_FragColor = vec4( vec3( color, color * 0.2, sin( color + time / 9.0 ) * 0.69 ), 9.0 );\n\n}"
        },
        "primeWaves": {
            "title": "Prime Waves",
            "src": "/*{\n  \"CREDIT\": \"by mojovideotech\",\n  \"CATEGORIES\" : [\n    \"Generator\",\n    \"waves\"\n  ],\n  \"DESCRIPTION\" : \"\",\n  \"INPUTS\" : [\n    {\n      \"NAME\" : \"center\",\n      \"TYPE\" : \"point2D\",\n       \"DEFAULT\": [\n\t\t-2,\n\t\t-1\n\t  ],\n      \"MAX\" : [\n        10,\n        10\n      ],\n      \"MIN\" : [\n        -10,\n        -10\n      ]\n    },\n    {\n\t\t\"NAME\": \"rate\",\n\t\t\"TYPE\": \"float\",\n\t\t\"DEFAULT\": -1,\n\t\t\"MIN\": -3,\n\t\t\"MAX\": 3\n\t},\n\t{\n\t\t\"NAME\": \"zoom\",\n\t\t\"TYPE\": \"float\",\n\t\t\"DEFAULT\": 5,\n\t\t\"MIN\": -10,\n\t\t\"MAX\": 10\n\t},\n\t{\n\t\t\"NAME\": \"depth\",\n\t\t\"TYPE\": \"float\",\n\t\t\"DEFAULT\": 0.6,\n\t\t\"MIN\": 0.0,\n\t\t\"MAX\": 1.0\n\t},\n\t{\n\t\t\"NAME\": \"rxy\",\n\t\t\"TYPE\": \"float\",\n\t\t\"DEFAULT\": 11,\n\t\t\"MIN\": 1,\n\t\t\"MAX\": 17\n\t},\n\t{\n\t\t\"NAME\": \"rxz\",\n\t\t\"TYPE\": \"float\",\n\t\t\"DEFAULT\": 13,\n\t\t\"MIN\": 1,\n\t\t\"MAX\": 17\n\t}\n  ]\n}\n*/\n\n// PrimeWaves by mojovideotech\n// based on:\n// glslsandbox.com/e#21344.0\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nvec2 distort(vec2 p)\n{\n    float theta  = atan(p.y, p.x);\n    float radius = length(p);\n    radius = pow(radius, 1.0+depth);\n    p.x = radius * cos(theta);\n    p.y = radius * sin(theta);\n    return 0.5 * (p + 1.0);\n}\n\nvec4 pattern(vec2 p)\n{\n    vec2 m=mod(p.xy+p.x+p.y,2.)-1.;\n    return vec4(length(m+p*0.1));\n}\n\nfloat hash(float n)\n{\n    return fract(sin(n)*29712.15073);\n}\n\nfloat noise(vec3 x, float y, float z)\n{\n    vec3 p=floor(x); vec3 f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    float n=p.x+p.y*y+p.z*z;\n    float r1=mix(mix(hash(n+0.0),hash(n+1.0),f.x),mix(hash(n+y),hash(n+y+1.0),f.x),f.y);\n    float r2=mix(mix(hash(n+z),hash(n+z+1.0),f.x),mix(hash(n+y+z),hash(n+y+z+1.0),f.x),f.y);\n    return mix(r1,r2,f.z);\n}\nvoid main( void ) {\n\n    float RY = 0.0;\tfloat RZ = 0.0;\n    if (rxy <= 1.)\t\t\t{\tRY += 11.;\t}\n    else if (rxy <= 2.)\t\t{\tRY += 13.; \t}\n    else if (rxy <= 3.)\t\t{\tRY += 17.; \t}\n    else if (rxy <= 4.)\t\t{\tRY += 19.; \t}\n    else if (rxy <= 5.)\t\t{\tRY += 23.; \t}\n    else if (rxy <= 6.)\t\t{\tRY += 29.; \t}\n    else if (rxy <= 8.)\t\t{\tRY += 31.; \t}\n    else if (rxy <= 9.)\t\t{\tRY += 37.; \t}\n    else if (rxy <= 10.)\t{\tRY += 41.; \t}\n    else if (rxy <= 11.)\t{\tRY += 43.; \t}\n    else if (rxy <= 12.)\t{\tRY += 47.; \t}\n    else if (rxy <= 13.)\t{\tRY += 53.; \t}\n    else if (rxy <= 14.)\t{\tRY += 59.; \t}\n    else if (rxy <= 15.)\t{\tRY += 61.; \t}\n    else if (rxy <= 16.)\t{\tRY += 67.; \t}\n    if (rxz <= 1.)\t\t\t{\tRZ += 11.; \t}\n    else if (rxz <= 2.)\t\t{\tRZ += 13.; \t}\n    else if (rxz <= 3.)\t\t{\tRZ += 17.; \t}\n    else if (rxz <= 4.)\t\t{\tRZ += 19.; \t}\n    else if (rxz <= 5.)\t\t{\tRZ += 23.; \t}\n    else if (rxz <= 6.)\t\t{\tRZ += 29.; \t}\n    else if (rxz <= 8.)\t\t{\tRZ += 31.; \t}\n    else if (rxz <= 9.)\t\t{\tRZ += 37.; \t}\n    else if (rxz <= 10.)\t{\tRZ += 41.; \t}\n    else if (rxz <= 11.)\t{\tRZ += 43.; \t}\n    else if (rxz <= 12.)\t{\tRZ += 47.; \t}\n    else if (rxz <= 13.)\t{\tRZ += 53.; \t}\n    else if (rxz <= 14.)\t{\tRZ += 59.; \t}\n    else if (rxz <= 15.)\t{\tRZ += 61.; \t}\n    else if (rxz <= 16.)\t{\tRZ += 67.; \t}\n\n    vec2 pos = ( gl_FragCoord.xy / RENDERSIZE.xy * zoom )+center;\n    float col = noise(pos.xyx + (TIME*rate),RY,RZ);\n    vec4 c = pattern(distort(pos+col));\n    c.xy = distort(c.xy);\n    gl_FragColor = vec4(c.x - col, sin(c.y) - col, cos(c.z), 1.0);\n\n}"
        },
        "quiver": {
            "title": "Quiver",
            "src": "// Quiver\n\nuniform float twist; // @@Slider default=.2 min=-4 max=4\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// Playing around with simplex noise and polar-coords with a lightning-themed\n// scene.\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (in float degree)\n{\n    float rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n    return mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{\n    p = vec2 (dot (p, vec2 (127.1, 311.7)),\n    dot (p, vec2 (269.5, 183.3)));\n\n    return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n    vec2 i = floor (p + (p.x + p.y)*K1);\n\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n    vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n    dot (b, hash (i + o)),\n    dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (70.));\n}\n\nfloat fbm (in vec2 p)\n{\n    mat2 rot = r2d (27.5);\n    float d = noise (p); p *= rot;\n    d += .5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .0625*noise (p);\n    d /= (1. + .5 + .25 + .125 + .0625);\n    return .5 + .5*d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 res = p;\n    res = res * 2. - 1.;\n    res.x *= iResolution.x / iResolution.y;\n    res *= scale;\n\n    return res;\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi);\n}\n\nvec2 polar2cart (in vec2 polar)\n{\n    float x = polar.x*cos (polar.y);\n    float y = polar.x*sin (polar.y);\n    return vec2 (x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = mapToScreen (fragCoord.xy/iResolution.xy, 2.5);\n\n    uv *= r2d (12.*iTime);\n    float len = length (uv);\n    float thickness = .25;\n    float haze = 2.5;\n\n    // distort UVs a bit\n    uv = cart2polar (uv);\n    uv.y += twist * (.5 + .5*sin(cos (uv.x)*len));\n    uv = polar2cart (uv);\n\n    float d1 = abs ((uv.x*haze)*thickness / (uv.x + fbm (uv + 1.25*iTime)));\n    float d2 = abs ((uv.y*haze)*thickness / (uv.y + fbm (uv - 1.5*iTime)));\n    float d3 = abs ((uv.x*uv.y*haze)*thickness / (uv.x*uv.y + fbm (uv - 2.*iTime)));\n    vec3 col = vec3 (.0);\n    float size = .075;\n    col += d1*size*vec3 (.1, .8, 2.);\n    col += d2*size*vec3 (2., .1, .8);\n    col += d3*size*vec3 (.8, 2., .1);\n\n    fragColor = vec4 (col, 1.);\n}\n"
        },
        "spaceRings": {
            "title": "Space Rings",
            "src": "// Space Rings\n\n#define time iTime*1.25\n#define p0 0.5, 0.5, 0.5,  0.5, 0.5, 0.5,  1.0, 1.0, 1.0,  0.0, 0.33, 0.67\n\nconst float numParticles = 25.;\nconst float numRings = 5.;\nconst float offsetMult = 30.;\nconst float tau = 6.23813;\n\nvec3 palette( in float t, in float a0, in float a1, in float a2, in float b0, in float b1, in float b2,\nin float c0, in float c1, in float c2,in float d0, in float d1, in float d2)\n{\n    return vec3(a0,a1,a2) + vec3(b0,b1,b2)*cos( tau*(vec3(c0,c1,c2)*t+vec3(d0,d1,d2)) );\n}\n\nvec3 particleColor(vec2 uv, float radius, float offset, float periodOffset)\n{\n    vec3 color = palette(.4 + offset / 4., p0);\n    uv /= pow(periodOffset, .75) * sin(periodOffset * iTime) + sin(periodOffset + iTime);\n    vec2 pos = vec2(cos(offset * offsetMult + time + periodOffset),\n    sin(offset * offsetMult + time * 5. + periodOffset * tau));\n\n    float dist = radius / distance(uv, pos);\n    return color * pow(dist, 2.) * 1.75;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 3.45;\n\n    fragColor = vec4(0., 0., 0., 1.);\n\n    for (float n = 0.; n <= numRings; n++)\n    {\n        for (float i = 0.; i <= numParticles; i++) {\n            fragColor.rgb += particleColor(uv, .03, i / numParticles, n / 2.);\n        }\n    }\n}"
        },
        "waves": {
            "title": "Waves",
            "src": "// Beat Waves\n// Adapted from http://glslsandbox.com/e#61168.1\n\n//#extension GL_OES_standard_derivatives : enable\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\nuniform float frequency = 6.28; // @@Slider min=3.14 max=25 default=15\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\nvoid main( void ) {\n\n    vec2 position = ( gl_FragCoord.xy / resolution.xy );\n    position.x -= .5;\n    float num = 2.0;\n\n    vec3 color = vec3(\n    sin(frequency * position.x + 0.0 + time) * 0.5 + 0.5 - sin(beatInfo.beat * 3.14) * .5,\n    sin(frequency * position.x * (sin(beatInfo.intensity) * .2 + 1.) + 2.0 + time) * 0.5 + 0.5,\n    sin(frequency * position.x + 4.0 + time) * 0.5 + 0.5 + sin(time * 4.)\n    );\n    // color = vec3(1.0);\n\n    color += vec3(position.y * 2.0 - 1.0);\n\n    color = vec3(\n    floor(color.r * num - 0.5) / num + 0.5,\n    floor(color.g * num - 0.5) / num + 0.5,\n    floor(color.b * num - 0.5) / num + 0.5\n    );\n\n    gl_FragColor = vec4( color, 1.0 );\n\n}"
        },
        "sunsetDelight": {
            "title": "Sunset Delight",
            "src": "// Sunset Delight\n// From http://glslsandbox.com/e#56573\n\n// Fireball\n// Awd\n// @AlexWDunn\n//mod by an+\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n//uniform vec2 mouse;\n\n// SPARKLEMOTION GADGET: Slider {name: \"MouseX\", initialValue: 1.0, minValue: 0.0, maxValue: 1.5}\nuniform float mouseX;\n\n// SPARKLEMOTION GADGET: Slider {name: \"MouseY\", initialValue: 1.0, minValue: 0.0, maxValue: 1.5}\nuniform float mouseY;\n\n#define saturate(oo) clamp(oo, 0.0, 1.0)\n\n// Quality Settings\n#define MarchSteps 6\n\n// Scene Settings\n#define ExpPosition vec3(0.0)\n#define Radius 2.0\n#define Background vec4(0.1, 0.0, 0.0, 1.0)\n\n// Noise Settings\n#define NoiseSteps 4\n#define NoiseAmplitude 0.1\n#define NoiseFrequency 2.2\n#define Animation vec3(0.0, .0, 0.5)\n\n// Colour Gradient\n#define Color1 vec4(0.0, 0.0, 0.0, 1.0)\n#define Color2 vec4(.0, .0, 1.0, 1.0)\n#define Color3 vec4(1.0, .0, 0., 1.0)\n#define Color4 vec4(0.4, 0.8, 0., 1.0)\n\n\n\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v)\n{\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0);\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tvec3 i  = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n\ti = mod289(i);\n\tvec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3  ns = n_ * D.wyz - D.xzx;\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);    // mod(j,N)\n\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\n\t//Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\n\t// Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat Turbulence(vec3 position, float minFreq, float maxFreq, float qWidth)\n{\n\tfloat value = 0.0;\n\tfloat cutoff = clamp(0.5/qWidth, 0.0, maxFreq);\n\tfloat fade;\n\tfloat fOut = minFreq;\n\n\tfor(int i=NoiseSteps ; i>=0 ; i++)\n\t{\n\t\tif(fOut >= 0.5 * cutoff) break;\n\n\t\tfOut *= 2.0;\n\t\tvalue += abs(snoise(position * fOut))/fOut;\n\t}\n\n\tfade = clamp(2.0 * (cutoff-fOut)/cutoff, 0.0, 1.0);\n\tvalue += fade * abs(snoise(position * fOut))/fOut;\n\n\treturn 1.0-value;\n}\n\nfloat SphereDist(vec3 position)\n{\n\treturn length(position - ExpPosition) - Radius;\n}\n\nvec4 Shade(float distance)\n{\n\tfloat c1 = saturate(distance*5.0 + 0.5);\n\tfloat c2 = saturate(distance*5.0);\n\tfloat c3 = saturate(distance*3.4 - 0.5);\n\n\tvec4 a = mix(Color1,Color2, c1);\n\tvec4 b = mix(a,     Color3, c2);\n\treturn \t mix(b,     Color4, c3);\n}\n\n\n// Draws the scene\nfloat RenderScene(vec3 position, out float distance)\n{\n\tfloat noise = Turbulence(position * NoiseFrequency + Animation*time, 0.1, 1.5, 0.03) * NoiseAmplitude;\n\tnoise = saturate(abs(noise));\n\tdistance = SphereDist(position) - noise;\n\n\treturn noise;\n}\n\n// Basic ray marching method.\nvec4 March(vec3 rayOrigin, vec3 rayStep)\n{\n\tvec3 position = rayOrigin;\n\n\tfloat distance;\n\tfloat displacement;\n\n\tfor(int step = MarchSteps; step >=0  ; --step)\n\t{\n\t\tdisplacement = RenderScene(position, distance);\n\n\t\tif(distance < 0.05) break;\n\n\t\tposition += rayStep * distance;\n\t}\n\treturn mix(Shade(displacement), Background, float(distance >= 0.5));\n}\n\nbool IntersectSphere(vec3 ro, vec3 rd, vec3 pos, float radius, out vec3 intersectPoint)\n{\n\tvec3 relDistance = (ro - pos);\n\n\tfloat b = dot(relDistance, rd);\n\tfloat c = dot(relDistance, relDistance) - radius*radius;\n\tfloat d = b*b - c;\n\n\tintersectPoint = ro + rd*(-b - sqrt(d));\n\n\treturn d >= 0.0;\n}\n\nvoid main(void)\n{\n\tvec2 p = (gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;\n\n\tp.x *= resolution.x/resolution.y;\n\n\tfloat rotx = mouseY * 4.0;\n\tfloat roty = -mouseX * 4.0;\n\tfloat zoom = 5.0;\n\n\t// camera\n\tvec3 ro = zoom * normalize(vec3(cos(roty), cos(rotx), sin(roty)));\n\tvec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n\tvec3 uu = normalize(cross( vec3(0.0, 1.0, 0.0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(p.x*uu + p.y*vv + 4.5*ww);\n\n\tvec4 col = Background;\n\n\tvec3 origin;\n\n\tif(IntersectSphere(ro, rd, ExpPosition, Radius + NoiseAmplitude*6.0, origin))\n\t{\n\t\tcol = March(origin, rd);\n\t}\n\n\tgl_FragColor = col;\n}\n"
        },
        "huerthquake": {
            "title": "Huerthquake",
            "src": "// Huearthquake\n// From http://glslsandbox.com/e#46400\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265358\n#define TWO_PI 6.28318530718\n\nuniform vec2 resolution;\nuniform float time;\n\nvec3 colorA = vec3(0.149, 0.141, 0.912);\nvec3 colorB = vec3(1.000, 0.833, 0.224);\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n/* Coordinate and unit utils */\nvec2 coord(in vec2 p) {\n    p = p / resolution.xy;\n    // correct aspect ratio\n    if (resolution.x > resolution.y) {\n        p.x *= resolution.x / resolution.y;\n        p.x += (resolution.y - resolution.x) / resolution.y / 2.0;\n    } else {\n        p.y *= resolution.y / resolution.x;\n        p.y += (resolution.x - resolution.y) / resolution.x / 2.0;\n    }\n    // centering\n    p -= 0.5;\n    p *= vec2(-1.0, 1.0);\n    return p;\n}\n#define rx 1.0 / min(resolution.x, resolution.y)\n#define uv gl_FragCoord.xy / resolution.xy\n#define st coord(gl_FragCoord.xy)\n#define mx coord(u_mouse)\n\nmat2 rot(in float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle),  cos(angle));\n}\n\nfloat wave(in vec2 pt, in float f, in float v) {\n    float r = length(pt);\n    float a = atan(pt.y, pt.x);\n    return sin(r * TWO_PI * f - v * time);\n}\n\nvoid main() {\n    vec2 pt = st;\n\n    float f = 10.0 * abs(sin(0.1 * time));\n    float v = 10.0;\n    float g = wave(pt, f, v);\n\n    for (float k = 0.0; k < 8.0; k++) {\n        float t = PI / 4.0 * k;\n        vec2 offset = 0.5 * vec2(cos(t), sin(t));\n        g += wave(pt + offset, f, v);\n    }\n\n    g *= 0.5;\n    g = step(g, 0.0);\n\n    vec3 rgb = mix(colorA, colorB, g);\n\n    gl_FragColor = vec4(rgb, 1.0);\n}\n"
        },
        "jacobianUndistortion": {
            "title": "Jacobian Undistortion",
            "src": "// Tuto: Jacobians and undistortion\n// from https://www.shadertoy.com/view/WlByRW\n\n#define Circle(U,r) smoothstep(50./R.y,0., abs(length(U)-r)-.02 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n    U = ( 2.*u - R ) / R.y, I, L;                  // normalized coordinates\n\n    U += .5*U*mat2(cos(2.*U+iTime),sin(2.*U-iTime));   // distorted coordinates\n    U *= 4.;\n\n    I =floor(U); L = 2.*fract(U)-1.;                   // draw distorted checker\n    O = vec4 (.4*mod(I.x+I.y,2.) );\n\n    O.r += Circle(L,.4);                               // draw circle in distorted space\n\n    mat2 J = transpose(mat2(dFdx(U),dFdy(U))) *R.y/8.; // the Jacobian store the local distorted frame\n    L *= inverse(J);                                   // undistort by applying the inverse transform\n    // or if you prefer right-multiplying matrices :\n    // mat2 J = mat2(dFdx(U),dFdy(U)) *R.y/8.;            // the Jacobian store the local distorted frame\n    // L = inverse(J)*L;                                  // undistort by applying the inverse transform\n    O.g += Circle(L,.4);                               // draw circle in undistorted space\n\n    O.b = ( .5+.5*determinant(J) ) *.6;                // det(J) shows compression in distortion\n    //O.b = length(vec4(J))/3.;\n    O.a = 1.;\n}"
        },
        "solidColor": {
            "title": "Solid Color",
            "src": "// Solid Color.glsl\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec4 color; // @@ColorPicker default=#3300ff\nuniform float colorBrightness; // @@Slider default=.75\nuniform float sparkliness; // @@Slider default=0 max=.5\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123 + time);\n}\n\nvoid main() {\n    gl_FragColor = color * colorBrightness\n        + ((sparkliness < random(gl_FragCoord.xy / resolution.xy)) ? vec4(0.) : vec4(1.));\n}"
        },
        "sunsetClouds": {
            "title": "Sunset Clouds",
            "src": "//Cloud Ten\n//by nimitz 2015 (twitter: @stormoid)\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define time iTime\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat moy = 0.;\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rz.x, rz.y, fp.z );\n}\n\nfloat fbm(in vec3 x)\n{\n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<2; i++)\n    {\n        rz += noise(x)*a;\n        a*=.35;\n        x*= 4.;\n    }\n    return rz;\n}\n\nfloat path(in float x){ return sin(x*0.01-3.1415)*28.+6.5; }\nfloat map(vec3 p){\n    return p.y*0.07 + (fbm(p*0.3)-0.1) + sin(p.x*0.24 + sin(p.z*.01)*7.)*0.22+0.15 + sin(p.z*0.08)*0.05;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n    float precis = .3;\n    float h= 1.;\n    float d = 0.;\n    for( int i=0; i<17; i++ )\n    {\n        if( abs(h)<precis || d>70. ) break;\n        d += h;\n        vec3 pos = ro+rd*d;\n        pos.y += .5;\n\t    float res = map(pos)*7.;\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 lgt = vec3(0);\nfloat mapV( vec3 p ){ return clamp(-map(p), 0., 1.);}\nvec4 marchV(in vec3 ro, in vec3 rd, in float t, in vec3 bgc)\n{\n\tvec4 rz = vec4( 0.0 );\n\t\n\tfor( int i=0; i<150; i++ )\n\t{\n\t\tif(rz.a > 0.99 || t > 200.) break;\n\t\t\n\t\tvec3 pos = ro + t*rd;\n        float den = mapV(pos);\n        \n        vec4 col = vec4(mix( vec3(.8,.75,.85), vec3(.0), den ),den);\n        col.xyz *= mix(bgc*bgc*2.5,  mix(vec3(0.1,0.2,0.55),vec3(.8,.85,.9),moy*0.4), clamp( -(den*40.+0.)*pos.y*.03-moy*0.5, 0., 1. ) );\n        col.rgb += clamp((1.-den*6.) + pos.y*0.13 +.55, 0., 1.)*0.35*mix(bgc,vec3(1),0.7); //Fringes\n        col += clamp(den*pos.y*.15, -.02, .0); //Depth occlusion\n        col *= smoothstep(0.2+moy*0.05,.0,mapV(pos+1.*lgt))*.85+0.15; //Shadows\n        \n\t\tcol.a *= .95;\n\t\tcol.rgb *= col.a;\n\t\trz = rz + col*(1.0 - rz.a);\n\n        t += max(.3,(2.-den*30.)*t*0.011);\n\t}\n\n\treturn clamp(rz, 0., 1.);\n}\n\nfloat pent(in vec2 p){    \n    vec2 q = abs(p);\n    return max(max(q.x*1.176-p.y*0.385, q.x*0.727+p.y), -p.y*1.237)*1.;\n}\n\nvec3 lensFlare(vec2 p, vec2 pos)\n{\n\tvec2 q = p-pos;\n    float dq = dot(q, q);\n    vec2 dist = p*(length(p))*0.75;\n\tfloat ang = atan(q.x,q.y);\n    vec2 pp = mix(p, dist, 0.5);\n    float sz = 0.01;\n    float rz = pow(abs(fract(ang*.8+.12)-0.5),3.)*(noise(ang*15.))*0.5;\n    rz *= smoothstep(1.0, 0.0, dot(q,q));\n    rz *= smoothstep(0.0, 0.01, dot(q,q));\n    rz += max(1.0/(1.0 + 30.0*pent(dist + 0.8*pos)),.0)*0.17;\n\trz += clamp(sz-pow(pent(pp + 0.15*pos),1.55),.0, 1.)*5.0;\n\trz += clamp(sz-pow(pent(pp + 0.1*pos),2.4),.0, 1.)*4.0;\n\trz += clamp(sz-pow(pent(pp - 0.05*pos),1.2),.0, 1.)*4.0;\n    rz += clamp(sz-pow(pent((pp + .5*pos)),1.7),.0, 1.)*4.0;\n    rz += clamp(sz-pow(pent((pp + .3*pos)),1.9),.0, 1.)*3.0;\n    rz += clamp(sz-pow(pent((pp - .2*pos)),1.3),.0, 1.)*4.0;\n    return vec3(clamp(rz,0.,1.));\n}\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nvec2 uv;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 q = fragCoord.xy / iResolution.xy;\n    uv = fragCoord.xy;\n    vec2 p = q - 0.5;\n\tfloat asp =iResolution.x/iResolution.y;\n    p.x *= asp;\n\tvec2 mo = iMouse.xy / iResolution.xy;\n\tmoy = mo.y;\n    float st = sin(time*0.3-1.3)*0.2;\n    vec3 ro = vec3(0.,-2.+sin(time*.3-1.)*2.,time*30.);\n    ro.x = path(ro.z);\n    vec3 ta = ro + vec3(0,0,1);\n    vec3 fw = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), fw ));\n    vec3 vv = normalize(cross(fw,uu));\n    const float zoom = 1.;\n    vec3 rd = normalize( p.x*uu + p.y*vv + -zoom*fw );\n    \n    float rox = sin(time*0.2)*0.6+2.9;\n    rox += smoothstep(0.6,1.2,sin(time*0.25))*3.5;\n   \tfloat roy = sin(time*0.5)*0.2;\n    mat3 rotation = rot_x(-roy)*rot_y(-rox+st*1.5)*rot_z(st);\n\tmat3 inv_rotation = rot_z(-st)*rot_y(rox-st*1.5)*rot_x(roy);\n    rd *= rotation;\n    rd.y -= dot(p,p)*0.06;\n    rd = normalize(rd);\n    \n    vec3 col = vec3(0.);\n    lgt = normalize(vec3(-0.3,mo.y+0.1,1.));  \n    float rdl = clamp(dot(rd, lgt),0.,1.);\n  \n    vec3 hor = mix( vec3(.9,.6,.7)*0.35, vec3(.5,0.05,0.05), rdl );\n    hor = mix(hor, vec3(.5,.8,1),mo.y);\n    col += mix( vec3(.2,.2,.6), hor, exp2(-(1.+ 3.*(1.-rdl))*max(abs(rd.y),0.)) )*.6;\n    col += .8*vec3(1.,.9,.9)*exp2(rdl*650.-650.);\n    col += .3*vec3(1.,1.,0.1)*exp2(rdl*100.-100.);\n    col += .5*vec3(1.,.7,0.)*exp2(rdl*50.-50.);\n    col += .4*vec3(1.,0.,0.05)*exp2(rdl*10.-10.);  \n    vec3 bgc = col;\n    \n    float rz = march(ro,rd);\n    \n    if (rz < 70.)\n    {   \n        vec4 res = marchV(ro, rd, rz-5., bgc);\n    \tcol = col*(1.0-res.w) + res.xyz;\n    }\n    \n    vec3 proj = (-lgt*inv_rotation);\n    col += 1.4*vec3(0.7,0.7,0.4)*clamp(lensFlare(p,-proj.xy/proj.z*zoom)*proj.z,0., 1.);\n    \n    float g = smoothstep(0.03,.97,mo.x);\n    col = mix(mix(col,col.brg*vec3(1,0.75,1),clamp(g*2.,0.0,1.0)), col.bgr, clamp((g-0.5)*2.,0.0,1.));\n    \n\tcol = clamp(col, 0., 1.);\n    col = col*0.5 + 0.5*col*col*(3.0-2.0*col); //saturation\n    col = pow(col, vec3(0.416667))*1.055 - 0.055; //sRGB\n\tcol *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 ); //Vign\n\n\tfragColor = vec4( col, 1.0 );\n}"
        },
        "oceanClouds": {
            "title": "Ocean Clouds",
            "src": "// Clouds: slice based volumetric height-clouds with god-rays, density, sun-radiance/shadow\n// and \n// Water: simple reflecting sky/sun and cloud shaded height-modulated waves\n//\n// Created by Frank Hugenroth 03/2013\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// noise and raymarching based on concepts and code from shaders by inigo quilez\n//\n\n// some variables to change :)\n\n#define RENDER_GODRAYS    1    // set this to 1 to enable god-rays\n//#define RENDER_GODRAYS    0    // disable god-rays\n\n#define RENDER_CLOUDS 1\n#define RENDER_WATER   1\n\nfloat waterlevel = 70.0;        // height of the water\nfloat wavegain   = 1.0;       // change to adjust the general water wave level\nfloat large_waveheight = 1.0; // change to adjust the \"heavy\" waves (set to 0.0 to have a very still ocean :)\nfloat small_waveheight = 1.0; // change to adjust the small waves\n\nvec3 fogcolor    = vec3( 0.5, 0.7, 1.1 );              \nvec3 skybottom   = vec3( 0.6, 0.8, 1.2 );\nvec3 skytop      = vec3(0.05, 0.2, 0.5);\nvec3 reflskycolor= vec3(0.025, 0.10, 0.20);\nvec3 watercolor  = vec3(0.2, 0.25, 0.3);\n\nvec3 light       = normalize( vec3(  0.1, 0.25,  0.9 ) );\n\n\n\n\n\n\n\n\n\n// random/hash function              \nfloat hash( float n )\n{\n  return fract(cos(n)*41415.92653);\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\n\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\n\n// Fractional Brownian motion\nfloat fbm( vec3 p )\n{\n  float f = 0.5000*noise( p ); p = m*p*1.1;\n  f += 0.2500*noise( p ); p = m*p*1.2;\n  f += 0.1666*noise( p ); p = m*p;\n  f += 0.0834*noise( p );\n  return f;\n}\n\nmat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\n// Fractional Brownian motion\nfloat fbm( vec2 p )\n{\n  float f = 0.5000*noise( p ); p = m2*p;\n  f += 0.2500*noise( p ); p = m2*p;\n  f += 0.1666*noise( p ); p = m2*p;\n  f += 0.0834*noise( p );\n  return f;\n}\n\n\n// this calculates the water as a height of a given position\nfloat water( vec2 p )\n{\n  float height = waterlevel;\n\n  vec2 shift1 = 0.001*vec2( iTime*160.0*2.0, iTime*120.0*2.0 );\n  vec2 shift2 = 0.001*vec2( iTime*190.0*2.0, -iTime*130.0*2.0 );\n\n  // coarse crossing 'ocean' waves...\n  float wave = 0.0;\n  wave += sin(p.x*0.021  + shift2.x)*4.5;\n  wave += sin(p.x*0.0172+p.y*0.010 + shift2.x*1.121)*4.0;\n  wave -= sin(p.x*0.00104+p.y*0.005 + shift2.x*0.121)*4.0;\n  // ...added by some smaller faster waves...\n  wave += sin(p.x*0.02221+p.y*0.01233+shift2.x*3.437)*5.0;\n  wave += sin(p.x*0.03112+p.y*0.01122+shift2.x*4.269)*2.5 ;\n  wave *= large_waveheight;\n  wave -= fbm(p*0.004-shift2*.5)*small_waveheight*24.;\n  // ...added by some distored random waves (which makes the water looks like water :)\n\n  float amp = 6.*small_waveheight;\n  shift1 *= .3;\n  for (int i=0; i<7; i++)\n  {\n    wave -= abs(sin((noise(p*0.01+shift1)-.5)*3.14))*amp;\n    amp *= .51;\n    shift1 *= 1.841;\n    p *= m2*0.9331;\n  }\n  \n  height += wave;\n  return height;\n}\n\n\n// cloud intersection raycasting\nfloat trace_fog(in vec3 rStart, in vec3 rDirection )\n{\n#ifdef RENDER_CLOUDS\n  // makes the clouds moving...\n  vec2 shift = vec2( iTime*80.0, iTime*60.0 );\n  float sum = 0.0;\n  // use only 12 cloud-layers ;)\n  // this improves performance but results in \"god-rays shining through clouds\" effect (sometimes)...\n  float q2 = 0., q3 = 0.;\n  for (int q=0; q<10; q++)\n  {\n    float c = (q2+350.0-rStart.y) / rDirection.y;// cloud distance\n    vec3 cpos = rStart + c*rDirection + vec3(831.0, 321.0+q3-shift.x*0.2, 1330.0+shift.y*3.0); // cloud position\n    float alpha = smoothstep(0.5, 1.0, fbm( cpos*0.0015 )); // cloud density\n\tsum += (1.0-sum)*alpha; // alpha saturation\n    if (sum>0.98)\n        break;\n    q2 += 120.;\n    q3 += 0.15;\n  }\n  \n  return clamp( 1.0-sum, 0.0, 1.0 );\n#else\n  return 1.0;\n#endif\n}\n\n// fog and water intersection function.\n// 1st: collects fog intensity while traveling\n// 2nd: check if hits the water surface and returns the distance\nbool trace(in vec3 rStart, in vec3 rDirection, in float sundot, out float fog, out float dist)\n{\n  float h = 20.0;\n  float t = 0.0;\n  float st = 1.0;\n  float alpha = 0.1;\n  float asum = 0.0;\n  vec3 p = rStart;\n\t\n  for( int j=1000; j<1120; j++ )\n  {\n    // some speed-up if all is far away...\n    if( t>500.0 ) \n      st = 2.0;\n    else if( t>800.0 ) \n      st = 5.0;\n    else if( t>1000.0 ) \n      st = 12.0;\n\n    p = rStart + t*rDirection; // calc current ray position\n\n#ifdef RENDER_GODRAYS\n    if (rDirection.y>0. && sundot > 0.001 && t>400.0 && t < 2500.0)\n    {\n      alpha = sundot * clamp((p.y-waterlevel)/waterlevel, 0.0, 1.0) * st * 0.024*smoothstep(0.80, 1.0, trace_fog(p,light));\n      asum  += (1.0-asum)*alpha;\n      if (asum > 0.9)\n        break;\n    }\n#endif\n\n    h = p.y - water(p.xz);\n\n    if( h<0.1 ) // hit the water?\n    {\n      dist = t; \n      fog = asum;\n      return true;\n    }\n\n    if( p.y>450.0 ) // lost in space? quit...\n      break;\n    \n    // speed up ray if possible...    \n    if(rDirection.y > 0.0) // look up (sky!) -> make large steps\n      t += 30.0 * st;\n    else\n      t += max(1.0,1.0*h)*st;\n  }\n\n  dist = t; \n  fog = asum;\n  if (h<10.0)\n   return true;\n  return false;\n}\n\n\nvec3 camera( float time )\n{\n  return vec3( 500.0 * sin(1.5+1.57*time), 0.0, 1200.0*time );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n  vec2 s = xy*vec2(1.75,1.0);\n\n  // get camera position and view direction\n  float time = (iTime+13.5+44.)*.05;\n  vec3 campos = camera( time );\n  vec3 camtar = camera( time + 0.4 );\n  campos.y = max(waterlevel+30.0, waterlevel+90.0 + 60.0*sin(time*2.0));\n  camtar.y = campos.y*0.5;\n\n  float roll = 0.14*sin(time*1.2);\n  vec3 cw = normalize(camtar-campos);\n  vec3 cp = vec3(sin(roll), cos(roll),0.0);\n  vec3 cu = normalize(cross(cw,cp));\n  vec3 cv = normalize(cross(cu,cw));\n  vec3 rd = normalize( s.x*cu + s.y*cv + 1.6*cw );\n\n  float sundot = clamp(dot(rd,light),0.0,1.0);\n\n  vec3 col;\n  float fog=0.0, dist=0.0;\n\n  if (!trace(campos,rd,sundot, fog, dist))\n  {\n    // render sky\n    float t = pow(1.0-0.7*rd.y, 15.0);\n    col = 0.8*(skybottom*t + skytop*(1.0-t));\n    // sun\n    col += 0.47*vec3(1.6,1.4,1.0)*pow( sundot, 350.0 );\n    // sun haze\n    col += 0.4*vec3(0.8,0.9,1.0)*pow( sundot, 2.0 );\n\n#ifdef RENDER_CLOUDS\n    // CLOUDS\n    vec2 shift = vec2( iTime*80.0, iTime*60.0 );\n    vec4 sum = vec4(0,0,0,0); \n    for (int q=1000; q<1100; q++) // 100 layers\n    {\n      float c = (float(q-1000)*12.0+350.0-campos.y) / rd.y; // cloud height\n      vec3 cpos = campos + c*rd + vec3(831.0, 321.0+float(q-1000)*.15-shift.x*0.2, 1330.0+shift.y*3.0); // cloud position\n      float alpha = smoothstep(0.5, 1.0, fbm( cpos*0.0015 ))*.9; // fractal cloud density\n      vec3 localcolor = mix(vec3( 1.1, 1.05, 1.0 ), 0.7*vec3( 0.4,0.4,0.3 ), alpha); // density color white->gray\n      alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer's density, the more the higher layers will be hidden)\n      sum += vec4(localcolor*alpha, alpha); // sum up weightened color\n      \n      if (sum.w>0.98)\n        break;\n    }\n    float alpha = smoothstep(0.7, 1.0, sum.w);\n    sum.rgb /= sum.w+0.0001;\n\n    // This is an important stuff to darken dense-cloud parts when in front (or near)\n    // of the sun (simulates cloud-self shadow)\n    sum.rgb -= 0.6*vec3(0.8, 0.75, 0.7)*pow(sundot,13.0)*alpha;\n    // This brightens up the low-density parts (edges) of the clouds (simulates light scattering in fog)\n    sum.rgb += 0.2*vec3(1.3, 1.2, 1.0)* pow(sundot,5.0)*(1.0-alpha);\n\n    col = mix( col, sum.rgb , sum.w*(1.0-t) );\n#endif\n\n    // add god-rays\n    col += vec3(0.5, 0.4, 0.3)*fog;\n  }\n  else\n  {\n#ifdef RENDER_WATER        \n    //  render water\n    \n    vec3 wpos = campos + dist*rd; // calculate position where ray meets water\n\n    // calculate water-mirror\n    vec2 xdiff = vec2(0.1, 0.0)*wavegain*4.;\n    vec2 ydiff = vec2(0.0, 0.1)*wavegain*4.;\n\n    // get the reflected ray direction\n    rd = reflect(rd, normalize(vec3(water(wpos.xz-xdiff) - water(wpos.xz+xdiff), 1.0, water(wpos.xz-ydiff) - water(wpos.xz+ydiff))));  \n    float refl = 1.0-clamp(dot(rd,vec3(0.0, 1.0, 0.0)),0.0,1.0);\n  \n    float sh = smoothstep(0.2, 1.0, trace_fog(wpos+20.0*rd,rd))*.7+.3;\n    // water reflects more the lower the reflecting angle is...\n    float wsky   = refl*sh;     // reflecting (sky-color) amount\n    float wwater = (1.0-refl)*sh; // water-color amount\n\n    float sundot = clamp(dot(rd,light),0.0,1.0);\n\n    // watercolor\n\n    col = wsky*reflskycolor; // reflecting sky-color \n    col += wwater*watercolor;\n    col += vec3(.003, .005, .005) * (wpos.y-waterlevel+30.);\n\n    // Sun\n    float wsunrefl = wsky*(0.5*pow( sundot, 10.0 )+0.25*pow( sundot, 3.5)+.75*pow( sundot, 300.0));\n    col += vec3(1.5,1.3,1.0)*wsunrefl; // sun reflection\n\n#endif\n\n    // global depth-fog\n    float fo = 1.0-exp(-pow(0.0003*dist, 1.5));\n    vec3 fco = fogcolor + 0.6*vec3(0.6,0.5,0.4)*pow( sundot, 4.0 );\n    col = mix( col, fco, fo );\n\n    // add god-rays\n    col += vec3(0.5, 0.4, 0.3)*fog; \n  }\n\n  fragColor=vec4(col,1.0);\n}\n\n\n"
        },
        "clouds": {
            "title": "Clouds",
            "src": "const float cloudscale = 1.1;\nconst float speed = 0.03;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.2;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \n    float time = iTime * speed;\n    float q = fbm(uv * cloudscale * 0.5);\n    \n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv *= cloudscale;\n    uv -= q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.7;\n    }\n    \n    //noise shape\n\tfloat f = 0.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale;\n    uv -= q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f;\n    \n    //noise colour\n    float c = 0.0;\n    time = iTime * speed * 2.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*2.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    time = iTime * speed * 3.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*3.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n\t\n    c += c1;\n    \n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n   \n    f = cloudcover + cloudalpha*f*r;\n    \n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n\tfragColor = vec4( result, 1.0 );\n}"
        },
        "electricEelUniverse": {
            "title": "Electric Eel Universe",
            "src": "// CC0: Electric Eel Universe\n//  Saturday tinkering with an old failed shader\n//  Turned out a bit better today\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 rayCylinder(vec3 ro, vec3 rd, vec3 cb, vec3 ca, float cr) {\n  vec3  oc = ro - cb;\n  float card = dot(ca,rd);\n  float caoc = dot(ca,oc);\n  float a = 1.0 - card*card;\n  float b = dot( oc, rd) - caoc*card;\n  float c = dot( oc, oc) - caoc*caoc - cr*cr;\n  float h = b*b - a*c;\n  if( h<0.0 ) return vec2(-1.0); //no intersection\n  h = sqrt(h);\n  return vec2(-b-h,-b+h)/a;\n}\n\n// License: Unknown, author: Unknown, found: shadertoy somewhere, don't remember where\nfloat dfcos(float x) {\n  return sqrt(x*x+1.0)*0.8-1.8;\n}\n\n// License: Unknown, author: Unknown, found: shadertoy somewhere, don't remember where\nfloat dfcos(vec2 p, float freq) {\n  float x = p.x;\n  float y = p.y;\n  x *= freq;\n    \n  float x1 = abs(mod(x+PI,TAU)-PI);\n  float x2 = abs(mod(x   ,TAU)-PI);\n    \n  float a = 0.18*freq;\n    \n  x1 /= max( y*a+1.0-a,1.0);\n  x2 /= max(-y*a+1.0-a,1.0);\n  return (mix(-dfcos(x2)-1.0,dfcos(x1)+1.0,clamp(y*0.5+0.5,0.0,1.0)))/max(freq*0.8,1.0)+max(abs(y)-1.0,0.0)*sign(y);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 l = normalize(vec3(0.0, 0., -1.0));\n  vec3 baseCol = hsv2rgb(vec3(0.6, 0.95, .0025));\n  return baseCol/(1.00001+dot(rd, l));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  const float rdd = 2.0;\n  const float mm = 4.0;\n  const float rep = 27.0;\n\n  vec3 rd = normalize(-p.x*uu + p.y*vv + rdd*ww);\n  \n  vec3 skyCol = skyColor(ro, rd);\n\n  rd.yx *= ROT(0.1*TIME);\n\n  vec3 col = skyCol;\n\n  // I read somewhere that if you call atan in a shader you got no business writing shader code.\n  //  I even call it in a loop :)\n  float a = atan(rd.y, rd.x);\n  for(float i = 0.0; i < mm; ++i) {\n    float ma = a;\n    float sz = rep+i*6.0;\n    float slices = TAU/sz; \n    float na = mod1(ma, slices);\n\n    float h1 = hash(na+13.0*i+123.4);\n    float h2 = fract(h1*3677.0);\n    float h3 = fract(h1*8677.0);\n\n    float tr = mix(0.5, 3.0, h1);\n    vec2 tc = rayCylinder(ro, rd, ro, vec3(0.0, 0.0, 1.0), tr);\n    vec3 tcp = ro + tc.y*rd;\n    vec2 tcp2 = vec2(tcp.z, atan(tcp.y, tcp.x));\n  \n    float zz = mix(0.025, 0.05, sqrt(h1))*rep/sz;\n    float tnpy = mod1(tcp2.y, slices);\n    float fo = smoothstep(0.5*slices, 0.25*slices, abs(tcp2.y));\n    tcp2.x += -h2*TIME;\n    tcp2.y *= tr*PI/3.0;\n\n    tcp2/=zz;\n    float d = dfcos(tcp2, 2.0*zz);\n//    float d = tcp2.y;\n    d = abs(d);\n    d *= zz;\n\n    vec3 bcol = (1.0+cos(vec3(0.0, 1.0, 2.0)+TAU*h3+0.5*h2*h2*tcp.z))*0.00005;\n    bcol /= max(d*d, 0.000+5E-7*tc.y*tc.y);\n    bcol *= exp(-0.04*tc.y*tc.y);\n    bcol *= smoothstep(-0.5, 1.0, sin(mix(0.125, 1.0, h2)*tcp.z));\n    bcol *= fo;\n    col += bcol;\n  }\n\n  return col;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float tm = 1.5*TIME+12.3;\n  vec3 ro   = vec3(0.0, 0.0, tm);\n  vec3 dro  = normalize(vec3(1.0, 0.0, 3.0));\n  dro.xz *= ROT(0.2*sin(0.05*tm));\n  dro.yz *= ROT(0.2*sin(0.05*tm*sqrt(0.5)));\n  const vec3 up = vec3(0.0,1.0,0.0);\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = (cross(ww, uu));\n  vec3 col = color(ww, uu, vv, ro, p);\n  col -= 0.125*vec3(0.0, 1.0, 2.0).yzx*length(pp);\n  col = aces_approx(col);\n  col = sRGB(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n\n"
        },
        "rainbows": {
            "title": "Rainbows",
            "src": "float circle(vec2 pos, vec2 pixel, float radius) {\n    return smoothstep(radius, radius * 0.6, distance(pos, pixel));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 rgb = vec3(0.);\n    \n    float frequency = 2.;\n    float amplitude = 0.2;\n    float speed = 2.;\n    float rh = 0.07;\n\n    float sr = (sin((iTime * speed) + uv.x * frequency)) * amplitude;\n    float sg = (sin(((iTime + .2) * speed) + uv.x * frequency)) * amplitude;\n    float sb = (sin(((iTime + .4) * speed) + uv.x * frequency)) * amplitude;\n    \n    sr += cos((iTime + sin(uv.x)) * .6) * 0.2;\n    sg += cos((iTime + sin(uv.x)) * .6) * 0.2;\n    sb += cos((iTime + sin(uv.x)) * .6) * 0.2;\n    \n    rgb.r += smoothstep(sr + rh, sr, uv.y) - smoothstep(sr, sr - rh, uv.y);\n    rgb.g += smoothstep(sg + rh, sg, uv.y) - smoothstep(sg, sg - rh, uv.y);\n    rgb.b += smoothstep(sb + rh, sb, uv.y) - smoothstep(sb, sb - rh, uv.y);\n    \n\n    for(float i = 0.; i < 45.; i++) {\n    \tfloat cx = cos((iTime * cos(clamp(iTime * 0.019, 0.7, 0.8)) * 2.) + i * 0.08) * 0.8;\n    \tfloat cy = sin((iTime * sin(clamp(iTime * 0.01, 0.8, 0.9)) * 1.2) + i * 0.06) * 0.4;    \n        \n\t    rgb += circle(vec2(cx, cy), uv, 0.05) * 0.97;\n    }    \n\n    fragColor = vec4(rgb,1.0);\n}"
        },
        "voronoi": {
            "title": "Voronoi",
            "src": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// I've not seen anybody out there computing correct cell interior distances for Voronoi\n// patterns yet. That's why they cannot shade the cell interior correctly, and why you've\n// never seen cell boundaries rendered correctly. \n//\n// However, here's how you do mathematically correct distances (note the equidistant and non\n// degenerated grey isolines inside the cells) and hence edges (in yellow):\n//\n// https://iquilezles.org/articles/voronoilines\n//\n// More Voronoi shaders:\n//\n// Exact edges:  https://www.shadertoy.com/view/ldl3W8\n// Hierarchical: https://www.shadertoy.com/view/Xll3zX\n// Smooth:       https://www.shadertoy.com/view/ldB3zc\n// Voronoise:    https://www.shadertoy.com/view/Xd23Dh\n\n#define ANIMATE\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\t//return textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n\t\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xx;\n\n    vec3 c = voronoi( 8.0*p );\n\n\t// isolines\n    vec3 col = c.x*(0.5 + 0.5*sin(64.0*c.x))*vec3(1.0);\n    // borders\t\n    col = mix( vec3(1.0,0.6,0.0), col, smoothstep( 0.04, 0.07, c.x ) );\n    // feature points\n\tfloat dd = length( c.yz );\n\tcol = mix( vec3(1.0,0.6,0.1), col, smoothstep( 0.0, 0.12, dd) );\n\tcol += vec3(1.0,0.6,0.1)*(1.0-smoothstep( 0.0, 0.04, dd));\n\n\tfragColor = vec4(col,1.0);\n}\n"
        },
        "voxelEdges": {
            "title": "Voxel Edges",
            "src": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// Shading technique explained here:\n//\n// https://iquilezles.org/articles/voxellines\n\n\n\n// consider replacing this by a proper noise function\n// float noise( in vec3 x )\n// {\n//     vec3 p = floor(x);\n//     vec3 f = fract(x);\n// \tf = f*f*(3.0-2.0*f);\n// \tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n// \tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n// \treturn mix( rg.x, rg.y, f.z );\n// }\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\nfloat mapTerrain( vec3 p )\n{\n\tp *= 0.1; \n\tp.xz *= 0.6;\n\t\n\tfloat time = 0.5 + 0.15*iTime;\n\tfloat ft = fract( time );\n\tfloat it = floor( time );\n\tft = smoothstep( 0.7, 1.0, ft );\n\ttime = it + ft;\n\tfloat spe = 1.4;\n\t\n\tfloat f;\n    f  = 0.5000*noise( p*1.00 + vec3(0.0,1.0,0.0)*spe*time );\n    f += 0.2500*noise( p*2.02 + vec3(0.0,2.0,0.0)*spe*time );\n    f += 0.1250*noise( p*4.01 );\n\treturn 25.0*f-10.0;\n}\n\nvec3 gro = vec3(0.0);\n\nfloat map(in vec3 c) \n{\n\tvec3 p = c + 0.5;\n\t\n\tfloat f = mapTerrain( p ) + 0.25*p.y;\n\n    f = mix( f, 1.0, step( length(gro-p), 5.0 ) );\n\n\treturn step( f, 0.5 );\n}\n\nvec3 lig = normalize( vec3(-0.4,0.3,0.7) );\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nvec3 path( float t, float ya )\n{\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x, 18.0 + ya*4.0*sin(0.05*t), p.y );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nfloat maxcomp( in vec4 v )\n{\n    return max( max(v.x,v.y), max(v.z,v.w) );\n}\n\nfloat isEdge( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wb = smoothstep( 0.85, 0.99, vec4(uv.x,\n                                           st.x,\n                                           uv.y,\n                                           st.y) ) * ( 1.0 - va + va*vc );\n    // corners\n    vec4 wc = smoothstep( 0.85, 0.99, vec4(uv.x*uv.y,\n                                           st.x*uv.y,\n                                           st.x*st.y,\n                                           uv.x*st.y) ) * ( 1.0 - vb + vd*vb );\n    return maxcomp( max(wb,wc) );\n}\n\nfloat calcOcc( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;\n\n    // corners\n    vec4 wb = vec4(uv.x*uv.y,\n                   st.x*uv.y,\n                   st.x*st.y,\n                   uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\n    \n    return wa.x + wa.y + wa.z + wa.w +\n           wb.x + wb.y + wb.z + wb.w;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n\t\n    // raymarch\t\n\tvec3 vos, dir;\n\tfloat t = castRay( ro, rd, vos, dir );\n\tif( t>0.0 )\n\t{\n        vec3 nor = -dir*sign(rd);\n        vec3 pos = ro + rd*t;\n        vec3 uvw = pos - vos;\n\t\t\n\t\tvec3 v1  = vos + nor + dir.yzx;\n\t    vec3 v2  = vos + nor - dir.yzx;\n\t    vec3 v3  = vos + nor + dir.zxy;\n\t    vec3 v4  = vos + nor - dir.zxy;\n\t\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\n        vec3 v6  = vos + nor - dir.yzx + dir.zxy;\n\t    vec3 v7  = vos + nor - dir.yzx - dir.zxy;\n\t    vec3 v8  = vos + nor + dir.yzx - dir.zxy;\n\t    vec3 v9  = vos + dir.yzx;\n\t    vec3 v10 = vos - dir.yzx;\n\t    vec3 v11 = vos + dir.zxy;\n\t    vec3 v12 = vos - dir.zxy;\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\n\n\t\tvec4 vc = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\n\t    vec4 vd = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\n\t    vec4 va = vec4( map(v9),  map(v10), map(v11), map(v12) );\n\t    vec4 vb = vec4( map(v13), map(v14), map(v15), map(v16) );\n\t\t\n\t\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\t\n        // wireframe\n        float www = 1.0 - isEdge( uv, va, vb, vc, vd );\n        \n        vec3 wir = smoothstep( 0.4, 0.5, abs(uvw-0.5) );\n        float vvv = (1.0-wir.x*wir.y)*(1.0-wir.x*wir.z)*(1.0-wir.y*wir.z);\n\n        col = vec3(0.5);\n        col += 0.8*vec3(0.1,0.3,0.4);\n        col *= 1.0 - 0.75*(1.0-vvv)*www;\n\t\t\n        // lighting\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n        float sky = 0.5 + 0.5*nor.y;\n        float amb = clamp(0.75 + pos.y/25.0,0.0,1.0);\n        float occ = 1.0;\n\t\n        // ambient occlusion\n        occ = calcOcc( uv, va, vb, vc, vd );\n        occ = 1.0 - occ/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n        occ *= amb;\n\n        // lighting\n        vec3 lin = vec3(0.0);\n        lin += 2.5*dif*vec3(1.00,0.90,0.70)*(0.5+0.5*occ);\n        lin += 0.5*bac*vec3(0.15,0.10,0.10)*occ;\n        lin += 2.0*sky*vec3(0.40,0.30,0.15)*occ;\n\n        // line glow\t\n        float lineglow = 0.0;\n        lineglow += smoothstep( 0.4, 1.0,     uv.x )*(1.0-va.x*(1.0-vc.x));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.x )*(1.0-va.y*(1.0-vc.y));\n        lineglow += smoothstep( 0.4, 1.0,     uv.y )*(1.0-va.z*(1.0-vc.z));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.y )*(1.0-va.w*(1.0-vc.w));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y*      uv.x )*(1.0-vb.x*(1.0-vd.x));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y* (1.0-uv.x))*(1.0-vb.y*(1.0-vd.y));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-vb.z*(1.0-vd.z));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*     uv.x )*(1.0-vb.w*(1.0-vd.w));\n\t\t\n        vec3 linCol = 2.0*vec3(5.0,0.6,0.0);\n        linCol *= (0.5+0.5*occ)*0.5;\n        lin += 3.0*lineglow*linCol;\n\t\t\n        col = col*lin;\n        col += 8.0*linCol*vec3(1.0,2.0,3.0)*(1.0-www);//*(0.5+1.0*sha);\n        col += 0.1*lineglow*linCol;\n        col *= min(0.1,exp( -0.07*t ));\n\t\n        // blend to black & white\t\t\n        // vec3 col2 = vec3(1.3)*(0.5+0.5*nor.y)*occ*www*(0.9+0.1*vvv)*exp( -0.04*t );;\n        // float mi = sin(-1.57+0.5*iTime);\n        // mi = smoothstep( 0.70, 0.75, mi );\n        // col = mix( col, col2, mi );\n\t}\n\n\t// gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.z<=0.00001 ) mo=vec2(0.0);\n\t\n\tfloat time = 2.0*iTime + 50.0*mo.x;\n    // camera\n\tfloat cr = 0.2*cos(0.1*iTime);\n\tvec3 ro = path( time+0.0, 1.0 );\n\tvec3 ta = path( time+5.0, 1.0 ) - vec3(0.0,6.0,0.0);\n\tgro = ro;\n\n    mat3 cam = setCamera( ro, ta, cr );\n\t\n\t// build ray\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( cam * vec3(p.xy,-2.5) );\n\n    vec3 col = render( ro, rd );\n    \n\t// vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tfloat time = 1.0*iTime;\n\n    float cr = 0.0;\n\tvec3 ro = path( time+0.0, 0.0 ) + vec3(0.0,0.7,0.0);\n\tvec3 ta = path( time+2.5, 0.0 ) + vec3(0.0,0.7,0.0);\n\n    mat3 cam = setCamera( ro, ta, cr );\n\n    vec3 col = render( ro + cam*fragRayOri, cam*fragRayDir );\n    \n    fragColor = vec4( col, 1.0 );\n}"
        },
        "octagrams": {
            "title": "Octagrams",
            "src": "precision highp float;\n\n\nfloat gTime = 0.;\nconst float REPEAT = 5.0;\n\n// 回転行列\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat box(vec3 pos, float scale) {\n\tpos *= scale;\n\tfloat base = sdBox(pos, vec3(.4,.4,.1)) /1.5;\n\tpos.xy *= 5.;\n\tpos.y -= 3.5;\n\tpos.xy *= rot(.75);\n\tfloat result = -base;\n\treturn result;\n}\n\nfloat box_set(vec3 pos, float iTime) {\n\tvec3 pos_origin = pos;\n\tpos = pos_origin;\n\tpos .y += sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box1 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\n\tpos = pos_origin;\n\tpos .y -=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box2 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\n\tpos = pos_origin;\n\tpos .x +=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box3 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\t\n\tpos = pos_origin;\n\tpos .x -=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box4 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\t\n\tpos = pos_origin;\n\tpos.xy *=   rot(.8);\n\tfloat box5 = box(pos,.5) * 6.;\t\n\tpos = pos_origin;\n\tfloat box6 = box(pos,.5) * 6.;\t\n\tfloat result = max(max(max(max(max(box1,box2),box3),box4),box5),box6);\n\treturn result;\n}\n\nfloat map(vec3 pos, float iTime) {\n\tvec3 pos_origin = pos;\n\tfloat box_set1 = box_set(pos, iTime);\n\n\treturn box_set1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 ro = vec3(0., -0.2 ,iTime * 4.);\n\tvec3 ray = normalize(vec3(p, 1.5));\n\tray.xy = ray.xy * rot(sin(iTime * .03) * 5.);\n\tray.yz = ray.yz * rot(sin(iTime * .05) * .2);\n\tfloat t = 0.1;\n\tvec3 col = vec3(0.);\n\tfloat ac = 0.0;\n\n\n\tfor (int i = 0; i < 99; i++){\n\t\tvec3 pos = ro + ray * t;\n\t\tpos = mod(pos-2., 4.) -2.;\n\t\tgTime = iTime -float(i) * 0.01;\n\t\t\n\t\tfloat d = map(pos, iTime);\n\n\t\td = max(abs(d), 0.01);\n\t\tac += exp(-d*23.);\n\n\t\tt += d* 0.55;\n\t}\n\n\tcol = vec3(ac * 0.02);\n\n\tcol +=vec3(0.,0.2 * abs(sin(iTime)),0.5 + sin(iTime) * 0.2);\n\n\n\tfragColor = vec4(col ,1.0 - t * (0.02 + 0.02 * sin (iTime)));\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Octgrams\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/"
        },
        "phantomStar": {
            "title": "Phantom Star",
            "src": "precision highp float;\n\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.0;\n\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) + pi/r;\n    float n = pi2 / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\nfloat box( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat ifsBox(vec3 p) {\n    for (int i=0; i<5; i++) {\n        p = abs(p) - 1.0;\n        p.xy *= rot(iTime*0.3);\n        p.xz *= rot(iTime*0.1);\n    }\n    p.xz *= rot(iTime);\n    return box(p, vec3(0.4,0.8,0.3));\n}\n\nfloat map(vec3 p, vec3 cPos) {\n    vec3 p1 = p;\n    p1.x = mod(p1.x-5., 10.) - 5.;\n    p1.y = mod(p1.y-5., 10.) - 5.;\n    p1.z = mod(p1.z, 16.)-8.;\n    p1.xy = pmod(p1.xy, 5.0);\n    return ifsBox(p1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cPos = vec3(0.0,0.0, -3.0 * iTime);\n    // vec3 cPos = vec3(0.3*sin(iTime*0.8), 0.4*cos(iTime*0.3), -6.0 * iTime);\n    vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 cUp  = vec3(sin(iTime), 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);\n\n    // Phantom Mode https://www.shadertoy.com/view/MtScWW by aiekick\n    float acc = 0.0;\n    float acc2 = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 99; i++) {\n        vec3 pos = cPos + ray * t;\n        float dist = map(pos, cPos);\n        dist = max(abs(dist), 0.02);\n        float a = exp(-dist*3.0);\n        if (mod(length(pos)+24.0*iTime, 30.0) < 3.0) {\n            a *= 2.0;\n            acc2 += a;\n        }\n        acc += a;\n        t += dist * 0.5;\n    }\n\n    vec3 col = vec3(acc * 0.01, acc * 0.011 + acc2*0.002, acc * 0.012+ acc2*0.005);\n    fragColor = vec4(col, 1.0 - t * 0.03);\n}"
        },
        "baseWarp": {
            "title": "Base Warp",
            "src": "// https://www.shadertoy.com/view/tdG3Rd\n\nfloat colormap_red(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 20049.0 / 82979.0) {\n        return 0.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;\n    } else if (x <= 1.0) {\n        return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 7249.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return 127.0 / 255.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nvec4 colormap(float x) {\n    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);\n}\n\n// https://iquilezles.org/articles/warp\n/*float noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}*/\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p + iTime  ); p = mtx*p*2.02;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.015625*noise( p + sin(iTime) );\n\n    return f/0.96875;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p + fbm( p ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n\tfloat shade = pattern(uv);\n    fragColor = vec4(colormap(shade).rgb, shade);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Base warp fBM\",\n\t\"description\": \"Noise but Pink\",\n\t\"model\": \"person\"\n}\n*/"
        },
        "sdfs": {
            "title": "SDFS",
            "src": "// https://www.shadertoy.com/view/lfcSWj\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)), 0.0);\n}\n\nfloat smin(float a, float b, float k){\n    float h = max( k-abs(a-b), 0.0)/k;\n    return min( a,b ) - h*h*h*k*(1.0/6.0);\n}\n\nvec3 rot3D(vec3 p, vec3 axis, float angle){\n    return mix(dot(axis,p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\nmat2 rot2D(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat map(vec3 p){\n    p.z += iTime * .4;\n    p = fract(p) - .5;\n    \n    float box = sdBox(p, vec3(.1));\n\n    \n    return box;\n}\n\nvec3 pallet(float t){\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + b*cos(6.28318*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord * 2. - iResolution.xy)/iResolution.y;\n    vec2 mouse =(iMouse.xy *2. - iResolution.xy)/iResolution.y * 3.;\n    vec3 col  = vec3(0.);\n    \n    vec3 ro = vec3(uv, -3.0);\n    vec3 rd = normalize(vec3(uv * 1.1,1.0));\n    float t = 0.; \n    \n    ro.xz *= rot2D(-iTime);\n    //rd.xz *= rot2D(-mouse.x);\n    \n   ro.yz *= rot2D(-iTime);\n    //rd.yz *= rot2D(-mouse.y);\n    for(int i = 0; i < 80; i++){\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        t += d;\n        if(d < 0.01 || t > 100.)break;\n    }\n    col = pallet(t*(0.75));\n    \n    fragColor = vec4(col, 1.);\n}"
        },
        "randomSin": {
            "title": "Random Sin",
            "src": "// https://www.shadertoy.com/view/lfdSDX\n\n#define PI 3.14\n\nvec3 bgColorDown = vec3(0.2, 0.1, 0.1);\nvec3 bgColorUp = vec3(0.1, 0.1, 0.2);\n\nvec3 P1ColorIn = vec3(1.0, 0.5, 0.0);\nvec3 P1ColorOut = vec3(1.0, 0.0, 0.0);\n\nvec3 P2ColorIn = vec3(0.0, 0.5, 1.0);  //vec3(1.0, 1.0, 1.0);\nvec3 P2ColorOut = vec3(0.0, 0.0, 1.0); //vec3(0.0, 0.5, 1.0);\nfloat surfaceSpeed = 0.5;\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n\tfloat bg = (cos(uv.x*3.14159*2.0) + sin((uv.y)*3.14159)) * 0.15;\n\t\n\tvec2 p = uv*2.0 - 1.0;\n\tp *= 15.0;\n\tvec2 sfunc = vec2(p.x, p.y + 5.0*sin(uv.x*10.0-iTime*2.0)+2.0*cos(uv.x*25.0+iTime*12.0));\n\tsfunc.y *= uv.x*2.0+0.05;\n\tsfunc.y *= 2.0 - uv.x*2.0+0.05;\n\tsfunc.y /= 0.1; // Thickness fix\n\t\n\tvec3 c = vec3(sfunc.y);\n\n\tfragColor = vec4(c,1.0);\n}"
        },
        "diveToCloud": {
            "title": "Dive to Cloud",
            "src": "// https://www.shadertoy.com/view/ll3SWl\n// referred https://www.shadertoy.com/view/4sXGRM\n\nvec3 skytop = vec3(0.05, 0.2, 0.5);\n\nvec3 light = normalize(vec3(0.1, 0.25, 0.9));\n\nvec2 cloudrange = vec2(0.0, 10000.0);\n\nmat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\n// hash function              \nfloat hash(float n)\n{\n    return fract(cos(n) * 114514.1919);\n}\n\n// 3d noise function\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = smoothstep(0.0, 1.0, fract(x));\n        \n    float n = p.x + p.y * 10.0 + p.z * 100.0;\n    \n    return mix(\n        mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n            mix(hash(n + 10.0), hash(n + 11.0), f.x), f.y),\n        mix(mix(hash(n + 100.0), hash(n + 101.0), f.x),\n            mix(hash(n + 110.0), hash(n + 111.0), f.x), f.y), f.z);\n}\n\n// Fractional Brownian motion\nfloat fbm(vec3 p)\n{\n    float f = 0.5000 * noise(p);\n    p = m * p;\n    f += 0.2500 * noise(p);\n    p = m * p;\n    f += 0.1666 * noise(p);\n    p = m * p;\n    f += 0.0834 * noise(p);\n    return f;\n}\n\nvec3 camera(float time)\n{\n    return vec3(5000.0 * sin(1.0 * time), 5000. + 1500. * sin(0.5 * time), 6000.0 * time);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float time = (iTime + 13.5 + 44.) * 1.0;\n    vec3 campos = camera(time);\n    vec3 camtar = camera(time + 0.4);\n\n    vec3 front = normalize(camtar - campos);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    vec3 fragAt = normalize(uv.x * right + uv.y * up + front);\n    \n    // clouds\n    vec4 sum = vec4(0, 0, 0, 0);\n    for (float depth = 0.0; depth < 100000.0; depth += 200.0)\n    {\n        vec3 ray = campos + fragAt * depth;\n        if (cloudrange.x < ray.y && ray.y < cloudrange.y)\n        {\n            float alpha = smoothstep(0.5, 1.0, fbm(ray * 0.00025));\n            vec3 localcolor = mix(vec3(1.1, 1.05, 1.0), vec3(0.3, 0.3, 0.2), alpha);\n            alpha = (1.0 - sum.a) * alpha;\n            sum += vec4(localcolor * alpha, alpha);\n        }\n    }\n    \n    float alpha = smoothstep(0.7, 1.0, sum.a);\n    sum.rgb /= sum.a + 0.0001;\n\n    float sundot = clamp(dot(fragAt, light), 0.0, 1.0);\n    vec3 col = 0.8 * (skytop);\n    col += 0.47 * vec3(1.6, 1.4, 1.0) * pow(sundot, 350.0);\n    col += 0.4 * vec3(0.8, 0.9, 1.0) * pow(sundot, 2.0);\n    \n    sum.rgb -= 0.6 * vec3(0.8, 0.75, 0.7) * pow(sundot, 13.0) * alpha;\n    \n    sum.rgb += 0.2 * vec3(1.3, 1.2, 1.0) * pow(sundot, 5.0) * (1.0 - alpha);\n\n    col = mix(col, sum.rgb, sum.a);\n\n    fragColor = vec4(col, 1.0);\n}"
        },
        "proteanClouds": {
            "title": "Protean Clouds",
            "src": "// https://www.shadertoy.com/view/3l23Rh\n\n// Protean clouds by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/3l23Rh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tTechnical details:\n\n\tThe main volume noise is generated from a deformed periodic grid, which can produce\n\ta large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple\n\tfetches of volume gradient computation for improved lighting.\n\n\tTo further accelerate marching, since the volume is smooth, more than half the the density\n\tinformation isn't used to rendering or shading but only as an underlying volume\tdistance to \n\tdetermine dynamic step size, by carefully selecting an equation\t(polynomial for speed) to \n\tstep as a function of overall density (not necessarily rendered) the visual results can be \n\tthe\tsame as a naive implementation with ~40% increase in rendering performance.\n\n\tSince the dynamic marching step size is even less uniform due to steps not being rendered at all\n\tthe fog is evaluated as the difference of the fog integral at each rendered step.\n\n*/\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*0.09);\n    float cl = mag2(p2.xy);\n    float d = 0.;\n    p *= .61;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + iTime*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 1.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n    return vec2(d + cl*.2 + 0.25, cl);\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n    const float ldst = 8.;\n\tvec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);\n\tfloat t = 1.5;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*1.12;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*2.3;\n            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n\n//from my \"Will it blend\" shader (https://www.shadertoy.com/view/lsdGzN)\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    bsMo = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*3.;\n    vec3 ro = vec3(0,0,time);\n    \n    ro += vec3(sin(iTime)*0.5,sin(iTime*1.)*0.,0);\n        \n    float dspAmp = .85;\n    ro.xy += disp(ro.z)*dspAmp;\n    float tgtDst = 3.5;\n    \n    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));\n    ro.x -= bsMo.x*2.;\n    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    rd.xy *= rot(-disp(time + 3.5).x*0.2 + bsMo.x);\n    prm1 = smoothstep(-0.4, 0.4,sin(iTime*0.3));\n\tvec4 scn = render(ro, rd, time);\n\t\t\n    vec3 col = scn.rgb;\n    col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.05,1.));\n    \n    col = pow(col, vec3(.55,0.65,0.6))*vec3(1.,.97,.9);\n\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n\tfragColor = vec4( col, 1.0 );\n}"
        },
        "sincos3d": {
            "title": "sincos 3d",
            "src": "// https://www.shadertoy.com/view/XfXGz4\n\n#define A(v) mat2(cos(m.v+radians(vec4(0, -90, 90, 0))))  // rotate\n#define W(v) length(vec3(p.yz-v(p.x+vec2(0, pi_2)+t), 0))-lt  // wave\n//#define W(v) length(p-vec3(round(p.x*pi)/pi, v(t+p.x), v(t+pi_2+p.x)))-lt  // wave\n#define P(v) length(p-vec3(0, v(t), v(t+pi_2)))-pt  // point\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float lt = .1, // line thickness\n          pt = .3, // point thickness\n          pi = 3.1416,\n          pi2 = pi*2.,\n          pi_2 = pi/2.,\n          t = iTime*pi,\n          s = 1., d = 0., i = d;\n    vec2 R = iResolution.xy,\n         m = (iMouse.xy-.5*R)/R.y*4.;\n    vec3 o = vec3(0, 0, -7), // cam\n         u = normalize(vec3((U-.5*R)/R.y, 1)),\n         c = vec3(0), k = c, p;\n    if (iMouse.z < 1.) m = -vec2(t/20.-pi_2, 0);\n    mat2 v = A(y), h = A(x); // pitch & yaw\n    for (; i++<50.;) // raymarch\n    {\n        p = o+u*d;\n        p.yz *= v;\n        p.xz *= h;\n        p.x -= 3.;\n        if (p.y < -1.5) p.y = 2./p.y;\n        k.x = min( max(p.x+lt, W(sin)), P(sin) );\n        k.y = min( max(p.x+lt, W(cos)), P(cos) );\n        s = min(s, min(k.x, k.y));\n        if (s < .001 || d > 100.) break;\n        d += s*.5;\n    }\n    c = max(cos(d*pi2) - s*sqrt(d) - k, 0.);\n    c.gb += .1;\n    C = vec4(c*.4 + c.brg*.6 + c*c, 1);\n}"
        },
        "midCentruy": {
            "title": "MidCentruy",
            "src": "// https://www.shadertoy.com/view/mtyGWy\n\n/* This animation is the material of my first youtube tutorial about creative \n   coding, which is a video in which I try to introduce programmers to GLSL \n   and to the wonderful world of shaders, while also trying to share my recent \n   passion for this community.\n                                       Video URL: https://youtu.be/f4s1h2YETNY\n*/\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//https://www.shadertoy.com/view/mtyGWy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}"
        },
        "fractalTrees": {
            "title": "Fractal Trees",
            "src": "// https://www.shadertoy.com/view/llXfRr\n\n#define MAXDIST 50.\n\nstruct Ray {\n\tvec3 ro;\n    vec3 rd;\n};\n  \n// from netgrind\nvec3 hue(vec3 color, float shift) {\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\n// ------\n\n// by iq\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat length6( vec3 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/6.0 );\n}\n\n// ------\n\n// from hg_sdf \n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// -------\n\n\nfloat fractal(vec3 p)\n{\n    const int iterations = 20;\n\t\n    float d = iTime*5. - p.z;\n   \tp=p.yxz;\n    pR(p.yz, 1.570795);\n    p.x += 6.5;\n\n    p.yz = mod(abs(p.yz)-.0, 20.) - 10.;\n    float scale = 1.25;\n    \n    p.xy /= (1.+d*d*0.0005);\n    \n\tfloat l = 0.;\n\t\n    for (int i=0; i<iterations; i++) {\n\t\tp.xy = abs(p.xy);\n\t\tp = p*scale + vec3(-3. + d*0.0095,-1.5,-.5);\n        \n\t\tpR(p.xy,0.35-d*0.015);\n\t\tpR(p.yz,0.5+d*0.02);\n\t\t\n        l =length6(p);\n\t}\n\treturn l*pow(scale, -float(iterations))-.15;\n}\n\nvec2 map(vec3 pos) \n{\n    float dist = 10.; \n    dist = opU(dist, fractal(pos));\n    dist = smin(dist, fPlane(pos,vec3(0.0,1.0,0.0),10.), 4.6);\n    return vec2(dist, 0.);\n}\n\nvec3 vmarch(Ray ray, float dist)\n{   \n    vec3 p = ray.ro;\n    vec2 r = vec2(0.);\n    vec3 sum = vec3(0);\n    vec3 c = hue(vec3(0.,0.,1.),5.5);\n    for( int i=0; i<20; i++ )\n    {\n        r = map(p);\n        if (r.x > .01) break;\n        p += ray.rd*.015;\n        vec3 col = c;\n        col.rgb *= smoothstep(.0,0.15,-r.x);\n        sum += abs(col)*.5;\n    }\n    return sum;\n}\n\nvec2 march(Ray ray) \n{\n    const int steps = 50;\n    const float prec = 0.001;\n    vec2 res = vec2(0.);\n    \n    for (int i = 0; i < steps; i++) \n    {        \n        vec2 s = map(ray.ro + ray.rd * res.x);\n        \n        if (res.x > MAXDIST || s.x < prec) \n        {\n        \tbreak;    \n        }\n        \n        res.x += s.x;\n        res.y = s.y;\n        \n    }\n   \n    return res;\n}\n\nvec3 calcNormal(vec3 pos) \n{\n\tconst vec3 eps = vec3(0.005, 0.0, 0.0);\n                          \n    return normalize(\n        vec3(map(pos + eps).x - map(pos - eps).x,\n             map(pos + eps.yxz).x - map(pos - eps.yxz).x,\n             map(pos + eps.yzx).x - map(pos - eps.yzx).x ) \n    );\n}\n\nvec4 render(Ray ray) \n{\n    vec3 col = vec3(0.);\n\tvec2 res = march(ray);\n   \n    if (res.x > MAXDIST) \n    {\n        return vec4(col, 50.);\n    }\n    \n    vec3 pos = ray.ro+res.x*ray.rd;\n    ray.ro = pos;\n   \tcol = vmarch(ray, res.x);\n    \n    col = mix(col, vec3(0.), clamp(res.x/50., 0., 1.));\n   \treturn vec4(col, res.x);\n}\n\nmat3 camera(in vec3 ro, in vec3 rd, float rot) \n{\n\tvec3 forward = normalize(rd - ro);\n    vec3 worldUp = vec3(sin(rot), cos(rot), 0.0);\n    vec3 x = normalize(cross(forward, worldUp));\n    vec3 y = normalize(cross(x, forward));\n    return mat3(x, y, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y -= uv.x*uv.x*0.15;\n    vec3 camPos = vec3(3., -1.5, iTime*5.);\n    vec3 camDir = camPos+vec3(-1.25,0.1, 1.);\n    mat3 cam = camera(camPos, camDir, 0.);\n    vec3 rayDir = cam * normalize( vec3(uv, .8));\n    \n    Ray ray;\n    ray.ro = camPos;\n    ray.rd = rayDir;\n    \n    vec4 col = render(ray);\n    \n\tfragColor = vec4(1.-col.xyz,clamp(1.-col.w/MAXDIST, 0., 1.));\n\tfragColor.a = 1.;\n\tfragColor.g -= fragColor.r;\n\tfragColor.r = 0.;\n\tfragColor.b = 0.;\n}"
        },
        "monitorsAndFractalLife": {
            "title": "monitors and fractal_life",
            "src": "// https://www.shadertoy.com/view/lfKSR1\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define time iTime\n#define resolution iResolution.xy\nfloat tanh2(float x) {\n    float ex = exp(2.0 * x);\n    return ((ex - 1.) / (ex + 1.));\n}\n\nvec2 tanh2(vec2 x) {\n    vec2 ex = exp(2.0 * x);\n    return ((ex - 1.) / (ex + 1.));\n}\n\n// --------[ Original ShaderToy begins here ]---------- //\n#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\nvec4 se(vec2 p) {\n//\tp.x += time*0.3;\n//\tp.y += sin(time*0.3);\n\tp = mod(p + 1.0, 2.0) - 1.0;\n\t\n\tfloat s = 100000.0;\n\tfloat c = 100000.0;\n\tfloat t=sin(time*0.2);\n\tfor(int i = 0; i < 9; i++) {\n\t\tp = abs(p)/clamp(dot(p, p), t, t+2.0) - vec2(0.5, 0.3);\n\t\ts = min(s, length(p));\n\t\tc = min(c, abs(p.y));\n\t}\n\t\n\tvec3 col = mix(vec3(0, 1, 1), vec3(0.1, 0.5, 1.0), smoothstep(0.0, 0.1, s));\n\tcol = mix(col, vec3(1.2, 1.0, 0.4), smoothstep(0.0, 1.0, c));\n\t\n\treturn vec4(col, s);\n}\n\nvec3 normal(vec2 p) {\n\tvec2 h = vec2(0.006, 0.0);\n\t\n\tvec3 n = vec3(\n\t\tse(p + h.xy).w - se(p - h.xy).w,\n\t\tse(p + h.yx).w - se(p - h.yx).w,\n\t\t-0.04);\n\t\n\treturn normalize(n);\n}\n\nvec3 render(vec2 p) {\n\tvec3 nor = normal(p);\n\tvec3 rd = normalize(vec3(p, 1.0));\n\n\t\n\tvec3 col = vec3(dot(nor, -rd));\n\tcol += clamp(pow(dot(nor, -rd), 32.0), 0.0, 1.0);\n//\tcol += 0.5*clamp(pow(1.0 + dot(rd, nor), 1.0), 0.0, 1.0);\n\tcol *= se(p).xyz;\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n vec2 uv = fragCoord/iResolution.xy-0.5;\n\tvec2 p = uv;\n\t vec2 uv2 = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv2.y += -0.2 * cos(0.2 * iTime);\n    uv2.x += -0.2 * sin(0.2 * iTime);\n    float a = atan(uv2.y, uv2.x);\n    float r = length(uv2);\n\n    float sc = 12. + 1. * cos(10. * uv.x + iTime);\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float v = h21(ipos);\n    float t = 11. * v + iTime;\n    vec2 p2 = cos(t) * 0.2 * vec2(cos(2. * v * t), sin(2. * (1.-v) * t));\n    float d = mlength(fpos - p2);\n    float k = 0.5 + 0.4 * cos(t);\n    float s = smoothstep(-k,k, 0.25 + 0.25 * thc(4., 20. * v + iTime) - d);\n    s *= 2. * s;\n    vec3 col = step(d, 0.45) * pal(1. * mlength(uv) + 0.08 * fract(s + atan(fpos.y, fpos.x)/pi + t) - 0.2 * t, vec3(0.6), vec3(0.6), vec3(1.), 0.22 * (1. + cos(ceil(4. * v) * s + t)) * vec3(0.,0.33,0.66));\n    \n   \n\t\n\tvec3 col2 = render(p);\n\t\n\n\tcol2 = pow(abs(col2*col), vec3(1.2));\n\tfragColor = vec4(col2, 1);\n}"
        },
        "raymarchingBasic": {
            "title": "Raymarching Basic",
            "src": "// https://www.shadertoy.com/view/Ml2XRD\n\nfloat map(vec3 p) {\n\tvec3 n = vec3(0, 1, 0);\n\tfloat k1 = 1.9;\n\tfloat k2 = (sin(p.x * k1) + sin(p.z * k1)) * 0.8;\n\tfloat k3 = (sin(p.y * k1) + sin(p.z * k1)) * 0.8;\n\tfloat w1 = 4.0 - dot(abs(p), normalize(n)) + k2;\n\tfloat w2 = 4.0 - dot(abs(p), normalize(n.yzx)) + k3;\n\tfloat s1 = length(mod(p.xy + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.5), 2.0) - 1.0) - 0.2;\n\tfloat s2 = length(mod(0.5+p.yz + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.3), 2.0) - 1.0) - 0.2;\n\treturn min(w1, min(w2, min(s1, s2)));\n}\n\nvec2 rot(vec2 p, float a) {\n\treturn vec2(\n\t\tp.x * cos(a) - p.y * sin(a),\n\t\tp.x * sin(a) + p.y * cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime;\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\tuv.x *= iResolution.x /  iResolution.y;\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\tdir.xz = rot(dir.xz, time * 0.23);dir = dir.yzx;\n\tdir.xz = rot(dir.xz, time * 0.2);dir = dir.yzx;\n\tvec3 pos = vec3(0, 0, time);\n\tvec3 col = vec3(0.0);\n\tfloat t = 0.0;\n    float tt = 0.0;\n\tfor(int i = 0 ; i < 100; i++) {\n\t\ttt = map(pos + dir * t);\n\t\tif(tt < 0.001) break;\n\t\tt += tt * 0.45;\n\t}\n\tvec3 ip = pos + dir * t;\n\tcol = vec3(t * 0.1);\n\tcol = sqrt(col);\n\tfragColor = vec4(0.05*t+abs(dir) * col + max(0.0, map(ip - 0.1) - tt), 1.0); //Thanks! Shane!\n    fragColor.a = 1.0 / (t * t * t * t);\n}"
        },
        "discoteq2": {
            "title": "Discoteq 2",
            "src": "// https://www.shadertoy.com/view/DtXfDr\n\n#define S smoothstep\n\nvec4 Line(vec2 uv, float speed, float height, vec3 col) {\n    uv.y += S(1., 0., abs(uv.x)) * sin(iTime * speed + uv.x * height) * .2;\n    return vec4(S(.06 * S(.2, .9, abs(uv.x)), 0., abs(uv.y) - .004) * col, 1.0) * S(1., .3, abs(uv.x));\n}\n\nvoid mainImage(out vec4 O, in vec2 I) {\n    vec2 uv = (I - .5 * iResolution.xy) / iResolution.y;\n    O = vec4 (0.);\n    for (float i = 0.; i <= 5.; i += 1.) {\n        float t = i / 5.;\n        O += Line(uv, 1. + t, 4. + t, vec3(.2 + t * .7, .2 + t * .4, 0.3));\n    }\n}"
        },
        "devilGlass": {
            "title": "Devil Glass",
            "src": "// https://www.shadertoy.com/view/lcV3Rz\n\n// alternative version of my shader from Revision24 showdown final\n// original version:\n// https://livecode.demozoo.org/event/2024_03_29_shader_showdown_revision_2024.html\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat gyroid (vec3 p) { return dot(cos(p),sin(p.yzx)); }\nfloat fbm(vec3 p)\n{\n  float result = 0.;\n  float a = .5;\n  for (float i = 0.; i < 3.; ++i)\n  {\n    p += result;\n    p.z += iTime*.2;\n    result += abs(gyroid(p/a)*a);\n    a /= 2.;\n  }\n  return result;\n}\n\nfloat map(vec3 p)\n{\n  float dist = 100.;\n  \n  p.xz *= rot(iTime * .2);\n  p.xy *= rot(iTime * .1);\n  vec3 q = p;\n  \n  p = abs(p)-1.3;\n  dist = max(p.x, max(p.y, p.z));\n  dist -= fbm(q)*.2;\n  dist = abs(dist)-.03;\n  \n  return dist * .5;\n}\n\nvec3 getResult(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 color = vec3(smoothstep(1., -1., length(uv)));\n    \n    vec3 pos = vec3(0,0,7);\n    vec3 ray = normalize(vec3(uv, -1.5));\n    float total = 0.;\n    float shade = 0.;\n    for (float i = 100.; i > 0.; --i)\n    {\n        float dist = map(pos);\n        if (dist < .001)\n        {\n            shade += 0.1;\n            dist = 0.002;\n        }\n        if (total > 10.) return color;\n        total += dist;\n        pos += ray * dist;\n    }\n\n    if (total < 10.)\n    {\n        color = 0.5 + 0.5 * cos(vec3(1,2,3)*5.5+shade);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(getResult(fragCoord),1.0);\n}"
        },
        "ripple": {
            "title": "Ripple",
            "src": "uniform float time;\nuniform float rippleAmount; // @type float\n\n// @return uv-coordinate\n// @param uvIn uv-coordinate\nvec2 main(vec2 uvIn) {\n  vec2 p = -1.0 + 2.0 * uvIn;\n  float len = length(p);\n  return uvIn + (p/len)*sin(len*12.0-time*4.0)*0.1 * rippleAmount;\n}"
        },
        "sparklez": {
            "title": "Sparklez™",
            "src": "uniform float sparkleIntensity; // @@Slider default=.2 min=0 max=1\nuniform float sparkleBrightness; // @@Slider default=5 min=0 max=10\n//Based on https://www.youtube.com/watch?v=3CycKKJiwis\n\nfloat random(vec2 par){\n    return fract(sin(dot(par.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 random2(vec2 par){\n    float rand = random(par);\n    return vec2(rand, random(par+rand));\n}\n\n// @param fragCoord uv-coordinate\n// @return color\nvec4 upstreamColor(vec2 fragCoord);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //The ratio of the width and height of the screen\n    float widthHeightRatio = iResolution.x/iResolution.y;\n\n    float t = iTime * 0.01;\n    float dist = 0.0;\n    float layers = 16.0;\n    float scale = 32.0;\n    float depth;\n    float phase;\n    float rotationAngle = iTime * -0.01;\n\n    vec2 offset;\n    vec2 local_uv;\n    vec2 index;\n    vec2 pos;\n    vec2 seed;\n    vec2 centre = vec2(0.5, 0.5);\n\n    mat2 rotation = mat2(cos(rotationAngle), -sin(rotationAngle),\n    sin(rotationAngle),  cos(rotationAngle));\n\n    for(float i = 0.0; i < layers; i++){\n        depth = fract(i/layers + t);\n\n        //Move centre in a circle depending on the depth of the layer\n        centre.x = 0.5 + 0.1 * cos(t) * depth;\n        centre.y = 0.5 + 0.1 * sin(t) * depth;\n\n        //Get uv from the fragment coordinates, rotation and depth\n        uv = centre-fragCoord/iResolution.xy;\n        uv.y /= widthHeightRatio;\n        uv *= rotation;\n        uv *= mix(scale, 0.0, depth);\n\n        //The local cell\n        index = floor(uv);\n\n        //Local cell seed;\n        seed = 20.0 * i + index;\n\n        //The local cell coordinates\n        local_uv = fract(i + uv) - 0.5;\n\n        //Get a random position for the local cell\n        pos = 1.8 * (random2(seed) - 0.5);\n\n        //Get a random phase\n        phase = 128.0 * random(seed);\n\n        //Get distance to the generated point, add fading to distant points\n        //Add the distance to the sum\n        dist += pow(abs(1.0-length(local_uv-pos)), 50.0 + 20.0 * sin(phase + 8.0 * iTime))\n        * min(1.0, depth*2.0) * sparkleIntensity;\n\n    }\n    fragColor = upstreamColor(fragCoord) + vec4(vec3(dist),1.0) * sparkleBrightness;\n}"
        },
        "heart": {
            "title": "Heart",
            "src": "// Heart\n// From http://mathworld.wolfram.com/HeartSurface.html\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\n\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n// @param fragCoord uv-coordinate\n// @return color\nvec4 upstreamColor(vec2 fragCoord);\n\nfloat f(vec3 p) {\n    vec3 pp = p * p;\n    vec3 ppp = pp * p;\n    float a = pp.x + 2.25 * pp.y + pp.z - 1.0;\n    return a * a * a - (pp.x + 0.1125 * pp.y) * ppp.z;\n}\n\n// Bisection solver for y\nfloat h(float x, float z) {\n    float a = 0.0, b = 0.75, y = 0.5;\n    for (int i = 0; i < 10; i++) {\n        if (f(vec3(x, y, z)) <= 0.0)\n        a = y;\n        else\n        b = y;\n        y = (a + b) * 0.5;\n    }\n    return y;\n}\n\n// Analytical gradient\n// (-2 x z^3+6 x (-1.+x^2+2.25 y^2+z^2)^2)\n// (-0.225 y z^3+13.5 y (-1.+x^2+2.25 y^2+z^2)^2)\n// (z (-3 x^2 z-0.3375 y^2 z+6 (-1.+x^2+2.25 y^2+z^2)^2))\nvec3 normal(vec2 p) {\n    vec3 v = vec3(p.x, h(p.x, p.y), p.y);\n    vec3 vv = v * v;\n    vec3 vvv = vv * v;\n    float a = -1.0 + dot(vv, vec3(1, 2.25, 1));\n    a *= a;\n\n    return normalize(vec3(\n    -2.0 * v.x * vvv.z +  6.0 * v.x * a,\n    -0.225 * v.y * vvv.z + 13.5 * v.y * a,\n    v.z * (-3.0 * vv.x * v.z - 0.3375 * vv.y * v.z + 6.0 * a)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 p = (vec3((2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x), 0)) * 2.;\n    float beat = beatInfo.beat;\n    float s = sin(beat * 4.0);\n    s *= s;\n    s *= s;\n    s *= s;\n    s *= s;\n    s *= 0.1;\n    vec3 tp = p * vec3(1.0 + s, 1.0 - s, 0.0) * 2.0;\n\n    if (f(tp.xzy) <= 0.0) {\n        vec3 n = normal(tp.xy);\n        float diffuse = dot(n, normalize(vec3(-1, 1, 1))) * 0.5 + 0.5;\n        float specular = pow(max(dot(n, normalize(vec3(-1, 2, 1))), 0.0), 64.0);\n        float rim = 0.; //1.0 - dot(n, vec3(0.0, 1.0, 0.0));\n        fragColor = vec4(diffuse * vec3(1.0, 0, 0) + specular * vec3(0.8) + rim * vec3(0.5), 1.);\n    }\n    else\n    fragColor = upstreamColor(fragCoord);\n}"
        },
        "thatSAllFolks": {
            "title": "That's all, folks!",
            "src": "// That's All Folks\nuniform float time;\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\nuniform float ringSpeed; // @@Slider default=10. min=-10 max=20\nuniform float ringDensity; // @@Slider default=60. min=10 max=120\nuniform float ringFade; // @@Slider default=.5 min=0 max=1\n\n// @param fragCoord uv-coordinate\n// @return color\nvec4 upstreamColor(vec2 fragCoord);\n\n// @return color\n// @param uvIn uv-coordinate\n// @param inColor color\nvec4 main(vec2 uvIn) {\n    vec4 inColor = upstreamColor(uvIn);\n    vec2 p = uvIn - .5;\n    float directMod = sin(time * 0.01);\n    float d = mix(\n        1. - ringFade,\n        1.,\n        sin(-length(p) * ringDensity * (0.8+ beatInfo.intensity * 0.2) + time * ringSpeed)\n    );\n    return vec4(inColor.rgb * d, 1.0);\n}"
        },
        "beatShift": {
            "title": "Beat Shift",
            "src": "// Beat Shift\n// Priority > 1, shader channel \"time\"\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\nuniform float beatTimeShiftAmount; // @@Slider default=.5 min=0 max=2\n\n// @return time\n// @param inTime time\nfloat main(float inTime) {\n    return inTime + beatInfo.intensity * beatTimeShiftAmount;\n}"
        },
        "imageOverlay": {
            "title": "Image Overlay",
            "src": "// Image Overlay\n\nvec4 image(vec2 uv); // @@Image\n\n// @return color\n// @param inColor color\nvec4 main(vec4 inColor) {\n    vec4 i = image(gl_FragCoord);\n    return vec4(mix(inColor.rgb, i.rgb, i.a), 1.0);\n}"
        },
        "zigZag": {
            "title": "Zig Zag",
            "src": "// Zig Zag\n\nuniform float time;\n// uniform float zig; // @type float\nuniform float frequency;// @@Slider default=10. min=0 max=20\nuniform float depth;// @@Slider default=0.1 min=0.0 max=0.2\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\nuniform BeatInfo beatInfo;// @@baaahs.BeatLink:BeatInfo\n\n// @return uv-coordinate\n// @param uvIn uv-coordinate\nvec2 main(vec2 uvIn) {\n    vec2 p = -1.0 + 2.0 * uvIn;\n    float len = p.x / 16.;\n    int y = int(uvIn.y * 10.);\n\n    return vec2(uvIn.x, uvIn.y + sin(uvIn.x * frequency + time * 10.) * depth);\n}"
        },
        "blackout": {
            "title": "Blackout",
            "src": "// @return color\n// @param uvIn uv-coordinate\nvec4 main(vec2 uvIn) {\n    return vec4(0., 0., 0., 1.);\n}"
        },
        "baaahsLogo": {
            "title": "[🐑] BAAAHS Logo",
            "src": "// Basic GLSL construction of the BAAAHS logo -- you can replace primitives in other shaders with this!\n// Ben Bartlett\n\n#define N 5\n#define COORD_SCALE 0.03\n\nuniform float horizontalScale; // @@Slider default=.7 min=0.25 max=1.\n\nuniform vec2 resolution; // @@Resolution\nuniform float time; // @@Time\n\n// @param fragCoord uv-coordinate\n// @return color\nvec4 upstreamColor(vec2 fragCoord);\n\n\n// For reference -- determines if a point is in a polygon. Since you can't pass dynamically sized arrays, we need one for each component :(\nbool pointInPoly(vec2 point, float scale, vec2 offset, vec2 vertices[N]){\n\tint i, j;\n\tbool c = false;\n\tvec2 pt = (point - offset)/scale;\n\tfor (i = 0, j = N-1; i < N; j = i++) {\n\t\tif ( ((vertices[i].y > pt.y) != (vertices[j].y > pt.y)) &&\n\t\t(pt.x < (vertices[j].x-vertices[i].x) * (pt.y-vertices[i].y) / (vertices[j].y-vertices[i].y) + vertices[i].x) )\n\t\tc = !c;\n\t}\n\treturn c;\n}\n\n// Coordiantes were obtained from image processing using Wolfram Mathematica. Contact Ben for the notebook source code.\nvec2 HEART[187] = vec2[187](vec2(-1.408e1,2.96),vec2(-1.39e1,3.56),vec2(-1.326e1,3.86),vec2(-1.37e1,4.4),vec2(-1.36e1,5.08),vec2(-1.322e1,5.4),vec2(-1.268e1,5.46),vec2(-13,5.92),vec2(-1.292e1,6.52),vec2(-1.242e1,6.92),vec2(-1.174e1,6.84),vec2(-1.198e1,7.4),vec2(-1.174e1,7.98),vec2(-1.126e1,8.22),vec2(-1.054e1,8.02),vec2(-1.058e1,8.66),vec2(-1.012e1,9.14),vec2(-9.6,9.18),vec2(-9.1,8.88),vec2(-9.08,9.42),vec2(-8.62,9.86),vec2(-8,9.86),vec2(-7.54,9.42),vec2(-7.4,9.94),vec2(-6.88,1.028e1),vec2(-6.22,1.014e1),vec2(-5.9,9.56),vec2(-5.46,1.01e1),vec2(-4.78,1.014e1),vec2(-4.42,9.88),vec2(-4.22,9.32),vec2(-3.86,9.8),vec2(-3.2,9.88),vec2(-2.74,9.54),vec2(-2.6,8.88),vec2(-2.02,9.24),vec2(-1.38,9.04),vec2(-1.12,8.6),vec2(-1.14,8.06),vec2(-0.52,8.28),vec2(0,8.02),vec2(0.58,8.16),vec2(1.04,7.96),vec2(1,8.5),vec2(1.28,8.96),vec2(1.98,9.14),vec2(2.54,8.78),vec2(2.52,9.3),vec2(2.98,9.8),vec2(3.6,9.82),vec2(4.12,9.3),vec2(4.22,9.72),vec2(4.62,1.008e1),vec2(5.32,1.006e1),vec2(5.78,9.52),vec2(6.1,1.014e1),vec2(6.74,1.028e1),vec2(7.24,9.98),vec2(7.4,9.44),vec2(7.98,9.92),vec2(8.64,9.82),vec2(8.98,9.4),vec2(8.98,8.88),vec2(9.5,9.24),vec2(1.02e1,9.1),vec2(1.052e1,8.58),vec2(1.046e1,8.04),vec2(1.11e1,8.3),vec2(1.166e1,8.04),vec2(1.188e1,7.38),vec2(1.166e1,6.92),vec2(1.236e1,7),vec2(1.284e1,6.62),vec2(1.294e1,6.06),vec2(1.268e1,5.54),vec2(1.326e1,5.48),vec2(1.368e1,4.92),vec2(1.364e1,4.44),vec2(1.326e1,3.98),vec2(1.378e1,3.82),vec2(1.41e1,3.24),vec2(1.394e1,2.66),vec2(1.34e1,2.36),vec2(1.386e1,2.08),vec2(1.408e1,1.62),vec2(1.388e1,0.94),vec2(1.32e1,0.68),vec2(1.36e1,0.16),vec2(1.356e1,-0.42),vec2(1.322e1,-0.8),vec2(1.262e1,-0.92),vec2(1.302e1,-1.38),vec2(1.294e1,-2.06),vec2(1.244e1,-2.44),vec2(1.188e1,-2.38),vec2(1.212e1,-2.92),vec2(1.198e1,-3.46),vec2(1.152e1,-3.8),vec2(1.094e1,-3.74),vec2(1.114e1,-4.44),vec2(1.08e1,-5.02),vec2(1.036e1,-5.18),vec2(9.86,-5.06),vec2(1.006e1,-5.66),vec2(9.84,-6.16),vec2(9.3,-6.42),vec2(8.72,-6.22),vec2(8.82,-6.92),vec2(8.46,-7.42),vec2(7.88,-7.54),vec2(7.48,-7.38),vec2(7.62,-8),vec2(7.34,-8.48),vec2(6.74,-8.68),vec2(6.26,-8.46),vec2(6.36,-9.14),vec2(5.88,-9.7),vec2(5.34,-9.74),vec2(4.94,-9.48),vec2(4.98,-1.016e1),vec2(4.64,-1.058e1),vec2(4.18,-1.072e1),vec2(3.56,-1.046e1),vec2(3.64,-1.102e1),vec2(3.3,-1.152e1),vec2(2.76,-1.166e1),vec2(2.22,-1.14e1),vec2(2.28,-1.198e1),vec2(1.92,-1.248e1),vec2(1.34,-1.26e1),vec2(0.86,-1.232e1),vec2(0.9,-13),vec2(0.74,-1.328e1),vec2(0.28,-1.354e1),vec2(-0.24,-1.35e1),vec2(-0.6,-1.324e1),vec2(-0.76,-1.242e1),vec2(-1.22,-1.266e1),vec2(-1.84,-1.25e1),vec2(-2.14,-1.204e1),vec2(-2.08,-1.146e1),vec2(-2.62,-1.172e1),vec2(-3.24,-1.152e1),vec2(-3.52,-11),vec2(-3.42,-1.052e1),vec2(-3.9,-1.076e1),vec2(-4.54,-1.062e1),vec2(-4.88,-1.006e1),vec2(-4.8,-9.54),vec2(-5.32,-9.82),vec2(-5.94,-9.64),vec2(-6.24,-9.1),vec2(-6.1,-8.5),vec2(-6.54,-8.74),vec2(-7.18,-8.58),vec2(-7.5,-8.02),vec2(-7.38,-7.44),vec2(-7.82,-7.62),vec2(-8.36,-7.48),vec2(-8.72,-6.88),vec2(-8.56,-6.32),vec2(-9.08,-6.5),vec2(-9.56,-6.36),vec2(-9.94,-5.72),vec2(-9.74,-5.14),vec2(-1.034e1,-5.26),vec2(-1.086e1,-4.96),vec2(-1.104e1,-4.34),vec2(-1.082e1,-3.82),vec2(-1.128e1,-3.92),vec2(-1.168e1,-3.76),vec2(-1.202e1,-3.1),vec2(-1.18e1,-2.48),vec2(-1.242e1,-2.54),vec2(-1.294e1,-2.02),vec2(-1.294e1,-1.46),vec2(-1.256e1,-1.04),vec2(-1.314e1,-0.92),vec2(-1.352e1,-0.46),vec2(-1.352e1,8.0e-2),vec2(-1.31e1,0.54),vec2(-1.382e1,0.78),vec2(-1.406e1,1.5),vec2(-1.382e1,1.98),vec2(-1.336e1,2.22),vec2(-1.386e1,2.46),vec2(-1.406e1,2.94));\nvec2 HEART_MIN_XY = vec2(-70.5, -67.9);\nvec2 HEART_MAX_XY = vec2(70.6, 51.6);\nvec2 FACE[26] = vec2[26](vec2(-5.24,2.5),vec2(-5.18,3.56),vec2(-5.04,3.84),vec2(-4.8,3.88),vec2(-3.58,3.3),vec2(-1.88,2.12),vec2(2.16,2.12),vec2(4.02,3.68),vec2(4.78,4.04),vec2(5.18,4.02),vec2(5.38,3.64),vec2(5.44,2.72),vec2(5.12,0),vec2(2.84,-7.52),vec2(2.7,-8.46),vec2(2.36,-9.22),vec2(1.86,-9.8),vec2(1.14,-1.026e1),vec2(0.46,-1.046e1),vec2(-0.36,-1.044e1),vec2(-1.28,-1.008e1),vec2(-1.88,-9.58),vec2(-2.38,-8.8),vec2(-2.64,-7.5),vec2(-4.76,-0.72),vec2(-5.22,2.48));\nvec2 MOUTH[35] = vec2[35](vec2(-1.66,-6.76),vec2(-1.56,-6.52),vec2(-1.3,-6.58),vec2(-0.32,-7.72),vec2(0.2,-7.86),vec2(0.58,-7.68),vec2(1.4,-6.66),vec2(1.62,-6.52),vec2(1.84,-6.58),vec2(1.82,-6.84),vec2(1.52,-6.98),vec2(1.22,-7.28),vec2(0.3,-8.66),vec2(0.3,-9.18),vec2(0.4,-9.28),vec2(1.14,-9.04),vec2(1.66,-8.64),vec2(1.8,-8.68),vec2(1.78,-8.82),vec2(1.44,-9.2),vec2(0.98,-9.52),vec2(0.42,-9.78),vec2(2.0e-2,-9.84),vec2(-0.86,-9.46),vec2(-1.54,-8.82),vec2(-1.56,-8.68),vec2(-1.44,-8.64),vec2(-1,-8.98),vec2(-0.18,-9.28),vec2(-8.0e-2,-9.16),vec2(-8.0e-2,-8.74),vec2(-0.14,-8.5),vec2(-0.8,-7.54),vec2(-1.26,-7.02),vec2(-1.64,-6.76));\nvec2 EYE_LEFT[10] = vec2[10](vec2(-4.6,2.4),vec2(-4.6,2.72),vec2(-4.46,2.98),vec2(-4.14,3.02),vec2(-3.82,2.8),vec2(-3.48,2.14),vec2(-3.54,1.6),vec2(-4,1.6),vec2(-4.26,1.72),vec2(-4.58,2.38));\nvec2 EYE_RIGHT[10] = vec2[10](vec2(3.64,1.8),vec2(3.72,2.34),vec2(4,2.8),vec2(4.32,3.02),vec2(4.68,2.94),vec2(4.78,2.42),vec2(4.48,1.76),vec2(4.2,1.6),vec2(3.7,1.6),vec2(3.66,1.78));\nvec2 EAR_LEFT[9] = vec2[9](vec2(-1.092e1,6.08),vec2(-1.084e1,6.26),vec2(-1.058e1,6.3),vec2(-7.02,6.24),vec2(-6.94,4.48),vec2(-7.14,4.38),vec2(-7.84,4.42),vec2(-1.078e1,5.88),vec2(-1.09e1,6.06));\nvec2 EAR_RIGHT[10] = vec2[10](vec2(7.22,4.48),vec2(7.42,4.38),vec2(8.12,4.42),vec2(1.106e1,5.88),vec2(1.12e1,6.14),vec2(1.112e1,6.26),vec2(1.086e1,6.3),vec2(7.36,6.28),vec2(7.26,6.18),vec2(7.22,4.5));\n\nbool pointInHeart(vec2 point, float scale, vec2 offset){\n\tint len = 187;\n\tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE);\n\tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((HEART[i].y > p.y) != (HEART[j].y > p.y)) && (p.x < (HEART[j].x-HEART[i].x) * (p.y-HEART[i].y) / (HEART[j].y-HEART[i].y) + HEART[i].x) ) c = !c; }\n\treturn c;\n}\nbool pointInFace(vec2 point, float scale, vec2 offset){\n\tint len = 26;\n\tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE);\n\tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((FACE[i].y > p.y) != (FACE[j].y > p.y)) && (p.x < (FACE[j].x-FACE[i].x) * (p.y-FACE[i].y) / (FACE[j].y-FACE[i].y) + FACE[i].x) ) c = !c; }\n\treturn c;\n}\nbool pointInMouth(vec2 point, float scale, vec2 offset){\n\tint len = 35;\n\tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE);\n\tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((MOUTH[i].y > p.y) != (MOUTH[j].y > p.y)) && (p.x < (MOUTH[j].x-MOUTH[i].x) * (p.y-MOUTH[i].y) / (MOUTH[j].y-MOUTH[i].y) + MOUTH[i].x) ) c = !c; }\n\treturn c;\n}\nbool pointInEyeLeft(vec2 point, float scale, vec2 offset){\n\tint len = 10;\n\tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE);\n\tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EYE_LEFT[i].y > p.y) != (EYE_LEFT[j].y > p.y)) && (p.x < (EYE_LEFT[j].x-EYE_LEFT[i].x) * (p.y-EYE_LEFT[i].y) / (EYE_LEFT[j].y-EYE_LEFT[i].y) + EYE_LEFT[i].x) ) c = !c; }\n\treturn c;\n}\nbool pointInEyeRight(vec2 point, float scale, vec2 offset){\n\tint len = 10;\n\tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE);\n\tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EYE_RIGHT[i].y > p.y) != (EYE_RIGHT[j].y > p.y)) && (p.x < (EYE_RIGHT[j].x-EYE_RIGHT[i].x) * (p.y-EYE_RIGHT[i].y) / (EYE_RIGHT[j].y-EYE_RIGHT[i].y) + EYE_RIGHT[i].x) ) c = !c; }\n\treturn c;\n}\nbool pointInEarLeft(vec2 point, float scale, vec2 offset){\n\tint len = 9;\n\tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE);\n\tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EAR_LEFT[i].y > p.y) != (EAR_LEFT[j].y > p.y)) && (p.x < (EAR_LEFT[j].x-EAR_LEFT[i].x) * (p.y-EAR_LEFT[i].y) / (EAR_LEFT[j].y-EAR_LEFT[i].y) + EAR_LEFT[i].x) ) c = !c; }\n\treturn c;\n}\nbool pointInEarRight(vec2 point, float scale, vec2 offset){\n\tint len = 10;\n\tint i, j; bool c = false; vec2 p = (point - offset)/(scale * COORD_SCALE);\n\tfor (i = 0, j = len-1; i < len; j = i++) { if ( ((EAR_RIGHT[i].y > p.y) != (EAR_RIGHT[j].y > p.y)) && (p.x < (EAR_RIGHT[j].x-EAR_RIGHT[i].x) * (p.y-EAR_RIGHT[i].y) / (EAR_RIGHT[j].y-EAR_RIGHT[i].y) + EAR_RIGHT[i].x) ) c = !c; }\n\treturn c;\n}\n\n// Shades only the black regions of the logo\nbool pointInSheep(vec2 point, float scale, vec2 offset) {\n\t// For speed -- check if it's in a bounding box, else return false\n\tvec2 p = (point - offset)/(scale * COORD_SCALE);\n\tif (p.x > HEART_MAX_XY.x || p.y > HEART_MAX_XY.y || p.x < HEART_MIN_XY.x || p.y < HEART_MIN_XY.y) {\n\t\treturn false;\n\t}\n\t// Check if it's in each part\n\tbool inHeart = pointInHeart(point, scale, offset);\n\tbool inFace = pointInFace(point, scale, offset);\n\tbool inMouth = pointInMouth(point, scale, offset);\n\tbool inEyeLeft = pointInEyeLeft(point, scale, offset);\n\tbool inEyeRight = pointInEyeRight(point, scale, offset);\n\tbool inEarLeft = pointInEarLeft(point, scale, offset);\n\tbool inEarRight = pointInEarRight(point, scale, offset);\n\t// Shade the correct regions\n\treturn inHeart && (!(inFace || inEarLeft || inEarRight) || (inMouth || inEyeLeft || inEyeRight));\n}\n\nvec3 drawScene(vec2 uv) {\n\tvec3 col = upstreamColor(uv).rgb;\n\n\tfloat sheep = -1.0 * float(pointInSheep(uv, .9 + 0.1 * sin(time * 2.), vec2(.15 * sin(time * .47), .1 * sin(time * .37))));\n\n\tcol = mix(vec3(0, 0, 0), col, step(0., sheep));\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\tvec2 uv = fragCoord/iResolution.xy; // <0, 1>\n\n\tvec2 fragPos = fragCoord / resolution.xy;\n\tfragPos = (fragPos - 0.5) * 1.5;\n\tfragPos.x *= resolution.x / resolution.y / horizontalScale;\n\t\n//\tuv -= 0.5; // <-0.5,0.5>\n//\tuv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n\tvec3 col = drawScene(fragPos);\n\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}\n\n"
        },
        "static": {
            "title": "Static",
            "src": "// Free for any purpose, commercial or otherwise. \n// But do post here so I can see where it got used!\n// If using on shadertoy, do link to this project on yours :)\n\nfloat noise(vec2 pos, float evolve) {\n    \n    // Loop the evolution (over a very long period of time).\n    float e = fract((evolve*0.01));\n    \n    // Coordinates\n    float cx  = pos.x*e;\n    float cy  = pos.y*e;\n    \n    // Generate a \"random\" black or white value\n    return fract(23.0*fract(2.0/fract(fract(cx*2.4/cy*23.0+pow(abs(cy/22.4),3.3))*fract(cx*evolve/pow(abs(cy),0.050)))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Increase this number to test performance\n    int intensity = 1;\n    \n    vec3 colour;\n    for (int i = 0; i < intensity; i++)\n        {\n        // Generate a black to white pixel\n        colour = vec3(noise(fragCoord,iTime), noise(fragCoord + 1.,iTime + 1.), noise(fragCoord - 2.,iTime + 2.));\n        }\n\t\n    // Output to screen\n    fragColor = vec4(max(vec3(.7), colour),1.0);\n}"
        },
        "rotateTwist": {
            "title": "Rotate & Twist",
            "src": "uniform float rotation; // @@Slider min=-3.14159 max=3.14159 default=0\nuniform float twist; // @@Slider min=-16 max=16 default=0\n\n// @param uvIn uv-coordinate\n// @return uv-coordinate\nvec2 main(vec2 uvIn) {\n    vec2 uv = uvIn - .5;\n    float dist = length(uv) * twist;\n    float theta = rotation + dist;\n    return vec2(\n        cos(theta) * uv.x - sin(theta) * uv.y,\n        sin(theta) * uv.x + cos(theta) * uv.y\n    ) + .5;\n}"
        }
    },
    "patches": {
        "xyProjection-patch": {
            "shaderId": "xyProjection",
            "incomingLinks": {
                "modelInfo": {
                    "type": "feed",
                    "feedId": "modelInfo"
                },
                "pixelLocation": {
                    "type": "feed",
                    "feedId": "pixelLocation"
                }
            }
        },
        "darkness-patch": {
            "shaderId": "darkness",
            "incomingLinks": {
            }
        },
        "hsb-patch": {
            "shaderId": "hsb",
            "incomingLinks": {
                "hueShift": {
                    "type": "feed",
                    "feedId": "hueShiftSlider"
                },
                "brightness": {
                    "type": "feed",
                    "feedId": "brightnessSlider"
                },
                "inColor": {
                    "type": "stream",
                    "stream": "main"
                },
                "saturation": {
                    "type": "feed",
                    "feedId": "saturationSlider"
                }
            },
            "priority": 10
        },
        "squarezzz-patch": {
            "shaderId": "squarezzz",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "speed": {
                    "type": "feed",
                    "feedId": "speedSlider"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "colorPulse-patch": {
            "shaderId": "colorPulse",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "uvIn": {
                    "type": "stream",
                    "stream": "main"
                },
                "hueRange": {
                    "type": "feed",
                    "feedId": "hueRangeSlider"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "fromCenter": {
                    "type": "feed",
                    "feedId": "fromCenterSwitch"
                },
                "pulseSpeed": {
                    "type": "feed",
                    "feedId": "pulseSpeedSlider"
                },
                "center": {
                    "type": "feed",
                    "feedId": "center"
                }
            }
        },
        "geometricColorPulse-patch": {
            "shaderId": "geometricColorPulse",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "uvIn": {
                    "type": "stream",
                    "stream": "main"
                },
                "fixtureInfo": {
                    "type": "feed",
                    "feedId": "fixtureInfo"
                },
                "hueRange": {
                    "type": "feed",
                    "feedId": "hueRangeSlider"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "cycleSpeed": {
                    "type": "feed",
                    "feedId": "cycleSpeedSlider"
                },
                "pulseSpeed": {
                    "type": "feed",
                    "feedId": "pulseSpeedSlider"
                }
            }
        },
        "complexTrippyShit1-patch": {
            "shaderId": "complexTrippyShit1",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "baaahzebra-patch": {
            "shaderId": "baaahzebra",
            "incomingLinks": {
                "uv": {
                    "type": "stream",
                    "stream": "main"
                },
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "speed": {
                    "type": "feed",
                    "feedId": "speedSlider2"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                }
            }
        },
        "orangeSnowflake-patch": {
            "shaderId": "orangeSnowflake",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "speed": {
                    "type": "feed",
                    "feedId": "speedSlider"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "pulsiness": {
                    "type": "feed",
                    "feedId": "pulsinessSlider"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "acidAtTheDisco-patch": {
            "shaderId": "acidAtTheDisco",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "speed": {
                    "type": "feed",
                    "feedId": "speedSlider"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "pulsiness": {
                    "type": "feed",
                    "feedId": "pulsinessSlider"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "picassoSNightmare-patch": {
            "shaderId": "picassoSNightmare",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "mouse": {
                    "type": "stream",
                    "stream": "main"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "plasma-patch": {
            "shaderId": "plasma",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "wobblyColorGrid-patch": {
            "shaderId": "wobblyColorGrid",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "center": {
                    "type": "feed",
                    "feedId": "center"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "gadzooks-patch": {
            "shaderId": "gadzooks",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "mouse": {
                    "type": "stream",
                    "stream": "main"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "gaiaSOrgasm-patch": {
            "shaderId": "gaiaSOrgasm",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "faeriePulse-patch": {
            "shaderId": "faeriePulse",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "yasQueen-patch": {
            "shaderId": "yasQueen",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "mouse": {
                    "type": "stream",
                    "stream": "main"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "geometricSheep-patch": {
            "shaderId": "geometricSheep",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "uvIn": {
                    "type": "stream",
                    "stream": "main"
                },
                "fixtureInfo": {
                    "type": "feed",
                    "feedId": "fixtureInfo"
                },
                "hueSpread": {
                    "type": "feed",
                    "feedId": "hueSpreadSlider"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "cycleSpeed": {
                    "type": "feed",
                    "feedId": "cycleSpeedSlider2"
                }
            }
        },
        "aquaticFlood-patch": {
            "shaderId": "aquaticFlood",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "sm_beat": {
                    "type": "feed",
                    "feedId": "beatLink"
                }
            }
        },
        "circularDependency-patch": {
            "shaderId": "circularDependency",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "redSea-patch": {
            "shaderId": "redSea",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "baaahsEclipse-patch": {
            "shaderId": "baaahsEclipse",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "soundAnalysis": {
                    "type": "feed",
                    "feedId": "soundAnalysis"
                },
                "horizontalScale": {
                    "type": "feed",
                    "feedId": "horizontalScaleSlider"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "midi": {
                    "type": "feed",
                    "feedId": "midi"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "firstRaymarches-patch": {
            "shaderId": "firstRaymarches",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "thing": {
                    "type": "feed",
                    "feedId": "thingSlider"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "fireball-patch": {
            "shaderId": "fireball",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "conflagration": {
                    "type": "feed",
                    "feedId": "conflagrationSlider"
                }
            }
        },
        "blueHearts-patch": {
            "shaderId": "blueHearts",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "blueSClues-patch": {
            "shaderId": "blueSClues",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iMouse": {
                    "type": "stream",
                    "stream": "main"
                }
            }
        },
        "checkerboard-patch": {
            "shaderId": "checkerboard",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "checkerboardSize": {
                    "type": "feed",
                    "feedId": "checkerboardSizeSlider"
                }
            }
        },
        "colorDiffusionFlow-patch": {
            "shaderId": "colorDiffusionFlow",
            "incomingLinks": {
                "DATE": {
                    "type": "feed",
                    "feedId": "date"
                },
                "TIME": {
                    "type": "feed",
                    "feedId": "time"
                },
                "nudge": {
                    "type": "feed",
                    "feedId": "nudgeSlider"
                },
                "rate1": {
                    "type": "feed",
                    "feedId": "rate1Slider"
                },
                "rate2": {
                    "type": "feed",
                    "feedId": "rate2Slider"
                },
                "loopcycle": {
                    "type": "feed",
                    "feedId": "loopcycleSlider"
                },
                "color1": {
                    "type": "feed",
                    "feedId": "color1Slider"
                },
                "color2": {
                    "type": "feed",
                    "feedId": "color2Slider"
                },
                "cycle1": {
                    "type": "feed",
                    "feedId": "cycle1Slider"
                },
                "cycle2": {
                    "type": "feed",
                    "feedId": "cycle2Slider"
                },
                "depthX": {
                    "type": "feed",
                    "feedId": "depthXSlider"
                },
                "depthY": {
                    "type": "feed",
                    "feedId": "depthYSlider"
                },
                "isf_FragNormCoord": {
                    "type": "stream",
                    "stream": "main"
                }
            }
        },
        "danceyCubes-patch": {
            "shaderId": "danceyCubes",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "mysterNumber": {
                    "type": "feed",
                    "feedId": "mysterNumberSlider"
                }
            }
        },
        "plaid-patch": {
            "shaderId": "plaid",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "primeWaves-patch": {
            "shaderId": "primeWaves",
            "incomingLinks": {
                "rxy": {
                    "type": "feed",
                    "feedId": "rxySlider"
                },
                "rxz": {
                    "type": "feed",
                    "feedId": "rxzSlider"
                },
                "TIME": {
                    "type": "feed",
                    "feedId": "time"
                },
                "rate": {
                    "type": "feed",
                    "feedId": "rateSlider"
                },
                "zoom": {
                    "type": "feed",
                    "feedId": "zoomSlider"
                },
                "depth": {
                    "type": "feed",
                    "feedId": "depthSlider"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "RENDERSIZE": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "center": {
                    "type": "feed",
                    "feedId": "center2"
                }
            }
        },
        "quiver-patch": {
            "shaderId": "quiver",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "twist": {
                    "type": "feed",
                    "feedId": "twistSlider"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "spaceRings-patch": {
            "shaderId": "spaceRings",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "waves-patch": {
            "shaderId": "waves",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "frequency": {
                    "type": "feed",
                    "feedId": "frequencySlider"
                }
            }
        },
        "sunsetDelight-patch": {
            "shaderId": "sunsetDelight",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "mouseX": {
                    "type": "feed",
                    "feedId": "mouseXSlider"
                },
                "mouseY": {
                    "type": "feed",
                    "feedId": "mouseYSlider"
                }
            }
        },
        "huerthquake-patch": {
            "shaderId": "huerthquake",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "jacobianUndistortion-patch": {
            "shaderId": "jacobianUndistortion",
            "incomingLinks": {
                "u": {
                    "type": "stream",
                    "stream": "main"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "solidColor-patch": {
            "shaderId": "solidColor",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "color": {
                    "type": "feed",
                    "feedId": "colorColorPicker"
                },
                "sparkliness": {
                    "type": "feed",
                    "feedId": "sparklinessSlider"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "colorBrightness": {
                    "type": "feed",
                    "feedId": "colorBrightnessSlider"
                }
            }
        },
        "sunsetClouds-patch": {
            "shaderId": "sunsetClouds",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iChannel0": {
                    "type": "feed",
                    "feedId": "pixelCoordsTexture"
                },
                "iMouse": {
                    "type": "stream",
                    "stream": "main"
                }
            }
        },
        "oceanClouds-patch": {
            "shaderId": "oceanClouds",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "clouds-patch": {
            "shaderId": "clouds",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "electricEelUniverse-patch": {
            "shaderId": "electricEelUniverse",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "rainbows-patch": {
            "shaderId": "rainbows",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "voronoi-patch": {
            "shaderId": "voronoi",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iChannel0": {
                    "type": "feed",
                    "feedId": "pixelCoordsTexture"
                }
            }
        },
        "voxelEdges-patch": {
            "shaderId": "voxelEdges",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iMouse": {
                    "type": "stream",
                    "stream": "main"
                }
            }
        },
        "octagrams-patch": {
            "shaderId": "octagrams",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "phantomStar-patch": {
            "shaderId": "phantomStar",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "baseWarp-patch": {
            "shaderId": "baseWarp",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "sdfs-patch": {
            "shaderId": "sdfs",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "iMouse": {
                    "type": "stream",
                    "stream": "main"
                }
            }
        },
        "randomSin-patch": {
            "shaderId": "randomSin",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "diveToCloud-patch": {
            "shaderId": "diveToCloud",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "proteanClouds-patch": {
            "shaderId": "proteanClouds",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "iMouse": {
                    "type": "stream",
                    "stream": "main"
                }
            }
        },
        "sincos3d-patch": {
            "shaderId": "sincos3d",
            "incomingLinks": {
                "U": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "iMouse": {
                    "type": "stream",
                    "stream": "main"
                }
            }
        },
        "midCentruy-patch": {
            "shaderId": "midCentruy",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "fractalTrees-patch": {
            "shaderId": "fractalTrees",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "monitorsAndFractalLife-patch": {
            "shaderId": "monitorsAndFractalLife",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "mouse": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "stream",
                    "stream": "main"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "raymarchingBasic-patch": {
            "shaderId": "raymarchingBasic",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "discoteq2-patch": {
            "shaderId": "discoteq2",
            "incomingLinks": {
                "I": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "devilGlass-patch": {
            "shaderId": "devilGlass",
            "incomingLinks": {
                "modelInfo": {
                    "type": "feed",
                    "feedId": "modelInfo"
                },
                "pixelLocation": {
                    "type": "feed",
                    "feedId": "pixelLocation"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "ripple-patch": {
            "shaderId": "ripple",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "uvIn": {
                    "type": "stream",
                    "stream": "main"
                },
                "rippleAmount": {
                    "type": "feed",
                    "feedId": "rippleAmountSlider"
                }
            }
        },
        "sparklez-patch": {
            "shaderId": "sparklez",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "sparkleIntensity": {
                    "type": "feed",
                    "feedId": "sparkleIntensitySlider"
                },
                "upstreamColor": {
                    "type": "stream",
                    "stream": "main"
                },
                "sparkleBrightness": {
                    "type": "feed",
                    "feedId": "sparkleBrightnessSlider"
                }
            },
            "priority": 15
        },
        "heart-patch": {
            "shaderId": "heart",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "upstreamColor": {
                    "type": "stream",
                    "stream": "main"
                }
            }
        },
        "thatSAllFolks-patch": {
            "shaderId": "thatSAllFolks",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "uvIn": {
                    "type": "stream",
                    "stream": "main"
                },
                "ringSpeed": {
                    "type": "feed",
                    "feedId": "ringSpeedSlider"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "ringDensity": {
                    "type": "feed",
                    "feedId": "ringDensitySlider"
                },
                "upstreamColor": {
                    "type": "stream",
                    "stream": "main"
                },
                "ringFade": {
                    "type": "feed",
                    "feedId": "ringFadeSlider"
                }
            }
        },
        "beatShift-patch": {
            "shaderId": "beatShift",
            "incomingLinks": {
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "beatTimeShiftAmount": {
                    "type": "feed",
                    "feedId": "beatTimeShiftAmountSlider"
                },
                "inTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            },
            "stream": "time",
            "priority": 1
        },
        "imageOverlay-patch": {
            "shaderId": "imageOverlay",
            "incomingLinks": {
                "image": {
                    "type": "feed",
                    "feedId": "imageImage"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "inColor": {
                    "type": "stream",
                    "stream": "main"
                }
            }
        },
        "zigZag-patch": {
            "shaderId": "zigZag",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "uvIn": {
                    "type": "stream",
                    "stream": "main"
                },
                "depth": {
                    "type": "feed",
                    "feedId": "depthSlider2"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "frequency": {
                    "type": "feed",
                    "feedId": "frequencySlider2"
                }
            }
        },
        "blackout-patch": {
            "shaderId": "blackout",
            "incomingLinks": {
                "uvIn": {
                    "type": "stream",
                    "stream": "main"
                }
            },
            "priority": 100
        },
        "baaahsLogo-patch": {
            "shaderId": "baaahsLogo",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "horizontalScale": {
                    "type": "feed",
                    "feedId": "horizontalScaleSlider"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "upstreamColor": {
                    "type": "stream",
                    "stream": "main"
                }
            }
        },
        "static-patch": {
            "shaderId": "static",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                }
            }
        },
        "rotateTwist-patch": {
            "shaderId": "rotateTwist",
            "incomingLinks": {
                "uvIn": {
                    "type": "stream",
                    "stream": "main"
                },
                "rotation": {
                    "type": "feed",
                    "feedId": "rotationSlider"
                },
                "twist": {
                    "type": "feed",
                    "feedId": "twistSlider2"
                }
            },
            "priority": 1
        }
    },
    "controls": {
        "shaderControls": {
            "type": "baaahs.Core:ButtonGroup",
            "title": "Shader Controls",
            "showTitle": true,
            "buttonIds": [
            ]
        },
        "vacuity": {
            "type": "baaahs.Core:Vacuity",
            "title": "Vacuity"
        },
        "shaders": {
            "type": "baaahs.Core:ButtonGroup",
            "title": "Shaders",
            "direction": "Vertical",
            "showTitle": true,
            "buttonIds": [
            ]
        },
        "squarezzz": {
            "type": "baaahs.Core:Button",
            "title": "[🐑] Squarezzz",
            "patchIds": [
                "squarezzz-patch"
            ]
        },
        "colorPulse": {
            "type": "baaahs.Core:Button",
            "title": "[🐑] ColorPulse",
            "patchIds": [
                "colorPulse-patch"
            ]
        },
        "geometricColorPulse": {
            "type": "baaahs.Core:Button",
            "title": "[🐑] Geometric ColorPulse",
            "patchIds": [
                "geometricColorPulse-patch"
            ]
        },
        "complexTrippyShit1": {
            "type": "baaahs.Core:Button",
            "title": "[🐑] Complex Trippy Shit #1",
            "patchIds": [
                "complexTrippyShit1-patch"
            ]
        },
        "baaahzebra": {
            "type": "baaahs.Core:Button",
            "title": "[🐑] BAAAHZebra",
            "patchIds": [
                "baaahzebra-patch"
            ]
        },
        "orangeSnowflake": {
            "type": "baaahs.Core:Button",
            "title": "Orange Snowflake",
            "patchIds": [
                "orangeSnowflake-patch"
            ]
        },
        "acidAtTheDisco": {
            "type": "baaahs.Core:Button",
            "title": "Acid at the Disco",
            "patchIds": [
                "acidAtTheDisco-patch"
            ]
        },
        "picassoSNightmare": {
            "type": "baaahs.Core:Button",
            "title": "Picasso's Nightmare",
            "patchIds": [
                "picassoSNightmare-patch"
            ]
        },
        "plasma": {
            "type": "baaahs.Core:Button",
            "title": "Plasma",
            "patchIds": [
                "plasma-patch"
            ]
        },
        "wobblyColorGrid": {
            "type": "baaahs.Core:Button",
            "title": "Wobbly Color Grid",
            "patchIds": [
                "wobblyColorGrid-patch"
            ]
        },
        "gadzooks": {
            "type": "baaahs.Core:Button",
            "title": "Gadzooks",
            "patchIds": [
                "gadzooks-patch"
            ]
        },
        "gaiaSOrgasm": {
            "type": "baaahs.Core:Button",
            "title": "Gaia's Orgasm",
            "patchIds": [
                "gaiaSOrgasm-patch"
            ]
        },
        "faeriePulse": {
            "type": "baaahs.Core:Button",
            "title": "Faerie Pulse",
            "patchIds": [
                "faeriePulse-patch"
            ]
        },
        "yasQueen": {
            "type": "baaahs.Core:Button",
            "title": "Yas Queen",
            "patchIds": [
                "yasQueen-patch"
            ]
        },
        "geometricSheep": {
            "type": "baaahs.Core:Button",
            "title": "[🐑] Geometric Sheep",
            "patchIds": [
                "geometricSheep-patch"
            ]
        },
        "aquaticFlood": {
            "type": "baaahs.Core:Button",
            "title": "Aquatic Flood",
            "patchIds": [
                "aquaticFlood-patch"
            ]
        },
        "circularDependency": {
            "type": "baaahs.Core:Button",
            "title": "Circular Dependency",
            "patchIds": [
                "circularDependency-patch"
            ]
        },
        "redSea": {
            "type": "baaahs.Core:Button",
            "title": "Red Sea",
            "patchIds": [
                "redSea-patch"
            ]
        },
        "baaahsEclipse": {
            "type": "baaahs.Core:Button",
            "title": "[🐑] BAAAHS Eclipse",
            "patchIds": [
                "baaahsEclipse-patch"
            ]
        },
        "firstRaymarches": {
            "type": "baaahs.Core:Button",
            "title": "First Raymarches",
            "patchIds": [
                "firstRaymarches-patch"
            ]
        },
        "fireball": {
            "type": "baaahs.Core:Button",
            "title": "Fireball",
            "patchIds": [
                "fireball-patch"
            ]
        },
        "blueHearts": {
            "type": "baaahs.Core:Button",
            "title": "Blue Hearts",
            "patchIds": [
                "blueHearts-patch"
            ]
        },
        "blueSClues": {
            "type": "baaahs.Core:Button",
            "title": "Blue's Clues",
            "patchIds": [
                "blueSClues-patch"
            ]
        },
        "checkerboard": {
            "type": "baaahs.Core:Button",
            "title": "Checkerboard",
            "patchIds": [
                "checkerboard-patch"
            ]
        },
        "colorDiffusionFlow": {
            "type": "baaahs.Core:Button",
            "title": "Color Diffusion Flow",
            "patchIds": [
                "colorDiffusionFlow-patch"
            ]
        },
        "danceyCubes": {
            "type": "baaahs.Core:Button",
            "title": "Dancey Cubes",
            "patchIds": [
                "danceyCubes-patch"
            ]
        },
        "plaid": {
            "type": "baaahs.Core:Button",
            "title": "Plaid",
            "patchIds": [
                "plaid-patch"
            ]
        },
        "primeWaves": {
            "type": "baaahs.Core:Button",
            "title": "Prime Waves",
            "patchIds": [
                "primeWaves-patch"
            ]
        },
        "quiver": {
            "type": "baaahs.Core:Button",
            "title": "Quiver",
            "patchIds": [
                "quiver-patch"
            ]
        },
        "spaceRings": {
            "type": "baaahs.Core:Button",
            "title": "Space Rings",
            "patchIds": [
                "spaceRings-patch"
            ]
        },
        "waves": {
            "type": "baaahs.Core:Button",
            "title": "Waves",
            "patchIds": [
                "waves-patch"
            ]
        },
        "sunsetDelight": {
            "type": "baaahs.Core:Button",
            "title": "Sunset Delight",
            "patchIds": [
                "sunsetDelight-patch"
            ]
        },
        "huerthquake": {
            "type": "baaahs.Core:Button",
            "title": "Huerthquake",
            "patchIds": [
                "huerthquake-patch"
            ]
        },
        "jacobianUndistortion": {
            "type": "baaahs.Core:Button",
            "title": "Jacobian Undistortion",
            "patchIds": [
                "jacobianUndistortion-patch"
            ]
        },
        "solidColor": {
            "type": "baaahs.Core:Button",
            "title": "Solid Color",
            "patchIds": [
                "solidColor-patch"
            ]
        },
        "sunsetClouds": {
            "type": "baaahs.Core:Button",
            "title": "Sunset Clouds",
            "patchIds": [
                "sunsetClouds-patch"
            ]
        },
        "oceanClouds": {
            "type": "baaahs.Core:Button",
            "title": "Ocean Clouds",
            "patchIds": [
                "oceanClouds-patch"
            ]
        },
        "clouds": {
            "type": "baaahs.Core:Button",
            "title": "Clouds",
            "patchIds": [
                "clouds-patch"
            ]
        },
        "electricEelUniverse": {
            "type": "baaahs.Core:Button",
            "title": "Electric Eel Universe",
            "patchIds": [
                "electricEelUniverse-patch"
            ]
        },
        "rainbows": {
            "type": "baaahs.Core:Button",
            "title": "Rainbows",
            "patchIds": [
                "rainbows-patch"
            ]
        },
        "voronoi": {
            "type": "baaahs.Core:Button",
            "title": "Voronoi",
            "patchIds": [
                "voronoi-patch"
            ]
        },
        "voxelEdges": {
            "type": "baaahs.Core:Button",
            "title": "Voxel Edges",
            "patchIds": [
                "voxelEdges-patch"
            ]
        },
        "octagrams": {
            "type": "baaahs.Core:Button",
            "title": "Octagrams",
            "patchIds": [
                "octagrams-patch"
            ]
        },
        "phantomStar": {
            "type": "baaahs.Core:Button",
            "title": "Phantom Star",
            "patchIds": [
                "phantomStar-patch"
            ]
        },
        "baseWarp": {
            "type": "baaahs.Core:Button",
            "title": "Base Warp",
            "patchIds": [
                "baseWarp-patch"
            ]
        },
        "sdfs": {
            "type": "baaahs.Core:Button",
            "title": "SDFS",
            "patchIds": [
                "sdfs-patch"
            ]
        },
        "randomSin": {
            "type": "baaahs.Core:Button",
            "title": "Random Sin",
            "patchIds": [
                "randomSin-patch"
            ]
        },
        "diveToCloud": {
            "type": "baaahs.Core:Button",
            "title": "Dive to Cloud",
            "patchIds": [
                "diveToCloud-patch"
            ]
        },
        "proteanClouds": {
            "type": "baaahs.Core:Button",
            "title": "Protean Clouds",
            "patchIds": [
                "proteanClouds-patch"
            ]
        },
        "sincos3d": {
            "type": "baaahs.Core:Button",
            "title": "sincos 3d",
            "patchIds": [
                "sincos3d-patch"
            ]
        },
        "midCentruy": {
            "type": "baaahs.Core:Button",
            "title": "MidCentruy",
            "patchIds": [
                "midCentruy-patch"
            ]
        },
        "fractalTrees": {
            "type": "baaahs.Core:Button",
            "title": "Fractal Trees",
            "patchIds": [
                "fractalTrees-patch"
            ]
        },
        "monitorsAndFractalLife": {
            "type": "baaahs.Core:Button",
            "title": "monitors and fractal_life",
            "patchIds": [
                "monitorsAndFractalLife-patch"
            ]
        },
        "raymarchingBasic": {
            "type": "baaahs.Core:Button",
            "title": "Raymarching Basic",
            "patchIds": [
                "raymarchingBasic-patch"
            ]
        },
        "discoteq2": {
            "type": "baaahs.Core:Button",
            "title": "Discoteq 2",
            "patchIds": [
                "discoteq2-patch"
            ]
        },
        "devilGlass": {
            "type": "baaahs.Core:Button",
            "title": "Devil Glass",
            "patchIds": [
                "devilGlass-patch"
            ]
        },
        "effects": {
            "type": "baaahs.Core:ButtonGroup",
            "title": "Effects",
            "direction": "Vertical",
            "showTitle": true,
            "allowMultiple": true,
            "buttonIds": [
            ]
        },
        "ripple": {
            "type": "baaahs.Core:Button",
            "title": "Ripple",
            "patchIds": [
                "ripple-patch"
            ]
        },
        "sparklez": {
            "type": "baaahs.Core:Button",
            "title": "Sparklez™",
            "patchIds": [
                "sparklez-patch"
            ]
        },
        "heart": {
            "type": "baaahs.Core:Button",
            "title": "Heart",
            "patchIds": [
                "heart-patch"
            ]
        },
        "thatSAllFolks": {
            "type": "baaahs.Core:Button",
            "title": "That's all, folks!",
            "patchIds": [
                "thatSAllFolks-patch"
            ]
        },
        "beatShift": {
            "type": "baaahs.Core:Button",
            "title": "Beat Shift",
            "patchIds": [
                "beatShift-patch"
            ]
        },
        "imageOverlay": {
            "type": "baaahs.Core:Button",
            "title": "Image Overlay",
            "patchIds": [
                "imageOverlay-patch"
            ]
        },
        "zigZag": {
            "type": "baaahs.Core:Button",
            "title": "Zig Zag",
            "patchIds": [
                "zigZag-patch"
            ]
        },
        "blackout": {
            "type": "baaahs.Core:Button",
            "title": "Blackout",
            "activationType": "Momentary",
            "patchIds": [
                "blackout-patch"
            ]
        },
        "baaahsLogo": {
            "type": "baaahs.Core:Button",
            "title": "[🐑] BAAAHS Logo",
            "patchIds": [
                "baaahsLogo-patch"
            ]
        },
        "static": {
            "type": "baaahs.Core:Button",
            "title": "Static",
            "patchIds": [
                "static-patch"
            ]
        },
        "rotateTwist": {
            "type": "baaahs.Core:Button",
            "title": "Rotate & Twist",
            "patchIds": [
                "rotateTwist-patch"
            ]
        },
        "globalControls": {
            "type": "baaahs.Core:ButtonGroup",
            "title": "Global Controls",
            "showTitle": true,
            "buttonIds": [
            ]
        },
        "brightness": {
            "type": "baaahs.Core:Slider",
            "title": "Brightness",
            "initialValue": 0.15,
            "maxValue": 0.75,
            "controlledFeedId": "brightnessSlider"
        },
        "saturation": {
            "type": "baaahs.Core:Slider",
            "title": "Saturation",
            "maxValue": 1.25,
            "controlledFeedId": "saturationSlider"
        },
        "hueShift": {
            "type": "baaahs.Core:Slider",
            "title": "Hue Shift",
            "maxValue": 2,
            "controlledFeedId": "hueShiftSlider"
        },
        "visualizer": {
            "type": "baaahs.Core:Visualizer"
        },
        "beatLink": {
            "type": "baaahs.BeatLink:BeatLink"
        }
    },
    "feeds": {
        "modelInfo": {
            "type": "baaahs.Core:ModelInfo"
        },
        "pixelLocation": {
            "type": "baaahs.Core:PixelLocation"
        },
        "hueShiftSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Hue Shift",
            "initialValue": 1,
            "minValue": 0,
            "maxValue": 2
        },
        "brightnessSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Brightness",
            "initialValue": 0.15,
            "minValue": 0,
            "maxValue": 0.75
        },
        "saturationSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Saturation",
            "initialValue": 1,
            "minValue": 0,
            "maxValue": 1.25
        },
        "time": {
            "type": "baaahs.Core:Time"
        },
        "speedSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Speed",
            "initialValue": 3,
            "minValue": 1,
            "maxValue": 5
        },
        "resolution": {
            "type": "baaahs.Core:Resolution"
        },
        "beatInfo": {
            "type": "baaahs.BeatLink:BeatInfo"
        },
        "midi": {
            "type": "baaahs.Midi:Midi"
        },
        "hueRangeSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Hue Range",
            "initialValue": 0.3,
            "minValue": 0,
            "maxValue": 1
        },
        "fromCenterSwitch": {
            "type": "baaahs.Core:Switch",
            "title": "From Center",
            "initiallyEnabled": true
        },
        "pulseSpeedSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Pulse Speed",
            "initialValue": 1,
            "minValue": 1,
            "maxValue": 3
        },
        "center": {
            "type": "baaahs.Core:XyPad",
            "title": "Center"
        },
        "fixtureInfo": {
            "type": "baaahs.Core:FixtureInfo"
        },
        "cycleSpeedSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Cycle Speed",
            "initialValue": 1,
            "minValue": 0,
            "maxValue": 5
        },
        "speedSlider2": {
            "type": "baaahs.Core:Slider",
            "title": "Speed",
            "initialValue": 5,
            "minValue": 0,
            "maxValue": 10
        },
        "pulsinessSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Pulsiness",
            "initialValue": 3,
            "minValue": 1,
            "maxValue": 5
        },
        "hueSpreadSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Hue Spread",
            "initialValue": 2,
            "minValue": 0,
            "maxValue": 10
        },
        "cycleSpeedSlider2": {
            "type": "baaahs.Core:Slider",
            "title": "Cycle Speed",
            "initialValue": 1,
            "minValue": 0,
            "maxValue": 10
        },
        "beatLink": {
            "type": "baaahs.BeatLink:BeatLink"
        },
        "soundAnalysis": {
            "type": "baaahs.SoundAnalysis:SoundAnalysis"
        },
        "horizontalScaleSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Horizontal Scale",
            "initialValue": 0.7,
            "minValue": 0.25,
            "maxValue": 1
        },
        "thingSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Thing",
            "initialValue": 0.866025,
            "minValue": 0,
            "maxValue": 2
        },
        "conflagrationSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Conflagration",
            "initialValue": 15,
            "minValue": 5,
            "maxValue": 20
        },
        "checkerboardSizeSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Checkerboard Size",
            "initialValue": 0.125,
            "minValue": 0.001,
            "maxValue": 1
        },
        "date": {
            "type": "baaahs.Core:Date"
        },
        "nudgeSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Nudge",
            "initialValue": 0.095,
            "minValue": 0.001,
            "maxValue": 0.01
        },
        "rate1Slider": {
            "type": "baaahs.Core:Slider",
            "title": "Rate1",
            "initialValue": 1.9,
            "minValue": -3,
            "maxValue": 3
        },
        "rate2Slider": {
            "type": "baaahs.Core:Slider",
            "title": "Rate2",
            "initialValue": 0.6,
            "minValue": -3,
            "maxValue": 3
        },
        "loopcycleSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Loopcycle",
            "initialValue": 85,
            "minValue": 20,
            "maxValue": 100
        },
        "color1Slider": {
            "type": "baaahs.Core:Slider",
            "title": "Color1",
            "initialValue": 0.45,
            "minValue": -2.5,
            "maxValue": 2.5
        },
        "color2Slider": {
            "type": "baaahs.Core:Slider",
            "title": "Color2",
            "initialValue": 1,
            "minValue": -1.25,
            "maxValue": 1.125
        },
        "cycle1Slider": {
            "type": "baaahs.Core:Slider",
            "title": "Cycle1",
            "initialValue": 1.33,
            "minValue": 0.01,
            "maxValue": 3.1459
        },
        "cycle2Slider": {
            "type": "baaahs.Core:Slider",
            "title": "Cycle2",
            "initialValue": 0.22,
            "minValue": -0.497,
            "maxValue": 0.497
        },
        "depthXSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Depth X",
            "initialValue": 0.85,
            "minValue": 0.001,
            "maxValue": 0.9
        },
        "depthYSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Depth Y",
            "initialValue": 0.25,
            "minValue": 0.001,
            "maxValue": 0.9
        },
        "mysterNumberSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Myster Number",
            "initialValue": 1,
            "minValue": 0,
            "maxValue": 1
        },
        "rxySlider": {
            "type": "baaahs.Core:Slider",
            "title": "Rxy",
            "initialValue": 11,
            "minValue": 1,
            "maxValue": 17
        },
        "rxzSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Rxz",
            "initialValue": 13,
            "minValue": 1,
            "maxValue": 17
        },
        "rateSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Rate",
            "initialValue": -1,
            "minValue": -3,
            "maxValue": 3
        },
        "zoomSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Zoom",
            "initialValue": 5,
            "minValue": -10,
            "maxValue": 10
        },
        "depthSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Depth",
            "initialValue": 0.6,
            "minValue": 0,
            "maxValue": 1
        },
        "center2": {
            "type": "baaahs.Core:XyPad",
            "title": "Center",
            "initialValue": {
                "x": -2,
                "y": -1
            },
            "minValue": {
                "x": -10,
                "y": -10
            },
            "maxValue": {
                "x": 10,
                "y": 10
            }
        },
        "twistSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Twist",
            "initialValue": 0.2,
            "minValue": -4,
            "maxValue": 4
        },
        "frequencySlider": {
            "type": "baaahs.Core:Slider",
            "title": "Frequency",
            "initialValue": 15,
            "minValue": 3.14,
            "maxValue": 25
        },
        "mouseXSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Mouse X",
            "initialValue": 1,
            "minValue": 0,
            "maxValue": 1
        },
        "mouseYSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Mouse Y",
            "initialValue": 1,
            "minValue": 0,
            "maxValue": 1
        },
        "colorColorPicker": {
            "type": "baaahs.Core:ColorPicker",
            "title": "Color",
            "initialValue": -13434625
        },
        "sparklinessSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Sparkliness",
            "initialValue": 0.02,
            "minValue": 0,
            "maxValue": 0.5
        },
        "colorBrightnessSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Color Brightness",
            "initialValue": 0.75,
            "minValue": 0,
            "maxValue": 1
        },
        "pixelCoordsTexture": {
            "type": "baaahs.Core:PixelCoordsTexture"
        },
        "rippleAmountSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Ripple Amount",
            "initialValue": 1,
            "minValue": 0,
            "maxValue": 1
        },
        "sparkleIntensitySlider": {
            "type": "baaahs.Core:Slider",
            "title": "Sparkle Intensity",
            "initialValue": 1,
            "minValue": 0,
            "maxValue": 2
        },
        "sparkleBrightnessSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Sparkle Brightness",
            "initialValue": 0.5,
            "minValue": 0,
            "maxValue": 4
        },
        "ringSpeedSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Ring Speed",
            "initialValue": 10,
            "minValue": -15,
            "maxValue": 20
        },
        "ringDensitySlider": {
            "type": "baaahs.Core:Slider",
            "title": "Ring Density",
            "initialValue": 60,
            "minValue": 10,
            "maxValue": 120
        },
        "ringFadeSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Ring Fade",
            "initialValue": 0.5,
            "minValue": 0,
            "maxValue": 1
        },
        "beatTimeShiftAmountSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Beat Time Shift Amount",
            "initialValue": 0.5,
            "minValue": 0,
            "maxValue": 2
        },
        "imageImage": {
            "type": "baaahs.Core:Image",
            "title": "Image Image"
        },
        "depthSlider2": {
            "type": "baaahs.Core:Slider",
            "title": "Depth",
            "initialValue": 0.1,
            "minValue": 0,
            "maxValue": 0.2
        },
        "frequencySlider2": {
            "type": "baaahs.Core:Slider",
            "title": "Frequency",
            "initialValue": 10,
            "minValue": 0,
            "maxValue": 20
        },
        "rotationSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Rotation",
            "initialValue": 0,
            "minValue": -6.28,
            "maxValue": 6.28
        },
        "twistSlider2": {
            "type": "baaahs.Core:Slider",
            "title": "Twist",
            "initialValue": 0,
            "minValue": -1,
            "maxValue": 1
        }
    },
    "version": 10
}