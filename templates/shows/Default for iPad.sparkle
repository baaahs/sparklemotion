{
    "title": "Sparkle Motion",
    "patchIds": [
        "xyProjection-patch",
        "darkness-patch",
        "hsb-patch"
    ],
    "layouts": {
        "panels": {
            "backdrops": {
                "title": "Backdrops"
            }
        },
        "formats": {
            "default": {
                "mediaQuery": null,
                "tabs": [
                    {
                        "type": "Grid",
                        "title": "Main",
                        "columns": 9,
                        "rows": 8,
                        "items": [
                            {
                                "controlId": "shaderControls",
                                "column": 0,
                                "row": 0,
                                "width": 6,
                                "height": 2,
                                "layout": {
                                    "columns": 1,
                                    "rows": 1,
                                    "items": [
                                        {
                                            "controlId": "vacuity",
                                            "column": 0,
                                            "row": 0
                                        }
                                    ]
                                }
                            },
                            {
                                "controlId": "shaders",
                                "column": 0,
                                "row": 2,
                                "width": 6,
                                "height": 6,
                                "layout": {
                                    "columns": 6,
                                    "rows": 6,
                                    "items": [
                                        {
                                            "controlId": "squarezzz",
                                            "column": 2,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "complexTrippyShit1",
                                            "column": 2,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "baaahzebra",
                                            "column": 3,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "orangeSnowflake",
                                            "column": 1,
                                            "row": 2
                                        },
                                        {
                                            "controlId": "acidAtTheDisco",
                                            "column": 2,
                                            "row": 3
                                        },
                                        {
                                            "controlId": "plasma",
                                            "column": 0,
                                            "row": 3
                                        },
                                        {
                                            "controlId": "wobblyColorGrid",
                                            "column": 3,
                                            "row": 3
                                        },
                                        {
                                            "controlId": "gadzooks",
                                            "column": 0,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "faeriePulse",
                                            "column": 0,
                                            "row": 2
                                        },
                                        {
                                            "controlId": "yasQueen",
                                            "column": 3,
                                            "row": 5
                                        },
                                        {
                                            "controlId": "circularDependency",
                                            "column": 0,
                                            "row": 5
                                        },
                                        {
                                            "controlId": "fireball",
                                            "column": 1,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "blueHearts",
                                            "column": 5,
                                            "row": 3
                                        },
                                        {
                                            "controlId": "blueSClues",
                                            "column": 5,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "checkerboard",
                                            "column": 3,
                                            "row": 2
                                        },
                                        {
                                            "controlId": "danceyCubes",
                                            "column": 0,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "plaid",
                                            "column": 2,
                                            "row": 2
                                        },
                                        {
                                            "controlId": "quiver",
                                            "column": 4,
                                            "row": 3
                                        },
                                        {
                                            "controlId": "spaceRings",
                                            "column": 1,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "waves",
                                            "column": 3,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "huerthquake",
                                            "column": 3,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "solidColor",
                                            "column": 0,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "sunsetClouds",
                                            "column": 2,
                                            "row": 5
                                        },
                                        {
                                            "controlId": "oceanClouds",
                                            "column": 5,
                                            "row": 5
                                        },
                                        {
                                            "controlId": "electricEelUniverse",
                                            "column": 4,
                                            "row": 2
                                        },
                                        {
                                            "controlId": "rainbows",
                                            "column": 4,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "voronoi",
                                            "column": 1,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "voxelEdges",
                                            "column": 1,
                                            "row": 3
                                        },
                                        {
                                            "controlId": "octagrams",
                                            "column": 5,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "randomSin",
                                            "column": 2,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "diveToCloud",
                                            "column": 5,
                                            "row": 2
                                        },
                                        {
                                            "controlId": "sincos3d",
                                            "column": 4,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "midCentury",
                                            "column": 5,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "monitorsAndFractalLife",
                                            "column": 4,
                                            "row": 5
                                        },
                                        {
                                            "controlId": "discoteq2",
                                            "column": 4,
                                            "row": 4
                                        },
                                        {
                                            "controlId": "devilGlass",
                                            "column": 1,
                                            "row": 5
                                        }
                                    ]
                                }
                            },
                            {
                                "controlId": "effects",
                                "column": 6,
                                "row": 3,
                                "width": 3,
                                "height": 2,
                                "layout": {
                                    "columns": 3,
                                    "rows": 2,
                                    "items": [
                                        {
                                            "controlId": "ripple",
                                            "column": 0,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "sparklez",
                                            "column": 2,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "thatSAllFolks",
                                            "column": 1,
                                            "row": 1
                                        },
                                        {
                                            "controlId": "zigZag",
                                            "column": 1,
                                            "row": 0
                                        },
                                        {
                                            "controlId": "rotateTwist",
                                            "column": 0,
                                            "row": 1
                                        }
                                    ]
                                }
                            },
                            {
                                "controlId": "globalControls",
                                "column": 6,
                                "row": 5,
                                "width": 3,
                                "height": 3,
                                "layout": {
                                    "columns": 3,
                                    "rows": 2,
                                    "items": [
                                        {
                                            "controlId": "brightness",
                                            "column": 2,
                                            "row": 0,
                                            "height": 2
                                        },
                                        {
                                            "controlId": "saturation",
                                            "column": 1,
                                            "row": 0,
                                            "height": 2
                                        },
                                        {
                                            "controlId": "hueShift",
                                            "column": 0,
                                            "row": 0,
                                            "height": 2
                                        }
                                    ]
                                }
                            },
                            {
                                "controlId": "visualizer",
                                "column": 6,
                                "row": 0,
                                "width": 3,
                                "height": 3
                            }
                        ]
                    }
                ]
            }
        }
    },
    "shaders": {
        "xyProjection": {
            "title": "XY Projection",
            "src": "// XY Projection\n\nstruct ModelInfo {\n    vec3 center;\n    vec3 extents;\n};\nuniform ModelInfo modelInfo; // @@ModelInfo\n\n// @return uv-coordinate\n// @param pixelLocation xyz-coordinate\nvec2 main(vec3 pixelLocation) {\n    vec3 extents = modelInfo.extents;\n    vec3 pixelOffset = (pixelLocation - modelInfo.center) / extents + .5;\n    return vec2(pixelOffset.x, pixelOffset.y);\n}\n"
        },
        "darkness": {
            "title": "Darkness",
            "src": "void main(void) {\n    gl_FragColor = vec4(0., 0., 0., 1.);\n}"
        },
        "hsb": {
            "title": "HSB",
            "src": "// HSB\n\nuniform float brightness; // @@Slider min=0 max=1.25 default=1\nuniform float saturation; // @@Slider min=0 max=1.25 default=1\nuniform float hueShift; // @@Slider min=0 max=2 default=1\n\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// @return color\n// @param inColor color\nvec4 main(vec4 inColor) {\n    vec4 clampedColor = clamp(inColor, 0., 1.);\n    vec3 hsv = rgb2hsv(clampedColor.rgb);\n    hsv.x += hueShift;\n    hsv.y *= saturation;\n    hsv.z *= brightness;\n    return vec4(hsv2rgb(hsv), clampedColor.a);\n}"
        },
        "squarezzz": {
            "title": "[🐑] Squarezzz",
            "src": "// Square pulse thingy optimized for BAAAHS\n// originally based on https://www.shadertoy.com/view/XsBfRW\n\nuniform float time; // @@Time\nuniform vec2 resolution; // @@Resolution\nuniform float speed; // @@Slider default=3.0 min=1.0 max=5.0\n\n\nstruct BeatInfo {\n\tfloat beat;\n\tfloat bpm;\n\tfloat intensity;\n\tfloat confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n/* Returns a value which cycles from 0 to 1 for each beat, with most of the increase occuring near the beat */\nfloat beatIntegral() {\n\tfloat t = mod(beatInfo.beat, 1.);\n\tfloat POWER = 4.; // Adjusts sharpnett of the curve\n\tfloat OFFSET = 0.0; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n\treturn 1. - pow(1. - mod(t + OFFSET, 1.0), POWER);\n}\n\n/* Returns a monotonically increasing time value which with most of the increase occuring near the beat */\nfloat pulsedTime() {\n\tfloat timeAdjustment = beatIntegral() - mod(beatInfo.beat, 1.);\n\treturn speed * 0.87 * (time + .4 * timeAdjustment); // 0.87 keeps it from pausing at the same spot each cycle\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tfloat t = pulsedTime();\n\n\tfloat aspect = resolution.y/resolution.x;\n\tfloat value;\n\tvec2 uv = fragCoord.xy / iResolution.x;\n\tuv -= vec2(0.5, 0.5 * aspect);\n\tuv *= .6;\n\n\tfloat rot = radians(45.0); // radians(45.0*sin(t));\n\tmat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n\n\tuv = m * uv;\n\tuv += vec2(0.5, 0.5 * aspect);\n\tuv.y+=0.5*(1.0 - aspect);\n\tvec2 pos = 10.0 * uv;\n\tvec2 rep = fract(pos);\n\tfloat dist = 2.0*min(min(rep.x, 1.0-rep.x), min(rep.y, 1.0-rep.y));\n\tfloat squareDist = length((floor(pos)+vec2(0.5)) - vec2(5.0) );\n\n\tfloat edge = sin(t-squareDist*0.5)*0.5+0.5;\n\n\tedge = (t-squareDist*0.5)*0.5;\n\tedge = 2.0*fract(edge*0.5);\n\n\tvalue = fract (dist*2.0);\n\tvalue = mix(value, 1.0-value, step(1.0, edge));\n\n\tedge = pow(abs(1.0-edge), 2.0);\n\n\tvalue = smoothstep( edge-0.05, edge, 0.95*value);\n\n\n\tvalue += squareDist*.1;\n\n\tvec4 baseColor = vec4(0.5 + 0.5*cos(t+uv.xyx+vec3(0,2,4)), 1.0);\n\tfragColor = mix(vec4(1.0,1.0,1.0,1.0), baseColor, value);\n\tfragColor.a = 0.25*clamp(value, 0.0, 1.0);\n}\n\n"
        },
        "complexTrippyShit1": {
            "title": "[🐑] Complex Trippy Shit #1",
            "src": "// Complex Trippy Shit #1\n// Ben Bartlett\n\n#define PI 3.1415926535897932384626433832795\n#define ii vec2(0.0, 1.0)\n\nuniform float time; // @@Time\nuniform vec2 resolution; // @@Resolution\n\n// Complex multiplication\nvec2 cx_mul(vec2 a, vec2 b) {return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }\n// Complex division\nvec2 cx_div(vec2 a, vec2 b) { return vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y))); }\n// Modulus\nfloat cx_abs(vec2 z) { return length(z); }\n// Complex conjugate\nvec2 cx_conj(vec2 z) { return vec2(z.x, -z.y); }\n// Complex argument\nfloat cx_arg(vec2 z) { return atan(z.y, z.x); }\n// Sin cos and exponential for complex numbers\nvec2 cx_sin(vec2 z) { return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y)); }\nvec2 cx_cos(vec2 z) { return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y)); }\nvec2 cx_exp(vec2 z) { return vec2(exp(z.x) * cos(z.y), exp(z.x) * sin(z.y)); }\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Complex math library ==========================\nvec2 cx_pow(vec2 z, float n) {\n    float angle = cx_arg(z);\n    float r = length(z);\n    float re = pow(r, n) * cos(n*angle);\n    float im = pow(r, n) * sin(n*angle);\n    return vec2(re, im);\n}\nvec2 cx_log(vec2 z) {\n    float rpart = sqrt((z.x*z.x)+(z.y*z.y));\n    float ipart = atan(z.y,z.x);\n    if (ipart > PI) ipart=ipart-(2.0*PI);\n    return vec2(log(rpart),ipart);\n}\nvec4 domainColoring (vec2 z, vec2 gridSpacing, float saturation, float gridStrength, float magStrength, float linePower) {\n    // Adapted from https://github.com/rreusser/glsl-domain-coloring\n    float carg = cx_arg(z);\n    float cmod = cx_abs(z);\n\n    float rebrt = pow((fract(z.x / gridSpacing.x) - 0.5) * 2.0, 2.);\n    float imbrt = pow((fract(z.y / gridSpacing.y) - 0.5) * 2.0, 2.);\n\n    float grid = 1.0 - (1.0 - rebrt) * (1.0 - imbrt);\n    grid = pow(abs(grid), linePower);\n\n    float circ = (fract(log2(cmod)) - 0.5) * 2.0;\n    circ = pow(abs(circ), linePower) * magStrength;\n\n    vec3 rgb = hsv2rgb(vec3(carg * 0.5 / PI, saturation, 0.5 + 0.5 * saturation - gridStrength * grid));\n    rgb *= (1.0 - circ);\n    rgb += circ * vec3(1.0);\n    return vec4(rgb, 1.0);\n}\n// =============================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.8 * (2. * fragCoord/resolution.xy - 1.);\n    uv *= vec2(16./9., 1.);\n    uv = vec2(-uv[1] - .2, uv[0]);\n\n    // Function is log(1/4 + iz^-3) + 2 exp(it)\n    vec2 fz = cx_log(vec2(.25, 0.0) + cx_pow(uv, -3.)) + 2. * cx_exp(time * ii);\n\n    float refz = fz[0];\n    float imfz = fz[1];\n    float argfz = cx_arg(fz) / (2.*PI);\n    float absfz = cx_abs(fz);\n\n    //float map = sin(refz + imfz) - log(absfz);\n    //float a=2.;\n    //map = pow(absfz, a) / (pow(absfz, a) + 1.);\n\n    fragColor = domainColoring(fz, vec2(1.0, 1.), 0.9, 1., 1., 1.);\n}"
        },
        "baaahzebra": {
            "title": "[🐑] BAAAHZebra",
            "src": "// Cool zebra pattern looking thing that alternates polarity on the beat\n// Ben Bartlett\n\nuniform float time; // @@Time\nuniform float speed; // @@Slider min=0.0 max=10.0 default=5.0\n\nstruct BeatInfo {\n\tfloat beat;\n\tfloat bpm;\n\tfloat intensity;\n\tfloat confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n// @return color\n// @param uv uv-coordinate\nvec4 main(vec2 uv) {\n\tfloat t = time * .01 * speed / 5.0;\n\tvec2 center = vec2(0.,0.);\n\n\tfloat periods = 4.1;\n\tcenter.y+=sin(uv.y*periods + t * 51.);\n\tcenter.x+=cos(uv.x*periods + t);\n\n\tfloat slantyness = 5.0;\n\tcenter.y+=sin(slantyness*(uv.x + uv.y));\n\tcenter.x+=sin(slantyness*(uv.x + uv.y));\n\n\tfloat d = distance(uv,center);\n\tfloat kFreq = 2.5;\n\n\tfloat k = -sin(d*6.283*kFreq - t);\n\tint beat = int(beatInfo.beat);\n\tif (beat % 2 == 0) {\n\t\tk *= -1.;\n\t}\n\n\tfloat e = smoothstep(0., fwidth(k)*1.5, k);\n\treturn vec4(sqrt(max(e, 0.)));\n}"
        },
        "orangeSnowflake": {
            "title": "Orange Snowflake",
            "src": "// Orange Snowflake\n// Modified from http://glslsandbox.com/e#61105.0\n\n/*\n * Original shader from: https://www.shadertoy.com/view/wl3XW8\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.141592\n#define TAU (2.*PI)\n\n// glslsandbox uniforms\nuniform float time; // @@Time\nuniform vec2 resolution; // @@Resolution\nuniform float speed; // @@Slider default=3.0 min=1.0 max=5.0\nuniform float pulsiness; // @@Slider default=3.0 min=1.0 max=5.0\n\n\n\n\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\n/* Returns a value which cycles from 0 to 1 for each beat, with most of the increase occuring near the beat */\nfloat beatIntegral() {\n\tfloat t = mod(beatInfo.beat, 1.);\n\tfloat POWER = 4.; // Adjusts sharpnett of the curve\n\tfloat OFFSET = 0.0; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n\treturn 1. - pow(1. - mod(t + OFFSET, 1.0), POWER);\n}\n\n/* Returns a monotonically increasing time value which with most of the increase occuring near the beat */\nfloat pulsedTime() {\n    float timeAdjustment = beatIntegral() - mod(beatInfo.beat, 1.);\n    return speed * .25 * 0.87 * (time + .1 * pulsiness * timeAdjustment); // 0.87 keeps it from pausing at the same spot each cycle\n}\n\n\n\n\n// --------[ Original ShaderToy begins here ]---------- //\n// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me\n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\nfloat t = pulsedTime();\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.4,18.4)))*1245.4);}\n\nmat2 rot (float a)\n{return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat hd (vec2 uv)\n{\n    uv = abs(uv);\n    return max(uv.x, dot(uv, normalize(vec2(1., sqrt(3.)))));\n}\n\nvec4 hgrid (vec2 uv,float detail)\n{\n    uv *= detail;\n    vec2 ga = mod(uv,vec2(1., sqrt(3.)))-vec2(1., sqrt(3.))*0.5;\n    vec2 gb = mod(uv-vec2(1., sqrt(3.))*0.5,vec2(1., sqrt(3.)))-vec2(1., sqrt(3.))*0.5;\n    vec2 guv = (dot(ga,ga)< dot(gb,gb))? ga: gb;\n\n    vec2 gid = uv-guv;\n\n    guv.y = 0.5-hd(guv);\n\n    return vec4(guv,gid);\n}\n\nfloat hexf (vec2 uv)\n{\n    float det = 3.;\n    float s = 0.5;\n    float d = 0.;\n    for (float i=0.; i<3.; i++)\n    {\n        float ratio = i/5.;\n        uv *= rot(TAU/(5.));\n        uv = (mod(i,2.) == 0.) ? vec2(uv.x+t*s,uv.y) : vec2(uv.x,uv.y+t*s);\n        d += step(hgrid(uv, det).y,0.03);\n        s -= 0.1;\n        det ++;\n    }\n    return d;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat fractal (vec3 p)\n{\n    float size = 1.;\n    float d = box(p,vec3(size));\n    for (float i=0.; i<5.; i++)\n    {\n        float ratio = i/5.;\n        p.yz *= rot(t);\n        mo(p.xz, vec2(2.+ratio));\n        mo(p.xy, vec2(0.5+ratio));\n        p.xy *= rot(t+ratio);\n        size -= ratio*1.5;\n        d= stmin(d,box(p,vec3(size)),1., 4.);\n    }\n    return d;\n}\n\nfloat g1 = 0.;\nfloat SDF (vec3 p)\n{\n    float d = fractal(p);\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-resolution.xy)/resolution.y;\n\n    float mask = 1.0;//step(0.3, abs(sin(length(uv)-PI*t))+0.01);\n    float fx = 0.0;//clamp(mix(1.-hexf(uv), hexf(uv), mask),0.,1.);\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(0.,0.,-10.),\n    p = ro,\n    rd = normalize(vec3(uv,1.)),\n    col = vec3(0.);\n\n    float shad = 0.;\n\n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/64.;\n            break;\n        }\n        d *= 0.7+dither*0.1;\n        p += d*rd;\n    }\n\n    col = vec3(2.,length(uv*0.5),0.1)*g1*0.2;\n    col *= (1.-fx);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n"
        },
        "acidAtTheDisco": {
            "title": "Acid at the Disco",
            "src": "// Acid at the Disco\n// Modified from: https://www.shadertoy.com/view/4sfXRB\n\nuniform float time; // @@Time\nuniform vec2 resolution; // @@Resolution\nuniform float speed; // @@Slider default=3.0 min=1.0 max=5.0\nuniform float pulsiness; // @@Slider default=3.0 min=1.0 max=5.0\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\nfloat beatIntegral() {\n    float t = mod(beatInfo.beat, 1.);\n    float POWER = 4.; // Adjusts sharpnett of the curve\n    float OFFSET = 0.0; // Adjusts future-offset of curve. OFFSET=0.5 means the steepest part happens between beats.\n    return 1. - pow(1. - mod(t + OFFSET, 1.0), POWER);\n}\n\nfloat pulsedTime() {\n    float timeAdjustment = beatIntegral() - mod(beatInfo.beat, 1.);\n    return speed * .25 * 0.87 * (time + .1 * pulsiness * timeAdjustment); // 0.87 keeps it from pausing at the same spot each cycle\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / resolution.xy;\n    float t = pulsedTime();\n    float depth = sin(uv.y*2.0+sin(t)*1.5+1.0+sin(uv.x*3.0+t*1.2))*cos(uv.y*2.0+t)+sin((uv.x*3.0+t));\n    float texey = (uv.x-0.5);\n    float xband = sin(sqrt(uv.y/uv.y)*16.0/(depth)+t*3.0);\n    float final = (\n    sin(texey/abs(depth)*32.0+t*16.0+sin(uv.y*uv.x*32.0*sin(depth*3.0)))*(depth)*xband\n    );\n\n\n    fragColor = vec4(-final*abs(sin(t)),(-final*sin(t)*2.0),(final),1.0)*1.5;\n}"
        },
        "plasma": {
            "title": "Plasma",
            "src": "// Based on https://www.shadertoy.com/view/MdBGzK\n\n#define DPII (3.1415926535*2.0)\n\n// 0 -> Blue / Pink\n// 1 -> Blue / Green\n// 2 -> Black / White\n// 3 -> Blue / Teal / Black\n// 4 -> Black / White\nint GetPlasmaIndex(int t)\n{\n\treturn 0;\n}\n\nconst int initialL1[5] = int[5](1000, 1000, 3500, 1000, 1000);\nconst int initialL2[5] = int[5](2000, 2000, 1000, 2000, 2000);\nconst int initialL3[5] = int[5](3000, 4000, 3000, 3000, 3000);\nconst int initialL4[5] = int[5](4000, 4000, 1000, 4000, 4000);\n\nconst int initialK1[5] = int[5](3500, 1500, 3500, 3500, 3500);\nconst int initialK2[5] = int[5](2300, 2300, 3300, 2300, 2300);\nconst int initialK3[5] = int[5](3900, 3900, 2900, 3900, 3900);\nconst int initialK4[5] = int[5](3670, 1670, 2670, 3670, 3670);\n\nint GetC1(int nXOffset0or1, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\n\tint nResult = 0;\n\tif (nXOffset0or1 == 0)\n\t{\n\t\tnResult = initialK1[nPlasmaIndex] + (-3 * t);\n\t}\n\telse\n\t{\n\t\tnResult = initialL1[nPlasmaIndex] + (-1 * t);\n\t}\n\t\n\tfloat fResult = float(nResult);\n\tfResult = mod(fResult, 4096.0);\n\n\tif (fResult < 0.0)\n\t{\n\t\tfResult += 4096.0;\n\t}\n\tnResult = int(fResult);\n\n\treturn nResult;\n}\n\nint GetC2(int nXOffset0or1, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\n\tint nResult = 0;\n\tif (nXOffset0or1 == 0)\n\t{\n\t\tnResult = initialK2[nPlasmaIndex] + (-2 * t);\n\t}\n\telse\n\t{\n\t\tnResult = initialL2[nPlasmaIndex] + (-2 * t);\n\t}\n\t\n\tfloat fResult = float(nResult);\n\tfResult = mod(fResult, 4096.0);\n\n\tif (fResult < 0.0)\n\t{\n\t\tfResult += 4096.0;\n\t}\n\tnResult = int(fResult);\n\n\treturn nResult;\n}\n\nint GetC3(int nXOffset0or1, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\n\tint nResult = 0;\n\tif (nXOffset0or1 == 0)\n\t{\n\t\tnResult = initialK3[nPlasmaIndex] + (1 * t);\n\t}\n\telse\n\t{\n\t\tnResult = initialL3[nPlasmaIndex] + (2 * t);\n\t}\n\t\n\tfloat fResult = float(nResult);\n\tfResult = mod(fResult, 4096.0);\n\n\tif (fResult < 0.0)\n\t{\n\t\tfResult += 4096.0;\n\t}\n\tnResult = int(fResult);\n\n\treturn nResult;\n}\n\nint GetC4(int nXOffset0or1, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\n\tint nResult = 0;\n\tif (nXOffset0or1 == 0)\n\t{\n\t\tnResult = initialK4[nPlasmaIndex] + (2 * t);\n\t}\n\telse\n\t{\n\t\tnResult = initialL4[nPlasmaIndex] + (3 * t);\n\t}\n\t\n\tfloat fResult = float(nResult);\n\tfResult = mod(fResult, 4096.0);\n\n\tif (fResult < 0.0)\n\t{\n\t\tfResult += 4096.0;\n\t}\n\tnResult = int(fResult);\n\n\treturn nResult;\n}\n\nfloat Palette0_GetRed(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = fIndex;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t\ta = 63.0 - a;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 192.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette0_GetGreen(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette0_GetBlue(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = fIndex;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t\ta = 63.0 - a;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 192.0;\n\t\ta = 63.0 - a;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette1_GetRed(float fIndex)\n{\n\t\treturn 0.0;\n\t\t\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = fIndex;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t\ta = 63.0 - a;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 192.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette1_GetGreen(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t}\n\telse\n\t{\n\t\ta = 63.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette1_GetBlue(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 192.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette2_GetRed(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 2.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette2_GetGreen(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 2.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette2_GetBlue(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 2.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette3_GetRed(float fIndex)\n{\n\t\treturn 0.0;\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = fIndex;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = 63.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette3_GetGreen(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = fIndex - 128.0;\n\t\ta = 63.0 - a;\n\t}\n\telse\n\t{\n\t\ta = 0.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette3_GetBlue(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 64.0))\n\t{\n\t\ta = 0.0;\n\t}\n\telse if ((fIndex >= 64.0) && (fIndex < 128.0))\n\t{\n\t\ta = fIndex - 64.0;\n\t}\n\telse if ((fIndex >= 128.0) && (fIndex < 192.0))\n\t{\n\t\ta = 63.0;\n\t}\n\telse\n\t{\n\t\ta = 63.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette4_GetRed(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 75.0))\n\t{\n\t\ta = fIndex;\n\t\ta = 63.0 - a * 64.0 / 75.0;\n\t}\n\telse if ((fIndex >= 75.0) && (fIndex < 181.0))\n\t{\n\t\treturn 0.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 181.0;\n\t\ta = (a * 64.0 / 75.0) * 8.0 / 10.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette4_GetGreen(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 75.0))\n\t{\n\t\ta = fIndex;\n\t\ta = 63.0 - a * 64.0 / 75.0;\n\t}\n\telse if ((fIndex >= 75.0) && (fIndex < 181.0))\n\t{\n\t\treturn 0.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 181.0;\n\t\ta = (a * 64.0 / 75.0) * 9.0 / 10.0;\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\nfloat Palette4_GetBlue(float fIndex)\n{\n\tfloat a = 0.0;\n\tif ((fIndex >= 0.0) && (fIndex < 75.0))\n\t{\n\t\ta = fIndex;\n\t\ta = 63.0 - a * 64.0 / 75.0;\n\t}\n\telse if ((fIndex >= 75.0) && (fIndex < 181.0))\n\t{\n\t\treturn 0.0;\n\t}\n\telse\n\t{\n\t\ta = fIndex - 181.0;\n\t\ta = (a * 64.0 / 75.0);\n\t}\n\n\tfloat fResult = cos(a*(3.1415926535*2.0)/128.0+3.1415926535)*31.0+32.0;\n\tfResult /= 63.0;\n\n\treturn fResult;\n}\n\nfloat Palette_GetRed(float fIndex, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\tfloat fResult = 0.0;\n\n\tif (nPlasmaIndex == 0)\n\t{\n\t\tfResult = Palette0_GetRed(fIndex);\n\t}\n\telse if (nPlasmaIndex == 1)\n\t{\n\t\tfResult = Palette1_GetRed(fIndex);\n\t}\n\telse if (nPlasmaIndex == 2)\n\t{\n\t\tfResult = Palette2_GetRed(fIndex);\n\t}\n\telse if (nPlasmaIndex == 3)\n\t{\n\t\tfResult = Palette3_GetRed(fIndex);\n\t}\n\telse if (nPlasmaIndex == 4)\n\t{\n\t\tfResult = Palette4_GetRed(fIndex);\n\t}\n\n\treturn fResult;\n}\nfloat Palette_GetGreen(float fIndex, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\tfloat fResult = 0.0;\n\n\tif (nPlasmaIndex == 0)\n\t{\n\t\tfResult = Palette0_GetGreen(fIndex);\n\t}\n\telse if (nPlasmaIndex == 1)\n\t{\n\t\tfResult = Palette1_GetGreen(fIndex);\n\t}\n\telse if (nPlasmaIndex == 2)\n\t{\n\t\tfResult = Palette2_GetGreen(fIndex);\n\t}\n\telse if (nPlasmaIndex == 3)\n\t{\n\t\tfResult = Palette3_GetGreen(fIndex);\n\t}\n\telse if (nPlasmaIndex == 4)\n\t{\n\t\tfResult = Palette4_GetGreen(fIndex);\n\t}\n\n\treturn fResult;\n}\nfloat Palette_GetBlue(float fIndex, int t)\n{\n\tint nPlasmaIndex = GetPlasmaIndex(t);\n\tfloat fResult = 0.0;\n\n\tif (nPlasmaIndex == 0)\n\t{\n\t\tfResult = Palette0_GetBlue(fIndex);\n\t}\n\telse if (nPlasmaIndex == 1)\n\t{\n\t\tfResult = Palette1_GetBlue(fIndex);\n\t}\n\telse if (nPlasmaIndex == 2)\n\t{\n\t\tfResult = Palette2_GetBlue(fIndex);\n\t}\n\telse if (nPlasmaIndex == 3)\n\t{\n\t\tfResult = Palette3_GetBlue(fIndex);\n\t}\n\telse if (nPlasmaIndex == 4)\n\t{\n\t\tfResult = Palette4_GetBlue(fIndex);\n\t}\n\n\treturn fResult;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// t is an integer frame count.\n\tint t = int(iTime * 60.0);\n\n\t// fPlasmaX is a float from 0 to 319,\n\t// fPlasmaY is a float from 0 to 399.\n\tfloat fPlasmaX = (fragCoord.x / iResolution.x) * 319.0;\n\tfloat fPlasmaY = (fragCoord.y / iResolution.y) * 399.0;\n\tfPlasmaY = 399.0 - fPlasmaY;\n\n\tfloat fRed = 0.0;\n\tfloat fGreen = 0.0;\n\tfloat fBlue = 0.0;\n\n\tfloat fScreenX = fragCoord.x;\n\tfloat fScreenY = fragCoord.y;\n\tfloat ah = 0.0;\n\tfloat ccc = fPlasmaX / 4.0;\n\tfloat fOffset = 0.0;\n\tfloat bx = 0.0;\n\n\tint nXOffset0or1 = int(mod(fScreenX, 2.0));\n\t// On every odd row, toggle the x offset. This causes different plasma constants to be\n\t// read for these pixels, achieving a chequered overlay of two plasmas.\n\tint xor = int(mod(fScreenY, 2.0));\n\tif (xor == 1)\n\t{\n\t\tif (nXOffset0or1 == 0)\n\t\t{\n\t\t\tnXOffset0or1 = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnXOffset0or1 = 0;\n\t\t}\n\t}\n\n\tfloat c1 = float(GetC1(nXOffset0or1, t));\n\tfloat c2 = float(GetC2(nXOffset0or1, t));\n\tfloat c3 = float(GetC3(nXOffset0or1, t));\n\tfloat c4 = float(GetC4(nXOffset0or1, t));\n\n\tfOffset = ((fPlasmaY * 2.0) + (c2 * 2.0) - (ccc * 8.0) + (80.0 * 8.0)) / 2.0;\n\tbx = ((sin(fOffset*DPII/4096.0)*55.0+sin(fOffset*DPII/4096.0*4.0)*5.0+sin(fOffset*DPII/4096.0*17.0)*3.0+64.0)*16.0);\n\n\tfOffset = bx + c1 + (ccc * 8.0);\n\tah = (sin(fOffset*DPII/4096.0)*55.0+sin(fOffset*DPII/4096.0*6.0)*5.0+sin(fOffset*DPII/4096.0*21.0)*4.0+64.0);\n\n\tfOffset = ((fPlasmaY * 2.0) + (c4 * 2.0) + (ccc * 32.0)) / 2.0;\n\tbx = ((sin(fOffset*DPII/4096.0)*55.0+sin(fOffset*DPII/4096.0*5.0)*8.0+sin(fOffset*DPII/4096.0*15.0)*2.0+64.0)*8.0);\n\n\tfOffset = bx + (fPlasmaY * 2.0) + c3 - (ccc * 4.0) + (80.0 * 4.0);\n\tah += (sin(fOffset*DPII/4096.0)*55.0+sin(fOffset*DPII/4096.0*6.0)*5.0+sin(fOffset*DPII/4096.0*21.0)*4.0+64.0);\n\n\tfloat fPaletteIndex = ah;\n\n\tfRed = Palette_GetRed(fPaletteIndex, t);\n\tfGreen = Palette_GetGreen(fPaletteIndex, t);\n\tfBlue = Palette_GetBlue(fPaletteIndex, t);\n\n\tfragColor = vec4(fRed, fGreen, fBlue, 1.0);\n}\n"
        },
        "wobblyColorGrid": {
            "title": "Wobbly Color Grid",
            "src": "// Wobbly Color Grid\n// From http://glslsandbox.com/e#60808.1\n\n//  modded by Mik - v1.1\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//#extension GL_OES_standard_derivatives : enable\n\n//varying vec2 surfacePosition;\nuniform float time; // @@Time\nuniform vec2 center; // @@XyPad\nuniform vec2 resolution; // @@Resolution\n\nvoid main(void){\n\n    float PI = 3.141592;\n    vec2 p = gl_FragCoord.xy/resolution*2.;\n\n    float time = time + length(p)*cos(time/4. - .0001*length(p)*cos(time/PI + .0001*length(p)*cos(time*time/PI)));\n    vec3 color = vec3(0., length(p), 0.);\n\n    float f = 0.0;\n\n    for(float i = 0.0; i < 15.0; i++){\n        float s = sin(center.x + time + center.x * i * PI / 10.0) * .85;\n        float c = cos(center.y + time + center.y * i * PI / 10.0) * .93;\n\n        f += 0.001 / (abs(p.x + c / (.35+length(p))) * abs(p.y + s / (.35+length(p)))) / (.5+length(p));\n        color.r += s * 1.0 * PI;\n        color.b += c * 1.0 * PI;\n    }\n\n\n    gl_FragColor = vec4(vec3(f * color), 1.0);\n}"
        },
        "gadzooks": {
            "title": "Gadzooks",
            "src": "// Gadzooks\n// From: http://glslsandbox.com/e#43036.0\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nvoid main( void ) {\n\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    p = p * 2.0 - 1.0;\n    p.x *= resolution.x / resolution.y;\n\n    float col = 0.0;\n\n    //mandelbrote\n    //vec2 z = vec2(0.0, 0.0);\n    //juillaset\n    vec2 z = p;\n    vec2 ms = mouse.xy * 2.0 - 1.0;\n    ms.x *= resolution.x / resolution.y;\n\n    for(int i = 0; i < 5; i++)\n    {\n        //mandelbrote\n        z = vec2(z.x * z.x - z.y * z.y + cos(time) *2.0, 2.0 * z.x * z.y) + ms;\n        //julliaset\n        //z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + P;\n    }\n    col = length(z);\n\n    gl_FragColor = vec4(vec3(z.x, z.y, col), 1.0);\n\n}\n"
        },
        "faeriePulse": {
            "title": "Faerie Pulse",
            "src": "// Færie Pulse\n// From http://glslsandbox.com/e#46723\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n\nfloat rand(int seed, float ray) {\n  return mod(sin(float(seed)*1.0+ray*1.0)*1.0, 1.0);\n}\n\nmat2 rotate2d(float _angle) {\n  return mat2(cos(_angle), -sin(_angle), sin(_angle), cos(_angle));\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n  vec3 uv3 = vec3(sin(time*0.1), uv);\n  vec2 center = resolution / max(resolution.x, resolution.y) * 0.5;\n\n  //float a = rand(5234, uv.x)*6.2+time*5.0*(rand(2534, uv.y)-rand(3545, uv.x));\n  float a = distance(uv, center)*rand(5234, uv.x)-6.2*(rand(2534, uv.y));\n\n  float ac = cos(time*0.1-a);\n  float as = sin(time*0.1+a);\n  uv3 *= mat3(\n  ac, as, 0.0, -as, ac, 0.0, 0.0, 0.0, 1.0);\n  uv.x = uv3.x;\n  uv.y = uv3.y;\n  //uv = rotate2d(time*0.1)*uv;\n  uv = mod(uv, 0.5) * 2.0;\n  //uv.x = cos(time-a);\n  //uv.y = sin(time+a);\n  gl_FragColor = vec4(uv, cos(distance(uv, center)), 1.0);\n}\n"
        },
        "yasQueen": {
            "title": "Yas Queen",
            "src": "// Yas Queen\n// From http://glslsandbox.com/e#46613\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n// EXAMPLE FROM https://www.shadertoy.com/view/lstfRH\n#define PI 3.141592653589793\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvoid main( void ) {\n\n    vec3 col;\n    float x = gl_FragCoord.x + sin(time/PI) * resolution.x / 4.0;\n    float y = gl_FragCoord.y + cos(time/PI) * resolution.y / 2.0;\n    float hue = sin(x / resolution.x) + cos(y / resolution.y) + sin((x + y) / 500.0) + cos(sqrt(x * x + y * y) / 100.0);\n\n    col = hsv2rgb(vec3(hue + time/8.0, 1.0, mod(time, 1000.0)));\n\n    gl_FragColor = vec4(col, 1);\n}\n"
        },
        "circularDependency": {
            "title": "Circular Dependency",
            "src": "// Circular Dependency\n// From http://glslsandbox.com/e#56705\n\n/*\n * Original shader from: https://www.shadertoy.com/view/Wtf3zl\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time; // @@Time\nuniform vec2 resolution; // @@Resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/resolution.xy;\n    uv-=.5;\n    uv.x*= resolution.x/resolution.y;\n\n    vec3 col = vec3(0.5);\n    float d =length(uv)*20.;\n    float a = atan(uv.y, uv.x);\n    col.r = smoothstep(0.1, .2, abs(mod(d+time, 2.)-1.));\n\tcol.g = col.r*floor(mod(d*.5+.5+time*.5, 2.));\n    float f = smoothstep(-.1, .1,sin(a*3.+(sin(time*.5)*2.)*d-time));\n    col.rg = mix(1.-col.rg, col.rg, f);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n"
        },
        "fireball": {
            "title": "Fireball",
            "src": "// Fire Ball\n// From http://glslsandbox.com/e#61108.0\n\n// Fire ball by David Robles\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//#extension GL_OES_standard_derivatives : enable\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n\nconst float PI = 3.141592;\n\nuniform float conflagration; // @@Slider min=5 max=20 default=15.\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x);\n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n    vec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat circleShape(vec2 coord, vec2 pos){\n    float dist = distance(coord, pos);\n    return clamp(   log(dist*(15.+conflagration+4.*noise(vec2(time*.8))))  ,0.,1.);\n}\n\nvec2 sineWave(vec2 p){\n    float Ax = .05;\n    float wx = 1.50 * PI;\n    float x = sin(wx * p.x) * Ax * sin(noise(vec2(time)));\n\n    float Ay = .05;\n    float wy = PI * 10.;\n    float y = sin(wy*p.y) * Ay * noise(vec2(time));\n\n    return vec2(p.x + x, p.y + y);\n}\n\nvoid main( void ) {\n\n    vec2 pos = gl_FragCoord.xy / resolution.xy;\n    vec2 uv = pos;\n\n    uv += vec2(-.5, -.5);\n    uv *= vec2(2.3, 1.3);\n\n    float luz = clamp(1.05 - (pow(uv.x, 2.) + pow(uv.y * 1.6, 6.))*2., 0., 1.);\n    //vec3 color = vec3(0.3059, 0.1922, 0.0431);\n    vec3 color = vec3(0.7333, 0.2902, 0.0314);\n    //vec3 color = vec3(0.3882, 0.1686, 0.251);\n    float grad = circleShape(sineWave(pos), vec2(.5, .32));\n\n    float ruido = 0.;\n\n    pos *= 5.0;\n    float xoff = 1.05;\n    float yoff = 2.1;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    ruido = 0.7500*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido += 0.2500*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido += 0.5000*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido += 0.1250*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n\n\n    ruido = 0.5 + 0.5*ruido;\n    ruido = clamp(ruido, 0., 1.);\n\n    /////////////////////////////////////////////////////////////\n    pos = uv;\n    pos *= 3.0;\n    float ruido2 = 0.;\n    xoff = 1.5;\n    yoff = 1.5;\n    m = mat2( -2.1,  .5, -.5,  2.1 );\n    ruido2 = 0.2500*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido2 += 0.5000*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido2 += 0.1250*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido2 += 0.0625*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n\n    ruido2 = 0.5 + 0.5*ruido2;\n    ruido2 = clamp(ruido2, 0., 1.);\n\n    float f = 0.;\n    f += 1.0 - ( (1.0-luz) / (ruido2 + 0.001) );\n    f /= grad;\n    f /= ruido;\n\n    gl_FragColor = vec4(f*color*luz*(.5-.5*noise(vec2(time*.8))), 1.);\n    //gl_FragColor = vec4(color/grad, 1.);\n\n}"
        },
        "blueHearts": {
            "title": "Blue Hearts",
            "src": "// Blue Hearts\n// From https://www.shadertoy.com/view/wt2GWK\n\n#define t iTime\n\nvec2 hash22(vec2 p)\n{\n\treturn fract(sin(vec2(dot(p,vec2(263.135,198.742)),dot(p,vec2(624.235,321.217))))*13.635);\n}\n\nfloat vorohearts( vec2 x)\n{\n\tvec2 n = floor(-x);\n\tvec2 f = fract(-x);\n\n\tfloat md = 1.0;\n\n\tfor( int j=-1; j<=1; j++ )\n\t{\n\t\tfor( int i=-1; i<=1; i++ )\n\t\t{\n\t\t\tvec2  g = vec2(float(i), float(j));\n\t\t\tvec2  o = hash22( n + g );\n\t\t\tvec2  r = g - f + (.5+.5*sin(t+o*6.28));\n\t\t\tr.x *= .8*(1.+sin(.5+sin(6.*t))*.03);\n\t\t\tr.y *= .95+sin(1.5+sin(3.*t))*.07;\n\t\t\tr.y += .08;\n\t\t\tr.y -= sqrt(abs(r.x))*.52;\n\t\t\tfloat d = length(r);\n\t\t\tif( d < md ) {md = d;}\n\t\t}\n\t}\n\treturn md;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n\t//Heart uv\n\tuv = uv*3.;\n\tfloat d = vorohearts(uv);\n\td = smoothstep(.58, .25, d);\n\n\t//Heart color\n\tvec3 p = vec3(1.6*d*(.6+sin(.5+sin(6.*t))*.1), d*(1.8+sin(.5+sin(6.*t))*.3), 2.1*(1.+sin(.5+sin(6.*t))*.3));\n\tvec3 col = vec3(d) * p;\n\n\t//Background\n\tcol += vorohearts(uv) * .35 * p;\n\n\tfragColor = vec4(col,1.);\n}"
        },
        "blueSClues": {
            "title": "Blue's Clues",
            "src": "// Blue's Clues\n// From https://www.shadertoy.com/view/wljSzR\n\n// Sphere tracer by mzeo\n//\n// inspired by http://www.youtube.com/watch?v=kuesTvUYsSc#t=377\n//\n// waves by @hintz\n\n#ifdef GL_ES\nprecision mediump float;\nconst vec3 df = vec3(0.05, 0.0, 0.0);\n#else\nconst vec3 df = vec3(0.01, 0.0, 0.0);\n#endif\n\n#define AUTO_CAMERA\n\n// input\n\n// Constants\n// Camera\nconst vec3 origin = vec3(0, 0, 0);\nconst int steps = 128;\nconst vec3 sun = vec3(1.0, .5, -1.0);\n\nconst int miterations = 32;\n\n// Ball\nstruct Ball\n{\n    vec3 pos;\n    float size;\n};\n\nconst Ball ball = Ball(vec3(0, 0, 5), 0.5);\n\nstruct Balls\n{\n    vec3 dir;\n    vec3 p;\n    float dist;\n};\n\nconst Balls balls = Balls(vec3(1, 0, 0), vec3(0, 0, 0), 1.0);\n\n// Floor\n\nstruct Plane\n{\n    vec3 n;\n    float d;\n};\n\nconst Plane plane = Plane(vec3(0, 1, 0), -1.0);\n\n// Distance\nstruct Dist\n{\n    float dist;\n    int id;\n};\n\n\nDist and(Dist a, Dist b)\n{\n    if (a.dist < b.dist)\n    {\n        return a;\n    }\n\n    return b;\n}\n\nDist fBall(Ball ball, vec3 p)\n{\n    return Dist(length(ball.pos - p) - ball.size, 0);\n}\n\nBall get(Balls balls, float t)\n{\n    float a = abs(mod(t, 6.0) - 3.0);\n    vec3 p = balls.p + balls.dir * t * balls.dist + a * a * vec3(0, -0.15, 0);\n    return Ball(p, ball.size);\n}\n\nDist fBalls(Balls balls, vec3 p)\n{\n    float t = dot(p - balls.p, balls.dir) / balls.dist;\n    float t0 = t - fract(t + fract(iTime) * 2.0);\n    float t1 = t0 + 1.0;\n\n    return and(\n    fBall(get(balls, t0), p),\n    fBall(get(balls, t1), p));\n}\n\nDist fPlane(Plane plane, vec3 p)\n{\n    return Dist(dot(plane.n, p) - plane.d - 0.4*cos(length(p.xz) - iTime), 1);\n}\n\nDist f(vec3 p)\n{\n    return and(\n    fBalls(balls, p),\n    fPlane(plane, p));\n}\n\nvec3 grad(vec3 p)\n{\n    float f0 = f(p).dist;\n\n    return normalize(vec3(\n    f(p + df.xyz).dist,\n    f(p + df.yxz).dist,\n    f(p + df.yzx).dist) - f0);\n}\n\nfloat mandel(vec2 c)\n{\n    vec2 z = c;\n\n    for(int i = 0; i < miterations; ++i)\n    {\n        z = vec2(z.x*z.x - z.y*z.y, 1.5*z.x*z.y) + c;\n        if (length(z) > 40.0) return float(i) / float(miterations);\n    }\n\n    return 0.0;\n}\n\nvec3 floorTexture(vec3 p)\n{\n    mat2 rot = mat2(vec2(1, 1), vec2(1, -1));\n    vec2 c = rot * (p.xz + vec2(-0.7, -1.0)) * 0.2;\n    float i = mandel(c);\n    return clamp(vec3(i * 10.0, i * i *10.0, i*i*i*5.0).zyx, vec3(0,0,0), vec3(2,2,2));\n}\n\n\nvec4 shade(vec3 p, vec3 ray, int id)\n{\n    vec3 n = grad(p);\n    float diffuse = clamp(dot(normalize(sun), n), 0.0, 1.0);\n\n    vec3 color;\n    float ref;\n\n    if (id == 0)\n    {\n        color = vec3(0,1,0);\n        ref = 0.1;\n    }\n    else\n    {\n        color = floorTexture(p);\n        ref = 0.5;\n    }\n\n    return vec4(color * diffuse, 1) * ref;\n}\n\nvec4 combine(vec4 a, vec4 b)\n{\n    return a + b * (1.0 - a.w);\n}\n\nvec4 sky(vec3 ray)\n{\n    float sun = dot(ray, normalize(sun));\n    sun = (sun > 0.0) ? pow(sun, 150.0) * 3.0 : 0.0;\n    float horizon = 1.0 - abs(ray.y);\n    vec3 blue = vec3(0.1, 0.3, 0.6);\n    vec3 red = vec3(0.6, 0.3, 0.) * 2.0;\n    return vec4(vec3(0.9, 0.8, 0.5) * sun + blue * horizon + red * pow(horizon, 8.0), 1);\n}\n\nvec4 trace(vec3 origin, vec3 ray)\n{\n    vec3 p = origin;\n    Dist dist = Dist(10.0, 2);\n    vec4 result = vec4(0, 0, 0, 0);\n\n    for(int i = 0; i < steps; ++i)\n    {\n        dist = f(p);\n        if (dist.dist > 0.01)\n        {\n            p += ray * dist.dist;\n            float absorb = exp(-dist.dist * 0.05);\n            vec4 s = sky(ray) * (1.0 - absorb);\n\n            result = combine(result, s);\n        }\n        else if (result.w < 0.99)\n        {\n            vec3 n = grad(p);\n            vec4 s = shade(p, ray, dist.id);\n            ray = reflect(ray, n);\n            p += n * 0.01;\n\n            result = combine(result, s);\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    return combine(result, sky(ray));\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float scale = 2.0 / max(iResolution.x, iResolution.y);\n    vec3 ray = vec3((fragCoord.xy - iResolution.xy / 2.0) * scale, 1);\n\n    //#ifdef AUTO_CAMERA\n    float yaw = cos(iTime) * -0.25 + 0.1;\n    float angle = iTime * 0.5;\n    //#else\n    //float yaw = iMouse.y - 0.15;\n    //float angle = iMouse.x * 8.0;\n    //#endif\n\n    vec3 from = (vec3(sin(angle), 0, cos(angle)) * cos(yaw) + vec3(0, sin(yaw) * 1.0, 0)) * 5.0;\n    //vec3 from = origin + vec3((iMouse.xy - vec2(0.5,0.0)) * vec2(15.0, 3.0), -5);\n    vec3 to = vec3(0, -1, 0);\n    vec3 up = vec3(0, 1, 0);\n    vec3 dir = normalize(to - from);\n    vec3 left = normalize(cross(up, dir));\n    mat3 rot = mat3(left, cross(dir, left), dir);\n\n    fragColor = trace(from, rot * normalize(ray));\n}"
        },
        "checkerboard": {
            "title": "Checkerboard",
            "src": "// Checkerboard\n\nuniform float checkerboardSize = 10.0; // @@Slider min=.001 max=1 default=.125\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = floor(fragCoord / checkerboardSize);\n    vec3 patternMask = vec3(mod(pos.x + mod(pos.y, 2.0), 2.0));\n    fragColor = vec4(patternMask.xy, 1., 1.);\n}"
        },
        "danceyCubes": {
            "title": "Dancey Cubes",
            "src": "// Dancey Cubes\n\nuniform float mysterNumber;\n\nvec3 palette(float d){\n    return mix(vec3(0.2,0.7,0.9),vec3(1.,0.,1.),d);\n}\n\nvec2 rotate(vec2 p,float a){\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p){\n    for( int i = 0; i<8; ++i){\n        float t = iTime*0.2;\n        p.xz =rotate(p.xz,t);\n        p.xy =rotate(p.xy,t*mysterNumber);\n        p.xz = abs(p.xz);\n        p.xz-=.5;\n    }\n    return dot(sign(p),p)/5.;\n}\n\nvec4 rm (vec3 ro, vec3 rd){\n    float t = 0.;\n    vec3 col = vec3(0.);\n    float d;\n    for(float i =0.; i<64.; i++){\n        vec3 p = ro + rd*t;\n        d = map(p)*.5;\n        if(d<0.02){\n            break;\n        }\n        if(d>100.){\n            break;\n        }\n        //col+=vec3(0.6,0.8,0.8)/(400.*(d));\n        col+=palette(length(p)*.1)/(400.*(d));\n        t+=d;\n    }\n    return vec4(col,1./(d*100.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n    vec3 ro = vec3(0.,0.,-50.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cf,cs));\n\n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n\n    vec3 rd = normalize(uuv-ro);\n\n    vec4 col = rm(ro,rd);\n\n\n    fragColor = col;\n    fragColor.a = 1.;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"fractal pyramid\",\n\t\"description\": \"coding my new screensaver\",\n\t\"model\": \"car\"\n}\n*/"
        },
        "plaid": {
            "title": "Plaid",
            "src": "// Plaid\n\n// #extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n\nuniform float time;\nuniform vec2 resolution;\n\nvoid main( void ) {\n\n    vec2 position = ( gl_FragCoord.xy / resolution.xy ) + 4.0;\n\n    float color = 0.0;\n    color += sin( position.x * cos( time / 15.0 ) * 80.0 ) + cos( position.y * cos( time / 15.0 ) * 10.0 );\n    color += sin( position.y * sin( time / 10.0 ) * 40.0 ) + cos( position.x * sin( time / 25.0 ) * 40.0 );\n    color += sin( position.x * sin( time / 5.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 80.0 );\n    color *= sin( time / 10.0 ) * 0.5;\n\n    gl_FragColor = vec4( vec3( color, color * 0.2, sin( color + time / 9.0 ) * 0.69 ), 9.0 );\n\n}"
        },
        "quiver": {
            "title": "Quiver",
            "src": "// Quiver\n\nuniform float twist; // @@Slider default=.2 min=-4 max=4\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// Playing around with simplex noise and polar-coords with a lightning-themed\n// scene.\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (in float degree)\n{\n    float rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n    return mat2 (vec2 (c, s),vec2 (-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{\n    p = vec2 (dot (p, vec2 (127.1, 311.7)),\n    dot (p, vec2 (269.5, 183.3)));\n\n    return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n    vec2 i = floor (p + (p.x + p.y)*K1);\n\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n    vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n    dot (b, hash (i + o)),\n    dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (70.));\n}\n\nfloat fbm (in vec2 p)\n{\n    mat2 rot = r2d (27.5);\n    float d = noise (p); p *= rot;\n    d += .5*noise (p); p *= rot;\n    d += .25*noise (p); p *= rot;\n    d += .125*noise (p); p *= rot;\n    d += .0625*noise (p);\n    d /= (1. + .5 + .25 + .125 + .0625);\n    return .5 + .5*d;\n}\n\nvec2 mapToScreen (in vec2 p, in float scale)\n{\n    vec2 res = p;\n    res = res * 2. - 1.;\n    res.x *= iResolution.x / iResolution.y;\n    res *= scale;\n\n    return res;\n}\n\nvec2 cart2polar (in vec2 cart)\n{\n    float r = length (cart);\n    float phi = atan (cart.y, cart.x);\n    return vec2 (r, phi);\n}\n\nvec2 polar2cart (in vec2 polar)\n{\n    float x = polar.x*cos (polar.y);\n    float y = polar.x*sin (polar.y);\n    return vec2 (x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = mapToScreen (fragCoord.xy/iResolution.xy, 2.5);\n\n    uv *= r2d (12.*iTime);\n    float len = length (uv);\n    float thickness = .25;\n    float haze = 2.5;\n\n    // distort UVs a bit\n    uv = cart2polar (uv);\n    uv.y += twist * (.5 + .5*sin(cos (uv.x)*len));\n    uv = polar2cart (uv);\n\n    float d1 = abs ((uv.x*haze)*thickness / (uv.x + fbm (uv + 1.25*iTime)));\n    float d2 = abs ((uv.y*haze)*thickness / (uv.y + fbm (uv - 1.5*iTime)));\n    float d3 = abs ((uv.x*uv.y*haze)*thickness / (uv.x*uv.y + fbm (uv - 2.*iTime)));\n    vec3 col = vec3 (.0);\n    float size = .075;\n    col += d1*size*vec3 (.1, .8, 2.);\n    col += d2*size*vec3 (2., .1, .8);\n    col += d3*size*vec3 (.8, 2., .1);\n\n    fragColor = vec4 (col, 1.);\n}\n"
        },
        "spaceRings": {
            "title": "Space Rings",
            "src": "// Space Rings\n\n#define time iTime*1.25\n#define p0 0.5, 0.5, 0.5,  0.5, 0.5, 0.5,  1.0, 1.0, 1.0,  0.0, 0.33, 0.67\n\nconst float numParticles = 25.;\nconst float numRings = 5.;\nconst float offsetMult = 30.;\nconst float tau = 6.23813;\n\nvec3 palette( in float t, in float a0, in float a1, in float a2, in float b0, in float b1, in float b2,\nin float c0, in float c1, in float c2,in float d0, in float d1, in float d2)\n{\n    return vec3(a0,a1,a2) + vec3(b0,b1,b2)*cos( tau*(vec3(c0,c1,c2)*t+vec3(d0,d1,d2)) );\n}\n\nvec3 particleColor(vec2 uv, float radius, float offset, float periodOffset)\n{\n    vec3 color = palette(.4 + offset / 4., p0);\n    uv /= pow(periodOffset, .75) * sin(periodOffset * iTime) + sin(periodOffset + iTime);\n    vec2 pos = vec2(cos(offset * offsetMult + time + periodOffset),\n    sin(offset * offsetMult + time * 5. + periodOffset * tau));\n\n    float dist = radius / distance(uv, pos);\n    return color * pow(dist, 2.) * 1.75;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 3.45;\n\n    fragColor = vec4(0., 0., 0., 1.);\n\n    for (float n = 0.; n <= numRings; n++)\n    {\n        for (float i = 0.; i <= numParticles; i++) {\n            fragColor.rgb += particleColor(uv, .03, i / numParticles, n / 2.);\n        }\n    }\n}"
        },
        "waves": {
            "title": "Waves",
            "src": "// Beat Waves\n// Adapted from http://glslsandbox.com/e#61168.1\n\n//#extension GL_OES_standard_derivatives : enable\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\nuniform float frequency = 6.28; // @@Slider min=3.14 max=25 default=15\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\nvoid main( void ) {\n\n    vec2 position = ( gl_FragCoord.xy / resolution.xy );\n    position.x -= .5;\n    float num = 2.0;\n\n    vec3 color = vec3(\n    sin(frequency * position.x + 0.0 + time) * 0.5 + 0.5 - sin(beatInfo.beat * 3.14) * .5,\n    sin(frequency * position.x * (sin(beatInfo.intensity) * .2 + 1.) + 2.0 + time) * 0.5 + 0.5,\n    sin(frequency * position.x + 4.0 + time) * 0.5 + 0.5 + sin(time * 4.)\n    );\n    // color = vec3(1.0);\n\n    color += vec3(position.y * 2.0 - 1.0);\n\n    color = vec3(\n    floor(color.r * num - 0.5) / num + 0.5,\n    floor(color.g * num - 0.5) / num + 0.5,\n    floor(color.b * num - 0.5) / num + 0.5\n    );\n\n    gl_FragColor = vec4( color, 1.0 );\n\n}"
        },
        "huerthquake": {
            "title": "Huerthquake",
            "src": "// Huearthquake\n// From http://glslsandbox.com/e#46400\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265358\n#define TWO_PI 6.28318530718\n\nuniform vec2 resolution;\nuniform float time;\n\nvec3 colorA = vec3(0.149, 0.141, 0.912);\nvec3 colorB = vec3(1.000, 0.833, 0.224);\n\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n/* Coordinate and unit utils */\nvec2 coord(in vec2 p) {\n    p = p / resolution.xy;\n    // correct aspect ratio\n    if (resolution.x > resolution.y) {\n        p.x *= resolution.x / resolution.y;\n        p.x += (resolution.y - resolution.x) / resolution.y / 2.0;\n    } else {\n        p.y *= resolution.y / resolution.x;\n        p.y += (resolution.x - resolution.y) / resolution.x / 2.0;\n    }\n    // centering\n    p -= 0.5;\n    p *= vec2(-1.0, 1.0);\n    return p;\n}\n#define rx 1.0 / min(resolution.x, resolution.y)\n#define uv gl_FragCoord.xy / resolution.xy\n#define st coord(gl_FragCoord.xy)\n#define mx coord(u_mouse)\n\nmat2 rot(in float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle),  cos(angle));\n}\n\nfloat wave(in vec2 pt, in float f, in float v) {\n    float r = length(pt);\n    float a = atan(pt.y, pt.x);\n    return sin(r * TWO_PI * f - v * time);\n}\n\nvoid main() {\n    vec2 pt = st;\n\n    float f = 10.0 * abs(sin(0.1 * time));\n    float v = 10.0;\n    float g = wave(pt, f, v);\n\n    for (float k = 0.0; k < 8.0; k++) {\n        float t = PI / 4.0 * k;\n        vec2 offset = 0.5 * vec2(cos(t), sin(t));\n        g += wave(pt + offset, f, v);\n    }\n\n    g *= 0.5;\n    g = step(g, 0.0);\n\n    vec3 rgb = mix(colorA, colorB, g);\n\n    gl_FragColor = vec4(rgb, 1.0);\n}\n"
        },
        "solidColor": {
            "title": "Solid Color",
            "src": "// Solid Color.glsl\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec4 color; // @@ColorPicker default=#3300ff\nuniform float colorBrightness; // @@Slider default=.75\nuniform float sparkliness; // @@Slider default=0 max=.5\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123 + time);\n}\n\nvoid main() {\n    gl_FragColor = color * colorBrightness\n        + ((sparkliness < random(gl_FragCoord.xy / resolution.xy)) ? vec4(0.) : vec4(1.));\n}"
        },
        "sunsetClouds": {
            "title": "Sunset Clouds",
            "src": "//Cloud Ten\n//by nimitz 2015 (twitter: @stormoid)\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define time iTime\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat moy = 0.;\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rz.x, rz.y, fp.z );\n}\n\nfloat fbm(in vec3 x)\n{\n    float rz = 0.;\n    float a = .35;\n    for (int i = 0; i<2; i++)\n    {\n        rz += noise(x)*a;\n        a*=.35;\n        x*= 4.;\n    }\n    return rz;\n}\n\nfloat path(in float x){ return sin(x*0.01-3.1415)*28.+6.5; }\nfloat map(vec3 p){\n    return p.y*0.07 + (fbm(p*0.3)-0.1) + sin(p.x*0.24 + sin(p.z*.01)*7.)*0.22+0.15 + sin(p.z*0.08)*0.05;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n    float precis = .3;\n    float h= 1.;\n    float d = 0.;\n    for( int i=0; i<17; i++ )\n    {\n        if( abs(h)<precis || d>70. ) break;\n        d += h;\n        vec3 pos = ro+rd*d;\n        pos.y += .5;\n\t    float res = map(pos)*7.;\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 lgt = vec3(0);\nfloat mapV( vec3 p ){ return clamp(-map(p), 0., 1.);}\nvec4 marchV(in vec3 ro, in vec3 rd, in float t, in vec3 bgc)\n{\n\tvec4 rz = vec4( 0.0 );\n\t\n\tfor( int i=0; i<150; i++ )\n\t{\n\t\tif(rz.a > 0.99 || t > 200.) break;\n\t\t\n\t\tvec3 pos = ro + t*rd;\n        float den = mapV(pos);\n        \n        vec4 col = vec4(mix( vec3(.8,.75,.85), vec3(.0), den ),den);\n        col.xyz *= mix(bgc*bgc*2.5,  mix(vec3(0.1,0.2,0.55),vec3(.8,.85,.9),moy*0.4), clamp( -(den*40.+0.)*pos.y*.03-moy*0.5, 0., 1. ) );\n        col.rgb += clamp((1.-den*6.) + pos.y*0.13 +.55, 0., 1.)*0.35*mix(bgc,vec3(1),0.7); //Fringes\n        col += clamp(den*pos.y*.15, -.02, .0); //Depth occlusion\n        col *= smoothstep(0.2+moy*0.05,.0,mapV(pos+1.*lgt))*.85+0.15; //Shadows\n        \n\t\tcol.a *= .95;\n\t\tcol.rgb *= col.a;\n\t\trz = rz + col*(1.0 - rz.a);\n\n        t += max(.3,(2.-den*30.)*t*0.011);\n\t}\n\n\treturn clamp(rz, 0., 1.);\n}\n\nfloat pent(in vec2 p){    \n    vec2 q = abs(p);\n    return max(max(q.x*1.176-p.y*0.385, q.x*0.727+p.y), -p.y*1.237)*1.;\n}\n\nvec3 lensFlare(vec2 p, vec2 pos)\n{\n\tvec2 q = p-pos;\n    float dq = dot(q, q);\n    vec2 dist = p*(length(p))*0.75;\n\tfloat ang = atan(q.x,q.y);\n    vec2 pp = mix(p, dist, 0.5);\n    float sz = 0.01;\n    float rz = pow(abs(fract(ang*.8+.12)-0.5),3.)*(noise(ang*15.))*0.5;\n    rz *= smoothstep(1.0, 0.0, dot(q,q));\n    rz *= smoothstep(0.0, 0.01, dot(q,q));\n    rz += max(1.0/(1.0 + 30.0*pent(dist + 0.8*pos)),.0)*0.17;\n\trz += clamp(sz-pow(pent(pp + 0.15*pos),1.55),.0, 1.)*5.0;\n\trz += clamp(sz-pow(pent(pp + 0.1*pos),2.4),.0, 1.)*4.0;\n\trz += clamp(sz-pow(pent(pp - 0.05*pos),1.2),.0, 1.)*4.0;\n    rz += clamp(sz-pow(pent((pp + .5*pos)),1.7),.0, 1.)*4.0;\n    rz += clamp(sz-pow(pent((pp + .3*pos)),1.9),.0, 1.)*3.0;\n    rz += clamp(sz-pow(pent((pp - .2*pos)),1.3),.0, 1.)*4.0;\n    return vec3(clamp(rz,0.,1.));\n}\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nvec2 uv;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 q = fragCoord.xy / iResolution.xy;\n    uv = fragCoord.xy;\n    vec2 p = q - 0.5;\n\tfloat asp =iResolution.x/iResolution.y;\n    p.x *= asp;\n\tvec2 mo = iMouse.xy / iResolution.xy;\n\tmoy = mo.y;\n    float st = sin(time*0.3-1.3)*0.2;\n    vec3 ro = vec3(0.,-2.+sin(time*.3-1.)*2.,time*30.);\n    ro.x = path(ro.z);\n    vec3 ta = ro + vec3(0,0,1);\n    vec3 fw = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), fw ));\n    vec3 vv = normalize(cross(fw,uu));\n    const float zoom = 1.;\n    vec3 rd = normalize( p.x*uu + p.y*vv + -zoom*fw );\n    \n    float rox = sin(time*0.2)*0.6+2.9;\n    rox += smoothstep(0.6,1.2,sin(time*0.25))*3.5;\n   \tfloat roy = sin(time*0.5)*0.2;\n    mat3 rotation = rot_x(-roy)*rot_y(-rox+st*1.5)*rot_z(st);\n\tmat3 inv_rotation = rot_z(-st)*rot_y(rox-st*1.5)*rot_x(roy);\n    rd *= rotation;\n    rd.y -= dot(p,p)*0.06;\n    rd = normalize(rd);\n    \n    vec3 col = vec3(0.);\n    lgt = normalize(vec3(-0.3,mo.y+0.1,1.));  \n    float rdl = clamp(dot(rd, lgt),0.,1.);\n  \n    vec3 hor = mix( vec3(.9,.6,.7)*0.35, vec3(.5,0.05,0.05), rdl );\n    hor = mix(hor, vec3(.5,.8,1),mo.y);\n    col += mix( vec3(.2,.2,.6), hor, exp2(-(1.+ 3.*(1.-rdl))*max(abs(rd.y),0.)) )*.6;\n    col += .8*vec3(1.,.9,.9)*exp2(rdl*650.-650.);\n    col += .3*vec3(1.,1.,0.1)*exp2(rdl*100.-100.);\n    col += .5*vec3(1.,.7,0.)*exp2(rdl*50.-50.);\n    col += .4*vec3(1.,0.,0.05)*exp2(rdl*10.-10.);  \n    vec3 bgc = col;\n    \n    float rz = march(ro,rd);\n    \n    if (rz < 70.)\n    {   \n        vec4 res = marchV(ro, rd, rz-5., bgc);\n    \tcol = col*(1.0-res.w) + res.xyz;\n    }\n    \n    vec3 proj = (-lgt*inv_rotation);\n    col += 1.4*vec3(0.7,0.7,0.4)*clamp(lensFlare(p,-proj.xy/proj.z*zoom)*proj.z,0., 1.);\n    \n    float g = smoothstep(0.03,.97,mo.x);\n    col = mix(mix(col,col.brg*vec3(1,0.75,1),clamp(g*2.,0.0,1.0)), col.bgr, clamp((g-0.5)*2.,0.0,1.));\n    \n\tcol = clamp(col, 0., 1.);\n    col = col*0.5 + 0.5*col*col*(3.0-2.0*col); //saturation\n    col = pow(col, vec3(0.416667))*1.055 - 0.055; //sRGB\n\tcol *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 ); //Vign\n\n\tfragColor = vec4( col, 1.0 );\n}"
        },
        "oceanClouds": {
            "title": "Ocean Clouds",
            "src": "// Clouds: slice based volumetric height-clouds with god-rays, density, sun-radiance/shadow\n// and \n// Water: simple reflecting sky/sun and cloud shaded height-modulated waves\n//\n// Created by Frank Hugenroth 03/2013\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// noise and raymarching based on concepts and code from shaders by inigo quilez\n//\n\n// some variables to change :)\n\n#define RENDER_GODRAYS    1    // set this to 1 to enable god-rays\n//#define RENDER_GODRAYS    0    // disable god-rays\n\n#define RENDER_CLOUDS 1\n#define RENDER_WATER   1\n\nfloat waterlevel = 70.0;        // height of the water\nfloat wavegain   = 1.0;       // change to adjust the general water wave level\nfloat large_waveheight = 1.0; // change to adjust the \"heavy\" waves (set to 0.0 to have a very still ocean :)\nfloat small_waveheight = 1.0; // change to adjust the small waves\n\nvec3 fogcolor    = vec3( 0.5, 0.7, 1.1 );              \nvec3 skybottom   = vec3( 0.6, 0.8, 1.2 );\nvec3 skytop      = vec3(0.05, 0.2, 0.5);\nvec3 reflskycolor= vec3(0.025, 0.10, 0.20);\nvec3 watercolor  = vec3(0.2, 0.25, 0.3);\n\nvec3 light       = normalize( vec3(  0.1, 0.25,  0.9 ) );\n\n\n\n\n\n\n\n\n\n// random/hash function              \nfloat hash( float n )\n{\n  return fract(cos(n)*41415.92653);\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\n\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\n\n// Fractional Brownian motion\nfloat fbm( vec3 p )\n{\n  float f = 0.5000*noise( p ); p = m*p*1.1;\n  f += 0.2500*noise( p ); p = m*p*1.2;\n  f += 0.1666*noise( p ); p = m*p;\n  f += 0.0834*noise( p );\n  return f;\n}\n\nmat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\n// Fractional Brownian motion\nfloat fbm( vec2 p )\n{\n  float f = 0.5000*noise( p ); p = m2*p;\n  f += 0.2500*noise( p ); p = m2*p;\n  f += 0.1666*noise( p ); p = m2*p;\n  f += 0.0834*noise( p );\n  return f;\n}\n\n\n// this calculates the water as a height of a given position\nfloat water( vec2 p )\n{\n  float height = waterlevel;\n\n  vec2 shift1 = 0.001*vec2( iTime*160.0*2.0, iTime*120.0*2.0 );\n  vec2 shift2 = 0.001*vec2( iTime*190.0*2.0, -iTime*130.0*2.0 );\n\n  // coarse crossing 'ocean' waves...\n  float wave = 0.0;\n  wave += sin(p.x*0.021  + shift2.x)*4.5;\n  wave += sin(p.x*0.0172+p.y*0.010 + shift2.x*1.121)*4.0;\n  wave -= sin(p.x*0.00104+p.y*0.005 + shift2.x*0.121)*4.0;\n  // ...added by some smaller faster waves...\n  wave += sin(p.x*0.02221+p.y*0.01233+shift2.x*3.437)*5.0;\n  wave += sin(p.x*0.03112+p.y*0.01122+shift2.x*4.269)*2.5 ;\n  wave *= large_waveheight;\n  wave -= fbm(p*0.004-shift2*.5)*small_waveheight*24.;\n  // ...added by some distored random waves (which makes the water looks like water :)\n\n  float amp = 6.*small_waveheight;\n  shift1 *= .3;\n  for (int i=0; i<7; i++)\n  {\n    wave -= abs(sin((noise(p*0.01+shift1)-.5)*3.14))*amp;\n    amp *= .51;\n    shift1 *= 1.841;\n    p *= m2*0.9331;\n  }\n  \n  height += wave;\n  return height;\n}\n\n\n// cloud intersection raycasting\nfloat trace_fog(in vec3 rStart, in vec3 rDirection )\n{\n#ifdef RENDER_CLOUDS\n  // makes the clouds moving...\n  vec2 shift = vec2( iTime*80.0, iTime*60.0 );\n  float sum = 0.0;\n  // use only 12 cloud-layers ;)\n  // this improves performance but results in \"god-rays shining through clouds\" effect (sometimes)...\n  float q2 = 0., q3 = 0.;\n  for (int q=0; q<10; q++)\n  {\n    float c = (q2+350.0-rStart.y) / rDirection.y;// cloud distance\n    vec3 cpos = rStart + c*rDirection + vec3(831.0, 321.0+q3-shift.x*0.2, 1330.0+shift.y*3.0); // cloud position\n    float alpha = smoothstep(0.5, 1.0, fbm( cpos*0.0015 )); // cloud density\n\tsum += (1.0-sum)*alpha; // alpha saturation\n    if (sum>0.98)\n        break;\n    q2 += 120.;\n    q3 += 0.15;\n  }\n  \n  return clamp( 1.0-sum, 0.0, 1.0 );\n#else\n  return 1.0;\n#endif\n}\n\n// fog and water intersection function.\n// 1st: collects fog intensity while traveling\n// 2nd: check if hits the water surface and returns the distance\nbool trace(in vec3 rStart, in vec3 rDirection, in float sundot, out float fog, out float dist)\n{\n  float h = 20.0;\n  float t = 0.0;\n  float st = 1.0;\n  float alpha = 0.1;\n  float asum = 0.0;\n  vec3 p = rStart;\n\t\n  for( int j=1000; j<1120; j++ )\n  {\n    // some speed-up if all is far away...\n    if( t>500.0 ) \n      st = 2.0;\n    else if( t>800.0 ) \n      st = 5.0;\n    else if( t>1000.0 ) \n      st = 12.0;\n\n    p = rStart + t*rDirection; // calc current ray position\n\n#ifdef RENDER_GODRAYS\n    if (rDirection.y>0. && sundot > 0.001 && t>400.0 && t < 2500.0)\n    {\n      alpha = sundot * clamp((p.y-waterlevel)/waterlevel, 0.0, 1.0) * st * 0.024*smoothstep(0.80, 1.0, trace_fog(p,light));\n      asum  += (1.0-asum)*alpha;\n      if (asum > 0.9)\n        break;\n    }\n#endif\n\n    h = p.y - water(p.xz);\n\n    if( h<0.1 ) // hit the water?\n    {\n      dist = t; \n      fog = asum;\n      return true;\n    }\n\n    if( p.y>450.0 ) // lost in space? quit...\n      break;\n    \n    // speed up ray if possible...    \n    if(rDirection.y > 0.0) // look up (sky!) -> make large steps\n      t += 30.0 * st;\n    else\n      t += max(1.0,1.0*h)*st;\n  }\n\n  dist = t; \n  fog = asum;\n  if (h<10.0)\n   return true;\n  return false;\n}\n\n\nvec3 camera( float time )\n{\n  return vec3( 500.0 * sin(1.5+1.57*time), 0.0, 1200.0*time );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n  vec2 s = xy*vec2(1.75,1.0);\n\n  // get camera position and view direction\n  float time = (iTime+13.5+44.)*.05;\n  vec3 campos = camera( time );\n  vec3 camtar = camera( time + 0.4 );\n  campos.y = max(waterlevel+30.0, waterlevel+90.0 + 60.0*sin(time*2.0));\n  camtar.y = campos.y*0.5;\n\n  float roll = 0.14*sin(time*1.2);\n  vec3 cw = normalize(camtar-campos);\n  vec3 cp = vec3(sin(roll), cos(roll),0.0);\n  vec3 cu = normalize(cross(cw,cp));\n  vec3 cv = normalize(cross(cu,cw));\n  vec3 rd = normalize( s.x*cu + s.y*cv + 1.6*cw );\n\n  float sundot = clamp(dot(rd,light),0.0,1.0);\n\n  vec3 col;\n  float fog=0.0, dist=0.0;\n\n  if (!trace(campos,rd,sundot, fog, dist))\n  {\n    // render sky\n    float t = pow(1.0-0.7*rd.y, 15.0);\n    col = 0.8*(skybottom*t + skytop*(1.0-t));\n    // sun\n    col += 0.47*vec3(1.6,1.4,1.0)*pow( sundot, 350.0 );\n    // sun haze\n    col += 0.4*vec3(0.8,0.9,1.0)*pow( sundot, 2.0 );\n\n#ifdef RENDER_CLOUDS\n    // CLOUDS\n    vec2 shift = vec2( iTime*80.0, iTime*60.0 );\n    vec4 sum = vec4(0,0,0,0); \n    for (int q=1000; q<1100; q++) // 100 layers\n    {\n      float c = (float(q-1000)*12.0+350.0-campos.y) / rd.y; // cloud height\n      vec3 cpos = campos + c*rd + vec3(831.0, 321.0+float(q-1000)*.15-shift.x*0.2, 1330.0+shift.y*3.0); // cloud position\n      float alpha = smoothstep(0.5, 1.0, fbm( cpos*0.0015 ))*.9; // fractal cloud density\n      vec3 localcolor = mix(vec3( 1.1, 1.05, 1.0 ), 0.7*vec3( 0.4,0.4,0.3 ), alpha); // density color white->gray\n      alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer's density, the more the higher layers will be hidden)\n      sum += vec4(localcolor*alpha, alpha); // sum up weightened color\n      \n      if (sum.w>0.98)\n        break;\n    }\n    float alpha = smoothstep(0.7, 1.0, sum.w);\n    sum.rgb /= sum.w+0.0001;\n\n    // This is an important stuff to darken dense-cloud parts when in front (or near)\n    // of the sun (simulates cloud-self shadow)\n    sum.rgb -= 0.6*vec3(0.8, 0.75, 0.7)*pow(sundot,13.0)*alpha;\n    // This brightens up the low-density parts (edges) of the clouds (simulates light scattering in fog)\n    sum.rgb += 0.2*vec3(1.3, 1.2, 1.0)* pow(sundot,5.0)*(1.0-alpha);\n\n    col = mix( col, sum.rgb , sum.w*(1.0-t) );\n#endif\n\n    // add god-rays\n    col += vec3(0.5, 0.4, 0.3)*fog;\n  }\n  else\n  {\n#ifdef RENDER_WATER        \n    //  render water\n    \n    vec3 wpos = campos + dist*rd; // calculate position where ray meets water\n\n    // calculate water-mirror\n    vec2 xdiff = vec2(0.1, 0.0)*wavegain*4.;\n    vec2 ydiff = vec2(0.0, 0.1)*wavegain*4.;\n\n    // get the reflected ray direction\n    rd = reflect(rd, normalize(vec3(water(wpos.xz-xdiff) - water(wpos.xz+xdiff), 1.0, water(wpos.xz-ydiff) - water(wpos.xz+ydiff))));  \n    float refl = 1.0-clamp(dot(rd,vec3(0.0, 1.0, 0.0)),0.0,1.0);\n  \n    float sh = smoothstep(0.2, 1.0, trace_fog(wpos+20.0*rd,rd))*.7+.3;\n    // water reflects more the lower the reflecting angle is...\n    float wsky   = refl*sh;     // reflecting (sky-color) amount\n    float wwater = (1.0-refl)*sh; // water-color amount\n\n    float sundot = clamp(dot(rd,light),0.0,1.0);\n\n    // watercolor\n\n    col = wsky*reflskycolor; // reflecting sky-color \n    col += wwater*watercolor;\n    col += vec3(.003, .005, .005) * (wpos.y-waterlevel+30.);\n\n    // Sun\n    float wsunrefl = wsky*(0.5*pow( sundot, 10.0 )+0.25*pow( sundot, 3.5)+.75*pow( sundot, 300.0));\n    col += vec3(1.5,1.3,1.0)*wsunrefl; // sun reflection\n\n#endif\n\n    // global depth-fog\n    float fo = 1.0-exp(-pow(0.0003*dist, 1.5));\n    vec3 fco = fogcolor + 0.6*vec3(0.6,0.5,0.4)*pow( sundot, 4.0 );\n    col = mix( col, fco, fo );\n\n    // add god-rays\n    col += vec3(0.5, 0.4, 0.3)*fog; \n  }\n\n  fragColor=vec4(col,1.0);\n}\n\n\n"
        },
        "electricEelUniverse": {
            "title": "Electric Eel Universe",
            "src": "// CC0: Electric Eel Universe\n//  Saturday tinkering with an old failed shader\n//  Turned out a bit better today\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 rayCylinder(vec3 ro, vec3 rd, vec3 cb, vec3 ca, float cr) {\n  vec3  oc = ro - cb;\n  float card = dot(ca,rd);\n  float caoc = dot(ca,oc);\n  float a = 1.0 - card*card;\n  float b = dot( oc, rd) - caoc*card;\n  float c = dot( oc, oc) - caoc*caoc - cr*cr;\n  float h = b*b - a*c;\n  if( h<0.0 ) return vec2(-1.0); //no intersection\n  h = sqrt(h);\n  return vec2(-b-h,-b+h)/a;\n}\n\n// License: Unknown, author: Unknown, found: shadertoy somewhere, don't remember where\nfloat dfcos(float x) {\n  return sqrt(x*x+1.0)*0.8-1.8;\n}\n\n// License: Unknown, author: Unknown, found: shadertoy somewhere, don't remember where\nfloat dfcos(vec2 p, float freq) {\n  float x = p.x;\n  float y = p.y;\n  x *= freq;\n    \n  float x1 = abs(mod(x+PI,TAU)-PI);\n  float x2 = abs(mod(x   ,TAU)-PI);\n    \n  float a = 0.18*freq;\n    \n  x1 /= max( y*a+1.0-a,1.0);\n  x2 /= max(-y*a+1.0-a,1.0);\n  return (mix(-dfcos(x2)-1.0,dfcos(x1)+1.0,clamp(y*0.5+0.5,0.0,1.0)))/max(freq*0.8,1.0)+max(abs(y)-1.0,0.0)*sign(y);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 l = normalize(vec3(0.0, 0., -1.0));\n  vec3 baseCol = hsv2rgb(vec3(0.6, 0.95, .0025));\n  return baseCol/(1.00001+dot(rd, l));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  const float rdd = 2.0;\n  const float mm = 4.0;\n  const float rep = 27.0;\n\n  vec3 rd = normalize(-p.x*uu + p.y*vv + rdd*ww);\n  \n  vec3 skyCol = skyColor(ro, rd);\n\n  rd.yx *= ROT(0.1*TIME);\n\n  vec3 col = skyCol;\n\n  // I read somewhere that if you call atan in a shader you got no business writing shader code.\n  //  I even call it in a loop :)\n  float a = atan(rd.y, rd.x);\n  for(float i = 0.0; i < mm; ++i) {\n    float ma = a;\n    float sz = rep+i*6.0;\n    float slices = TAU/sz; \n    float na = mod1(ma, slices);\n\n    float h1 = hash(na+13.0*i+123.4);\n    float h2 = fract(h1*3677.0);\n    float h3 = fract(h1*8677.0);\n\n    float tr = mix(0.5, 3.0, h1);\n    vec2 tc = rayCylinder(ro, rd, ro, vec3(0.0, 0.0, 1.0), tr);\n    vec3 tcp = ro + tc.y*rd;\n    vec2 tcp2 = vec2(tcp.z, atan(tcp.y, tcp.x));\n  \n    float zz = mix(0.025, 0.05, sqrt(h1))*rep/sz;\n    float tnpy = mod1(tcp2.y, slices);\n    float fo = smoothstep(0.5*slices, 0.25*slices, abs(tcp2.y));\n    tcp2.x += -h2*TIME;\n    tcp2.y *= tr*PI/3.0;\n\n    tcp2/=zz;\n    float d = dfcos(tcp2, 2.0*zz);\n//    float d = tcp2.y;\n    d = abs(d);\n    d *= zz;\n\n    vec3 bcol = (1.0+cos(vec3(0.0, 1.0, 2.0)+TAU*h3+0.5*h2*h2*tcp.z))*0.00005;\n    bcol /= max(d*d, 0.000+5E-7*tc.y*tc.y);\n    bcol *= exp(-0.04*tc.y*tc.y);\n    bcol *= smoothstep(-0.5, 1.0, sin(mix(0.125, 1.0, h2)*tcp.z));\n    bcol *= fo;\n    col += bcol;\n  }\n\n  return col;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float tm = 1.5*TIME+12.3;\n  vec3 ro   = vec3(0.0, 0.0, tm);\n  vec3 dro  = normalize(vec3(1.0, 0.0, 3.0));\n  dro.xz *= ROT(0.2*sin(0.05*tm));\n  dro.yz *= ROT(0.2*sin(0.05*tm*sqrt(0.5)));\n  const vec3 up = vec3(0.0,1.0,0.0);\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = (cross(ww, uu));\n  vec3 col = color(ww, uu, vv, ro, p);\n  col -= 0.125*vec3(0.0, 1.0, 2.0).yzx*length(pp);\n  col = aces_approx(col);\n  col = sRGB(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, pp);\n  fragColor = vec4(col, 1.0);\n}\n\n"
        },
        "rainbows": {
            "title": "Rainbows",
            "src": "float circle(vec2 pos, vec2 pixel, float radius) {\n    return smoothstep(radius, radius * 0.6, distance(pos, pixel));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 rgb = vec3(0.);\n    \n    float frequency = 2.;\n    float amplitude = 0.2;\n    float speed = 2.;\n    float rh = 0.07;\n\n    float sr = (sin((iTime * speed) + uv.x * frequency)) * amplitude;\n    float sg = (sin(((iTime + .2) * speed) + uv.x * frequency)) * amplitude;\n    float sb = (sin(((iTime + .4) * speed) + uv.x * frequency)) * amplitude;\n    \n    sr += cos((iTime + sin(uv.x)) * .6) * 0.2;\n    sg += cos((iTime + sin(uv.x)) * .6) * 0.2;\n    sb += cos((iTime + sin(uv.x)) * .6) * 0.2;\n    \n    rgb.r += smoothstep(sr + rh, sr, uv.y) - smoothstep(sr, sr - rh, uv.y);\n    rgb.g += smoothstep(sg + rh, sg, uv.y) - smoothstep(sg, sg - rh, uv.y);\n    rgb.b += smoothstep(sb + rh, sb, uv.y) - smoothstep(sb, sb - rh, uv.y);\n    \n\n    for(float i = 0.; i < 45.; i++) {\n    \tfloat cx = cos((iTime * cos(clamp(iTime * 0.019, 0.7, 0.8)) * 2.) + i * 0.08) * 0.8;\n    \tfloat cy = sin((iTime * sin(clamp(iTime * 0.01, 0.8, 0.9)) * 1.2) + i * 0.06) * 0.4;    \n        \n\t    rgb += circle(vec2(cx, cy), uv, 0.05) * 0.97;\n    }    \n\n    fragColor = vec4(rgb,1.0);\n}"
        },
        "voronoi": {
            "title": "Voronoi",
            "src": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// I've not seen anybody out there computing correct cell interior distances for Voronoi\n// patterns yet. That's why they cannot shade the cell interior correctly, and why you've\n// never seen cell boundaries rendered correctly. \n//\n// However, here's how you do mathematically correct distances (note the equidistant and non\n// degenerated grey isolines inside the cells) and hence edges (in yellow):\n//\n// https://iquilezles.org/articles/voronoilines\n//\n// More Voronoi shaders:\n//\n// Exact edges:  https://www.shadertoy.com/view/ldl3W8\n// Hierarchical: https://www.shadertoy.com/view/Xll3zX\n// Smooth:       https://www.shadertoy.com/view/ldB3zc\n// Voronoise:    https://www.shadertoy.com/view/Xd23Dh\n\n#define ANIMATE\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\t//return textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n\t\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xx;\n\n    vec3 c = voronoi( 8.0*p );\n\n\t// isolines\n    vec3 col = c.x*(0.5 + 0.5*sin(64.0*c.x))*vec3(1.0);\n    // borders\t\n    col = mix( vec3(1.0,0.6,0.0), col, smoothstep( 0.04, 0.07, c.x ) );\n    // feature points\n\tfloat dd = length( c.yz );\n\tcol = mix( vec3(1.0,0.6,0.1), col, smoothstep( 0.0, 0.12, dd) );\n\tcol += vec3(1.0,0.6,0.1)*(1.0-smoothstep( 0.0, 0.04, dd));\n\n\tfragColor = vec4(col,1.0);\n}\n"
        },
        "voxelEdges": {
            "title": "Voxel Edges",
            "src": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// Shading technique explained here:\n//\n// https://iquilezles.org/articles/voxellines\n\n\n\n// consider replacing this by a proper noise function\n// float noise( in vec3 x )\n// {\n//     vec3 p = floor(x);\n//     vec3 f = fract(x);\n// \tf = f*f*(3.0-2.0*f);\n// \tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n// \tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n// \treturn mix( rg.x, rg.y, f.z );\n// }\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\nfloat mapTerrain( vec3 p )\n{\n\tp *= 0.1; \n\tp.xz *= 0.6;\n\t\n\tfloat time = 0.5 + 0.15*iTime;\n\tfloat ft = fract( time );\n\tfloat it = floor( time );\n\tft = smoothstep( 0.7, 1.0, ft );\n\ttime = it + ft;\n\tfloat spe = 1.4;\n\t\n\tfloat f;\n    f  = 0.5000*noise( p*1.00 + vec3(0.0,1.0,0.0)*spe*time );\n    f += 0.2500*noise( p*2.02 + vec3(0.0,2.0,0.0)*spe*time );\n    f += 0.1250*noise( p*4.01 );\n\treturn 25.0*f-10.0;\n}\n\nvec3 gro = vec3(0.0);\n\nfloat map(in vec3 c) \n{\n\tvec3 p = c + 0.5;\n\t\n\tfloat f = mapTerrain( p ) + 0.25*p.y;\n\n    f = mix( f, 1.0, step( length(gro-p), 5.0 ) );\n\n\treturn step( f, 0.5 );\n}\n\nvec3 lig = normalize( vec3(-0.4,0.3,0.7) );\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nvec3 path( float t, float ya )\n{\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x, 18.0 + ya*4.0*sin(0.05*t), p.y );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nfloat maxcomp( in vec4 v )\n{\n    return max( max(v.x,v.y), max(v.z,v.w) );\n}\n\nfloat isEdge( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wb = smoothstep( 0.85, 0.99, vec4(uv.x,\n                                           st.x,\n                                           uv.y,\n                                           st.y) ) * ( 1.0 - va + va*vc );\n    // corners\n    vec4 wc = smoothstep( 0.85, 0.99, vec4(uv.x*uv.y,\n                                           st.x*uv.y,\n                                           st.x*st.y,\n                                           uv.x*st.y) ) * ( 1.0 - vb + vd*vb );\n    return maxcomp( max(wb,wc) );\n}\n\nfloat calcOcc( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;\n\n    // corners\n    vec4 wb = vec4(uv.x*uv.y,\n                   st.x*uv.y,\n                   st.x*st.y,\n                   uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\n    \n    return wa.x + wa.y + wa.z + wa.w +\n           wb.x + wb.y + wb.z + wb.w;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n\t\n    // raymarch\t\n\tvec3 vos, dir;\n\tfloat t = castRay( ro, rd, vos, dir );\n\tif( t>0.0 )\n\t{\n        vec3 nor = -dir*sign(rd);\n        vec3 pos = ro + rd*t;\n        vec3 uvw = pos - vos;\n\t\t\n\t\tvec3 v1  = vos + nor + dir.yzx;\n\t    vec3 v2  = vos + nor - dir.yzx;\n\t    vec3 v3  = vos + nor + dir.zxy;\n\t    vec3 v4  = vos + nor - dir.zxy;\n\t\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\n        vec3 v6  = vos + nor - dir.yzx + dir.zxy;\n\t    vec3 v7  = vos + nor - dir.yzx - dir.zxy;\n\t    vec3 v8  = vos + nor + dir.yzx - dir.zxy;\n\t    vec3 v9  = vos + dir.yzx;\n\t    vec3 v10 = vos - dir.yzx;\n\t    vec3 v11 = vos + dir.zxy;\n\t    vec3 v12 = vos - dir.zxy;\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\n\n\t\tvec4 vc = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\n\t    vec4 vd = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\n\t    vec4 va = vec4( map(v9),  map(v10), map(v11), map(v12) );\n\t    vec4 vb = vec4( map(v13), map(v14), map(v15), map(v16) );\n\t\t\n\t\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\t\n        // wireframe\n        float www = 1.0 - isEdge( uv, va, vb, vc, vd );\n        \n        vec3 wir = smoothstep( 0.4, 0.5, abs(uvw-0.5) );\n        float vvv = (1.0-wir.x*wir.y)*(1.0-wir.x*wir.z)*(1.0-wir.y*wir.z);\n\n        col = vec3(0.5);\n        col += 0.8*vec3(0.1,0.3,0.4);\n        col *= 1.0 - 0.75*(1.0-vvv)*www;\n\t\t\n        // lighting\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n        float sky = 0.5 + 0.5*nor.y;\n        float amb = clamp(0.75 + pos.y/25.0,0.0,1.0);\n        float occ = 1.0;\n\t\n        // ambient occlusion\n        occ = calcOcc( uv, va, vb, vc, vd );\n        occ = 1.0 - occ/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n        occ *= amb;\n\n        // lighting\n        vec3 lin = vec3(0.0);\n        lin += 2.5*dif*vec3(1.00,0.90,0.70)*(0.5+0.5*occ);\n        lin += 0.5*bac*vec3(0.15,0.10,0.10)*occ;\n        lin += 2.0*sky*vec3(0.40,0.30,0.15)*occ;\n\n        // line glow\t\n        float lineglow = 0.0;\n        lineglow += smoothstep( 0.4, 1.0,     uv.x )*(1.0-va.x*(1.0-vc.x));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.x )*(1.0-va.y*(1.0-vc.y));\n        lineglow += smoothstep( 0.4, 1.0,     uv.y )*(1.0-va.z*(1.0-vc.z));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.y )*(1.0-va.w*(1.0-vc.w));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y*      uv.x )*(1.0-vb.x*(1.0-vd.x));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y* (1.0-uv.x))*(1.0-vb.y*(1.0-vd.y));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-vb.z*(1.0-vd.z));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*     uv.x )*(1.0-vb.w*(1.0-vd.w));\n\t\t\n        vec3 linCol = 2.0*vec3(5.0,0.6,0.0);\n        linCol *= (0.5+0.5*occ)*0.5;\n        lin += 3.0*lineglow*linCol;\n\t\t\n        col = col*lin;\n        col += 8.0*linCol*vec3(1.0,2.0,3.0)*(1.0-www);//*(0.5+1.0*sha);\n        col += 0.1*lineglow*linCol;\n        col *= min(0.1,exp( -0.07*t ));\n\t\n        // blend to black & white\t\t\n        // vec3 col2 = vec3(1.3)*(0.5+0.5*nor.y)*occ*www*(0.9+0.1*vvv)*exp( -0.04*t );;\n        // float mi = sin(-1.57+0.5*iTime);\n        // mi = smoothstep( 0.70, 0.75, mi );\n        // col = mix( col, col2, mi );\n\t}\n\n\t// gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.z<=0.00001 ) mo=vec2(0.0);\n\t\n\tfloat time = 2.0*iTime + 50.0*mo.x;\n    // camera\n\tfloat cr = 0.2*cos(0.1*iTime);\n\tvec3 ro = path( time+0.0, 1.0 );\n\tvec3 ta = path( time+5.0, 1.0 ) - vec3(0.0,6.0,0.0);\n\tgro = ro;\n\n    mat3 cam = setCamera( ro, ta, cr );\n\t\n\t// build ray\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( cam * vec3(p.xy,-2.5) );\n\n    vec3 col = render( ro, rd );\n    \n\t// vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tfloat time = 1.0*iTime;\n\n    float cr = 0.0;\n\tvec3 ro = path( time+0.0, 0.0 ) + vec3(0.0,0.7,0.0);\n\tvec3 ta = path( time+2.5, 0.0 ) + vec3(0.0,0.7,0.0);\n\n    mat3 cam = setCamera( ro, ta, cr );\n\n    vec3 col = render( ro + cam*fragRayOri, cam*fragRayDir );\n    \n    fragColor = vec4( col, 1.0 );\n}"
        },
        "octagrams": {
            "title": "Octagrams",
            "src": "precision highp float;\n\n\nfloat gTime = 0.;\nconst float REPEAT = 5.0;\n\n// 回転行列\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat box(vec3 pos, float scale) {\n\tpos *= scale;\n\tfloat base = sdBox(pos, vec3(.4,.4,.1)) /1.5;\n\tpos.xy *= 5.;\n\tpos.y -= 3.5;\n\tpos.xy *= rot(.75);\n\tfloat result = -base;\n\treturn result;\n}\n\nfloat box_set(vec3 pos, float iTime) {\n\tvec3 pos_origin = pos;\n\tpos = pos_origin;\n\tpos .y += sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box1 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\n\tpos = pos_origin;\n\tpos .y -=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box2 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\n\tpos = pos_origin;\n\tpos .x +=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box3 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\t\n\tpos = pos_origin;\n\tpos .x -=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box4 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\t\n\tpos = pos_origin;\n\tpos.xy *=   rot(.8);\n\tfloat box5 = box(pos,.5) * 6.;\t\n\tpos = pos_origin;\n\tfloat box6 = box(pos,.5) * 6.;\t\n\tfloat result = max(max(max(max(max(box1,box2),box3),box4),box5),box6);\n\treturn result;\n}\n\nfloat map(vec3 pos, float iTime) {\n\tvec3 pos_origin = pos;\n\tfloat box_set1 = box_set(pos, iTime);\n\n\treturn box_set1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 ro = vec3(0., -0.2 ,iTime * 4.);\n\tvec3 ray = normalize(vec3(p, 1.5));\n\tray.xy = ray.xy * rot(sin(iTime * .03) * 5.);\n\tray.yz = ray.yz * rot(sin(iTime * .05) * .2);\n\tfloat t = 0.1;\n\tvec3 col = vec3(0.);\n\tfloat ac = 0.0;\n\n\n\tfor (int i = 0; i < 99; i++){\n\t\tvec3 pos = ro + ray * t;\n\t\tpos = mod(pos-2., 4.) -2.;\n\t\tgTime = iTime -float(i) * 0.01;\n\t\t\n\t\tfloat d = map(pos, iTime);\n\n\t\td = max(abs(d), 0.01);\n\t\tac += exp(-d*23.);\n\n\t\tt += d* 0.55;\n\t}\n\n\tcol = vec3(ac * 0.02);\n\n\tcol +=vec3(0.,0.2 * abs(sin(iTime)),0.5 + sin(iTime) * 0.2);\n\n\n\tfragColor = vec4(col ,1.0 - t * (0.02 + 0.02 * sin (iTime)));\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Octgrams\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/"
        },
        "randomSin": {
            "title": "Random Sin",
            "src": "// https://www.shadertoy.com/view/lfdSDX\n\n#define PI 3.14\n\nvec3 bgColorDown = vec3(0.2, 0.1, 0.1);\nvec3 bgColorUp = vec3(0.1, 0.1, 0.2);\n\nvec3 P1ColorIn = vec3(1.0, 0.5, 0.0);\nvec3 P1ColorOut = vec3(1.0, 0.0, 0.0);\n\nvec3 P2ColorIn = vec3(0.0, 0.5, 1.0);  //vec3(1.0, 1.0, 1.0);\nvec3 P2ColorOut = vec3(0.0, 0.0, 1.0); //vec3(0.0, 0.5, 1.0);\nfloat surfaceSpeed = 0.5;\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n\tfloat bg = (cos(uv.x*3.14159*2.0) + sin((uv.y)*3.14159)) * 0.15;\n\t\n\tvec2 p = uv*2.0 - 1.0;\n\tp *= 15.0;\n\tvec2 sfunc = vec2(p.x, p.y + 5.0*sin(uv.x*10.0-iTime*2.0)+2.0*cos(uv.x*25.0+iTime*12.0));\n\tsfunc.y *= uv.x*2.0+0.05;\n\tsfunc.y *= 2.0 - uv.x*2.0+0.05;\n\tsfunc.y /= 0.1; // Thickness fix\n\t\n\tvec3 c = vec3(sfunc.y);\n\n\tfragColor = vec4(c,1.0);\n}"
        },
        "diveToCloud": {
            "title": "Dive to Cloud",
            "src": "// https://www.shadertoy.com/view/ll3SWl\n// referred https://www.shadertoy.com/view/4sXGRM\n\nvec3 skytop = vec3(0.05, 0.2, 0.5);\n\nvec3 light = normalize(vec3(0.1, 0.25, 0.9));\n\nvec2 cloudrange = vec2(0.0, 10000.0);\n\nmat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\n// hash function              \nfloat hash(float n)\n{\n    return fract(cos(n) * 114514.1919);\n}\n\n// 3d noise function\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = smoothstep(0.0, 1.0, fract(x));\n        \n    float n = p.x + p.y * 10.0 + p.z * 100.0;\n    \n    return mix(\n        mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n            mix(hash(n + 10.0), hash(n + 11.0), f.x), f.y),\n        mix(mix(hash(n + 100.0), hash(n + 101.0), f.x),\n            mix(hash(n + 110.0), hash(n + 111.0), f.x), f.y), f.z);\n}\n\n// Fractional Brownian motion\nfloat fbm(vec3 p)\n{\n    float f = 0.5000 * noise(p);\n    p = m * p;\n    f += 0.2500 * noise(p);\n    p = m * p;\n    f += 0.1666 * noise(p);\n    p = m * p;\n    f += 0.0834 * noise(p);\n    return f;\n}\n\nvec3 camera(float time)\n{\n    return vec3(5000.0 * sin(1.0 * time), 5000. + 1500. * sin(0.5 * time), 6000.0 * time);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float time = (iTime + 13.5 + 44.) * 1.0;\n    vec3 campos = camera(time);\n    vec3 camtar = camera(time + 0.4);\n\n    vec3 front = normalize(camtar - campos);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    vec3 fragAt = normalize(uv.x * right + uv.y * up + front);\n    \n    // clouds\n    vec4 sum = vec4(0, 0, 0, 0);\n    for (float depth = 0.0; depth < 100000.0; depth += 200.0)\n    {\n        vec3 ray = campos + fragAt * depth;\n        if (cloudrange.x < ray.y && ray.y < cloudrange.y)\n        {\n            float alpha = smoothstep(0.5, 1.0, fbm(ray * 0.00025));\n            vec3 localcolor = mix(vec3(1.1, 1.05, 1.0), vec3(0.3, 0.3, 0.2), alpha);\n            alpha = (1.0 - sum.a) * alpha;\n            sum += vec4(localcolor * alpha, alpha);\n        }\n    }\n    \n    float alpha = smoothstep(0.7, 1.0, sum.a);\n    sum.rgb /= sum.a + 0.0001;\n\n    float sundot = clamp(dot(fragAt, light), 0.0, 1.0);\n    vec3 col = 0.8 * (skytop);\n    col += 0.47 * vec3(1.6, 1.4, 1.0) * pow(sundot, 350.0);\n    col += 0.4 * vec3(0.8, 0.9, 1.0) * pow(sundot, 2.0);\n    \n    sum.rgb -= 0.6 * vec3(0.8, 0.75, 0.7) * pow(sundot, 13.0) * alpha;\n    \n    sum.rgb += 0.2 * vec3(1.3, 1.2, 1.0) * pow(sundot, 5.0) * (1.0 - alpha);\n\n    col = mix(col, sum.rgb, sum.a);\n\n    fragColor = vec4(col, 1.0);\n}"
        },
        "sincos3d": {
            "title": "sincos 3d",
            "src": "// https://www.shadertoy.com/view/XfXGz4\n\n#define A(v) mat2(cos(m.v+radians(vec4(0, -90, 90, 0))))  // rotate\n#define W(v) length(vec3(p.yz-v(p.x+vec2(0, pi_2)+t), 0))-lt  // wave\n//#define W(v) length(p-vec3(round(p.x*pi)/pi, v(t+p.x), v(t+pi_2+p.x)))-lt  // wave\n#define P(v) length(p-vec3(0, v(t), v(t+pi_2)))-pt  // point\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float lt = .1, // line thickness\n          pt = .3, // point thickness\n          pi = 3.1416,\n          pi2 = pi*2.,\n          pi_2 = pi/2.,\n          t = iTime*pi,\n          s = 1., d = 0., i = d;\n    vec2 R = iResolution.xy,\n         m = (iMouse.xy-.5*R)/R.y*4.;\n    vec3 o = vec3(0, 0, -7), // cam\n         u = normalize(vec3((U-.5*R)/R.y, 1)),\n         c = vec3(0), k = c, p;\n    if (iMouse.z < 1.) m = -vec2(t/20.-pi_2, 0);\n    mat2 v = A(y), h = A(x); // pitch & yaw\n    for (; i++<50.;) // raymarch\n    {\n        p = o+u*d;\n        p.yz *= v;\n        p.xz *= h;\n        p.x -= 3.;\n        if (p.y < -1.5) p.y = 2./p.y;\n        k.x = min( max(p.x+lt, W(sin)), P(sin) );\n        k.y = min( max(p.x+lt, W(cos)), P(cos) );\n        s = min(s, min(k.x, k.y));\n        if (s < .001 || d > 100.) break;\n        d += s*.5;\n    }\n    c = max(cos(d*pi2) - s*sqrt(d) - k, 0.);\n    c.gb += .1;\n    C = vec4(c*.4 + c.brg*.6 + c*c, 1);\n}"
        },
        "midCentury": {
            "title": "MidCentury",
            "src": "// https://www.shadertoy.com/view/mtyGWy\n\n/* This animation is the material of my first youtube tutorial about creative \n   coding, which is a video in which I try to introduce programmers to GLSL \n   and to the wonderful world of shaders, while also trying to share my recent \n   passion for this community.\n                                       Video URL: https://youtu.be/f4s1h2YETNY\n*/\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//https://www.shadertoy.com/view/mtyGWy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}"
        },
        "monitorsAndFractalLife": {
            "title": "monitors and fractal_life",
            "src": "// https://www.shadertoy.com/view/lfKSR1\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define time iTime\n#define resolution iResolution.xy\nfloat tanh2(float x) {\n    float ex = exp(2.0 * x);\n    return ((ex - 1.) / (ex + 1.));\n}\n\nvec2 tanh2(vec2 x) {\n    vec2 ex = exp(2.0 * x);\n    return ((ex - 1.) / (ex + 1.));\n}\n\n// --------[ Original ShaderToy begins here ]---------- //\n#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nfloat ths(float a, float b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec2 thc(float a, vec2 b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\n\nvec2 ths(float a, vec2 b) {\n    return tanh(a * sin(b)) / tanh(a);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\nvec4 se(vec2 p) {\n//\tp.x += time*0.3;\n//\tp.y += sin(time*0.3);\n\tp = mod(p + 1.0, 2.0) - 1.0;\n\t\n\tfloat s = 100000.0;\n\tfloat c = 100000.0;\n\tfloat t=sin(time*0.2);\n\tfor(int i = 0; i < 9; i++) {\n\t\tp = abs(p)/clamp(dot(p, p), t, t+2.0) - vec2(0.5, 0.3);\n\t\ts = min(s, length(p));\n\t\tc = min(c, abs(p.y));\n\t}\n\t\n\tvec3 col = mix(vec3(0, 1, 1), vec3(0.1, 0.5, 1.0), smoothstep(0.0, 0.1, s));\n\tcol = mix(col, vec3(1.2, 1.0, 0.4), smoothstep(0.0, 1.0, c));\n\t\n\treturn vec4(col, s);\n}\n\nvec3 normal(vec2 p) {\n\tvec2 h = vec2(0.006, 0.0);\n\t\n\tvec3 n = vec3(\n\t\tse(p + h.xy).w - se(p - h.xy).w,\n\t\tse(p + h.yx).w - se(p - h.yx).w,\n\t\t-0.04);\n\t\n\treturn normalize(n);\n}\n\nvec3 render(vec2 p) {\n\tvec3 nor = normal(p);\n\tvec3 rd = normalize(vec3(p, 1.0));\n\n\t\n\tvec3 col = vec3(dot(nor, -rd));\n\tcol += clamp(pow(dot(nor, -rd), 32.0), 0.0, 1.0);\n//\tcol += 0.5*clamp(pow(1.0 + dot(rd, nor), 1.0), 0.0, 1.0);\n\tcol *= se(p).xyz;\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n vec2 uv = fragCoord/iResolution.xy-0.5;\n\tvec2 p = uv;\n\t vec2 uv2 = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv2.y += -0.2 * cos(0.2 * iTime);\n    uv2.x += -0.2 * sin(0.2 * iTime);\n    float a = atan(uv2.y, uv2.x);\n    float r = length(uv2);\n\n    float sc = 12. + 1. * cos(10. * uv.x + iTime);\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    float v = h21(ipos);\n    float t = 11. * v + iTime;\n    vec2 p2 = cos(t) * 0.2 * vec2(cos(2. * v * t), sin(2. * (1.-v) * t));\n    float d = mlength(fpos - p2);\n    float k = 0.5 + 0.4 * cos(t);\n    float s = smoothstep(-k,k, 0.25 + 0.25 * thc(4., 20. * v + iTime) - d);\n    s *= 2. * s;\n    vec3 col = step(d, 0.45) * pal(1. * mlength(uv) + 0.08 * fract(s + atan(fpos.y, fpos.x)/pi + t) - 0.2 * t, vec3(0.6), vec3(0.6), vec3(1.), 0.22 * (1. + cos(ceil(4. * v) * s + t)) * vec3(0.,0.33,0.66));\n    \n   \n\t\n\tvec3 col2 = render(p);\n\t\n\n\tcol2 = pow(abs(col2*col), vec3(1.2));\n\tfragColor = vec4(col2, 1);\n}"
        },
        "discoteq2": {
            "title": "Discoteq 2",
            "src": "// https://www.shadertoy.com/view/DtXfDr\n\n#define S smoothstep\n\nvec4 Line(vec2 uv, float speed, float height, vec3 col) {\n    uv.y += S(1., 0., abs(uv.x)) * sin(iTime * speed + uv.x * height) * .2;\n    return vec4(S(.06 * S(.2, .9, abs(uv.x)), 0., abs(uv.y) - .004) * col, 1.0) * S(1., .3, abs(uv.x));\n}\n\nvoid mainImage(out vec4 O, in vec2 I) {\n    vec2 uv = (I - .5 * iResolution.xy) / iResolution.y;\n    O = vec4 (0.);\n    for (float i = 0.; i <= 5.; i += 1.) {\n        float t = i / 5.;\n        O += Line(uv, 1. + t, 4. + t, vec3(.2 + t * .7, .2 + t * .4, 0.3));\n    }\n}"
        },
        "devilGlass": {
            "title": "Devil Glass",
            "src": "// https://www.shadertoy.com/view/lcV3Rz\n\n// alternative version of my shader from Revision24 showdown final\n// original version:\n// https://livecode.demozoo.org/event/2024_03_29_shader_showdown_revision_2024.html\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat gyroid (vec3 p) { return dot(cos(p),sin(p.yzx)); }\nfloat fbm(vec3 p)\n{\n  float result = 0.;\n  float a = .5;\n  for (float i = 0.; i < 3.; ++i)\n  {\n    p += result;\n    p.z += iTime*.2;\n    result += abs(gyroid(p/a)*a);\n    a /= 2.;\n  }\n  return result;\n}\n\nfloat map(vec3 p)\n{\n  float dist = 100.;\n  \n  p.xz *= rot(iTime * .2);\n  p.xy *= rot(iTime * .1);\n  vec3 q = p;\n  \n  p = abs(p)-1.3;\n  dist = max(p.x, max(p.y, p.z));\n  dist -= fbm(q)*.2;\n  dist = abs(dist)-.03;\n  \n  return dist * .5;\n}\n\nvec3 getResult(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 color = vec3(smoothstep(1., -1., length(uv)));\n    \n    vec3 pos = vec3(0,0,7);\n    vec3 ray = normalize(vec3(uv, -1.5));\n    float total = 0.;\n    float shade = 0.;\n    for (float i = 100.; i > 0.; --i)\n    {\n        float dist = map(pos);\n        if (dist < .001)\n        {\n            shade += 0.1;\n            dist = 0.002;\n        }\n        if (total > 10.) return color;\n        total += dist;\n        pos += ray * dist;\n    }\n\n    if (total < 10.)\n    {\n        color = 0.5 + 0.5 * cos(vec3(1,2,3)*5.5+shade);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(getResult(fragCoord),1.0);\n}"
        },
        "ripple": {
            "title": "Ripple",
            "src": "uniform float time;\nuniform float rippleAmount; // @type float\n\n// @return uv-coordinate\n// @param uvIn uv-coordinate\nvec2 main(vec2 uvIn) {\n  vec2 p = -1.0 + 2.0 * uvIn;\n  float len = length(p);\n  return uvIn + (p/len)*sin(len*12.0-time*4.0)*0.1 * rippleAmount;\n}"
        },
        "sparklez": {
            "title": "Sparklez™",
            "src": "uniform float sparkleIntensity; // @@Slider default=.2 min=0 max=1\nuniform float sparkleBrightness; // @@Slider default=5 min=0 max=10\n//Based on https://www.youtube.com/watch?v=3CycKKJiwis\n\nfloat random(vec2 par){\n    return fract(sin(dot(par.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 random2(vec2 par){\n    float rand = random(par);\n    return vec2(rand, random(par+rand));\n}\n\n// @param fragCoord uv-coordinate\n// @return color\nvec4 upstreamColor(vec2 fragCoord);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //The ratio of the width and height of the screen\n    float widthHeightRatio = iResolution.x/iResolution.y;\n\n    float t = iTime * 0.01;\n    float dist = 0.0;\n    float layers = 16.0;\n    float scale = 32.0;\n    float depth;\n    float phase;\n    float rotationAngle = iTime * -0.01;\n\n    vec2 offset;\n    vec2 local_uv;\n    vec2 index;\n    vec2 pos;\n    vec2 seed;\n    vec2 centre = vec2(0.5, 0.5);\n\n    mat2 rotation = mat2(cos(rotationAngle), -sin(rotationAngle),\n    sin(rotationAngle),  cos(rotationAngle));\n\n    for(float i = 0.0; i < layers; i++){\n        depth = fract(i/layers + t);\n\n        //Move centre in a circle depending on the depth of the layer\n        centre.x = 0.5 + 0.1 * cos(t) * depth;\n        centre.y = 0.5 + 0.1 * sin(t) * depth;\n\n        //Get uv from the fragment coordinates, rotation and depth\n        uv = centre-fragCoord/iResolution.xy;\n        uv.y /= widthHeightRatio;\n        uv *= rotation;\n        uv *= mix(scale, 0.0, depth);\n\n        //The local cell\n        index = floor(uv);\n\n        //Local cell seed;\n        seed = 20.0 * i + index;\n\n        //The local cell coordinates\n        local_uv = fract(i + uv) - 0.5;\n\n        //Get a random position for the local cell\n        pos = 1.8 * (random2(seed) - 0.5);\n\n        //Get a random phase\n        phase = 128.0 * random(seed);\n\n        //Get distance to the generated point, add fading to distant points\n        //Add the distance to the sum\n        dist += pow(abs(1.0-length(local_uv-pos)), 50.0 + 20.0 * sin(phase + 8.0 * iTime))\n        * min(1.0, depth*2.0) * sparkleIntensity;\n\n    }\n    fragColor = upstreamColor(fragCoord) + vec4(vec3(dist),1.0) * sparkleBrightness;\n}"
        },
        "thatSAllFolks": {
            "title": "That's all, folks!",
            "src": "// That's All Folks\nuniform float time;\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\nuniform BeatInfo beatInfo; // @@baaahs.BeatLink:BeatInfo\n\nuniform float ringSpeed; // @@Slider default=10. min=-10 max=20\nuniform float ringDensity; // @@Slider default=60. min=10 max=120\nuniform float ringFade; // @@Slider default=.5 min=0 max=1\n\n// @param fragCoord uv-coordinate\n// @return color\nvec4 upstreamColor(vec2 fragCoord);\n\n// @return color\n// @param uvIn uv-coordinate\n// @param inColor color\nvec4 main(vec2 uvIn) {\n    vec4 inColor = upstreamColor(uvIn);\n    vec2 p = uvIn - .5;\n    float directMod = sin(time * 0.01);\n    float d = mix(\n        1. - ringFade,\n        1.,\n        sin(-length(p) * ringDensity * (0.8+ beatInfo.intensity * 0.2) + time * ringSpeed)\n    );\n    return vec4(inColor.rgb * d, 1.0);\n}"
        },
        "zigZag": {
            "title": "Zig Zag",
            "src": "// Zig Zag\n\nuniform float time;\n// uniform float zig; // @type float\nuniform float frequency;// @@Slider default=10. min=0 max=20\nuniform float depth;// @@Slider default=0.1 min=0.0 max=0.2\n\nstruct BeatInfo {\n    float beat;\n    float bpm;\n    float intensity;\n    float confidence;\n};\nuniform BeatInfo beatInfo;// @@baaahs.BeatLink:BeatInfo\n\n// @return uv-coordinate\n// @param uvIn uv-coordinate\nvec2 main(vec2 uvIn) {\n    vec2 p = -1.0 + 2.0 * uvIn;\n    float len = p.x / 16.;\n    int y = int(uvIn.y * 10.);\n\n    return vec2(uvIn.x, uvIn.y + sin(uvIn.x * frequency + time * 10.) * depth);\n}"
        },
        "rotateTwist": {
            "title": "Rotate & Twist",
            "src": "uniform float rotation; // @@Slider min=-3.14159 max=3.14159 default=0\nuniform float twist; // @@Slider min=-16 max=16 default=0\n\n// @param uvIn uv-coordinate\n// @return uv-coordinate\nvec2 main(vec2 uvIn) {\n    vec2 uv = uvIn - .5;\n    float dist = length(uv) * twist;\n    float theta = rotation + dist;\n    return vec2(\n        cos(theta) * uv.x - sin(theta) * uv.y,\n        sin(theta) * uv.x + cos(theta) * uv.y\n    ) + .5;\n}"
        }
    },
    "patches": {
        "xyProjection-patch": {
            "shaderId": "xyProjection",
            "incomingLinks": {
                "modelInfo": {
                    "type": "feed",
                    "feedId": "modelInfo"
                },
                "pixelLocation": {
                    "type": "feed",
                    "feedId": "pixelLocation"
                }
            }
        },
        "darkness-patch": {
            "shaderId": "darkness",
            "incomingLinks": {}
        },
        "hsb-patch": {
            "shaderId": "hsb",
            "incomingLinks": {
                "hueShift": {
                    "type": "feed",
                    "feedId": "hueShiftSlider"
                },
                "brightness": {
                    "type": "feed",
                    "feedId": "brightnessSlider"
                },
                "inColor": {
                    "type": "stream",
                    "stream": "main"
                },
                "saturation": {
                    "type": "feed",
                    "feedId": "saturationSlider"
                }
            },
            "priority": 10
        },
        "squarezzz-patch": {
            "shaderId": "squarezzz",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "speed": {
                    "type": "feed",
                    "feedId": "speedSlider"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "complexTrippyShit1-patch": {
            "shaderId": "complexTrippyShit1",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "baaahzebra-patch": {
            "shaderId": "baaahzebra",
            "incomingLinks": {
                "uv": {
                    "type": "stream",
                    "stream": "main"
                },
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "speed": {
                    "type": "feed",
                    "feedId": "speedSlider2"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                }
            }
        },
        "orangeSnowflake-patch": {
            "shaderId": "orangeSnowflake",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "speed": {
                    "type": "feed",
                    "feedId": "speedSlider"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "pulsiness": {
                    "type": "feed",
                    "feedId": "pulsinessSlider"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "acidAtTheDisco-patch": {
            "shaderId": "acidAtTheDisco",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "speed": {
                    "type": "feed",
                    "feedId": "speedSlider"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "pulsiness": {
                    "type": "feed",
                    "feedId": "pulsinessSlider"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "plasma-patch": {
            "shaderId": "plasma",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "wobblyColorGrid-patch": {
            "shaderId": "wobblyColorGrid",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "center": {
                    "type": "feed",
                    "feedId": "center"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "gadzooks-patch": {
            "shaderId": "gadzooks",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "mouse": {
                    "type": "stream",
                    "stream": "main"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "faeriePulse-patch": {
            "shaderId": "faeriePulse",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "yasQueen-patch": {
            "shaderId": "yasQueen",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "mouse": {
                    "type": "stream",
                    "stream": "main"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "circularDependency-patch": {
            "shaderId": "circularDependency",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "fireball-patch": {
            "shaderId": "fireball",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "conflagration": {
                    "type": "feed",
                    "feedId": "conflagrationSlider"
                }
            }
        },
        "blueHearts-patch": {
            "shaderId": "blueHearts",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "blueSClues-patch": {
            "shaderId": "blueSClues",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iMouse": {
                    "type": "stream",
                    "stream": "main"
                }
            }
        },
        "checkerboard-patch": {
            "shaderId": "checkerboard",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "checkerboardSize": {
                    "type": "feed",
                    "feedId": "checkerboardSizeSlider"
                }
            }
        },
        "danceyCubes-patch": {
            "shaderId": "danceyCubes",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "mysterNumber": {
                    "type": "feed",
                    "feedId": "mysterNumberSlider"
                }
            }
        },
        "plaid-patch": {
            "shaderId": "plaid",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "quiver-patch": {
            "shaderId": "quiver",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "twist": {
                    "type": "feed",
                    "feedId": "twistSlider"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "spaceRings-patch": {
            "shaderId": "spaceRings",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "waves-patch": {
            "shaderId": "waves",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "frequency": {
                    "type": "feed",
                    "feedId": "frequencySlider"
                }
            }
        },
        "huerthquake-patch": {
            "shaderId": "huerthquake",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "solidColor-patch": {
            "shaderId": "solidColor",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "color": {
                    "type": "feed",
                    "feedId": "colorColorPicker"
                },
                "sparkliness": {
                    "type": "feed",
                    "feedId": "sparklinessSlider"
                },
                "gl_FragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "colorBrightness": {
                    "type": "feed",
                    "feedId": "colorBrightnessSlider"
                }
            }
        },
        "sunsetClouds-patch": {
            "shaderId": "sunsetClouds",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iChannel0": {
                    "type": "feed",
                    "feedId": "pixelCoordsTexture"
                },
                "iMouse": {
                    "type": "stream",
                    "stream": "main"
                }
            }
        },
        "oceanClouds-patch": {
            "shaderId": "oceanClouds",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "electricEelUniverse-patch": {
            "shaderId": "electricEelUniverse",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "rainbows-patch": {
            "shaderId": "rainbows",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                }
            }
        },
        "voronoi-patch": {
            "shaderId": "voronoi",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iChannel0": {
                    "type": "feed",
                    "feedId": "pixelCoordsTexture"
                }
            }
        },
        "voxelEdges-patch": {
            "shaderId": "voxelEdges",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iMouse": {
                    "type": "stream",
                    "stream": "main"
                }
            }
        },
        "octagrams-patch": {
            "shaderId": "octagrams",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "randomSin-patch": {
            "shaderId": "randomSin",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "diveToCloud-patch": {
            "shaderId": "diveToCloud",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "sincos3d-patch": {
            "shaderId": "sincos3d",
            "incomingLinks": {
                "U": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "iMouse": {
                    "type": "stream",
                    "stream": "main"
                }
            }
        },
        "midCentury-patch": {
            "shaderId": "midCentury",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "monitorsAndFractalLife-patch": {
            "shaderId": "monitorsAndFractalLife",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "mouse": {
                    "type": "stream",
                    "stream": "main"
                },
                "resolution": {
                    "type": "stream",
                    "stream": "main"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "discoteq2-patch": {
            "shaderId": "discoteq2",
            "incomingLinks": {
                "I": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "devilGlass-patch": {
            "shaderId": "devilGlass",
            "incomingLinks": {
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                }
            }
        },
        "ripple-patch": {
            "shaderId": "ripple",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "uvIn": {
                    "type": "stream",
                    "stream": "main"
                },
                "rippleAmount": {
                    "type": "feed",
                    "feedId": "rippleAmountSlider"
                }
            }
        },
        "sparklez-patch": {
            "shaderId": "sparklez",
            "incomingLinks": {
                "iTime": {
                    "type": "feed",
                    "feedId": "time"
                },
                "fragCoord": {
                    "type": "stream",
                    "stream": "main"
                },
                "iResolution": {
                    "type": "feed",
                    "feedId": "resolution"
                },
                "sparkleIntensity": {
                    "type": "feed",
                    "feedId": "sparkleIntensitySlider"
                },
                "upstreamColor": {
                    "type": "stream",
                    "stream": "main"
                },
                "sparkleBrightness": {
                    "type": "feed",
                    "feedId": "sparkleBrightnessSlider"
                }
            },
            "priority": 15
        },
        "thatSAllFolks-patch": {
            "shaderId": "thatSAllFolks",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "uvIn": {
                    "type": "stream",
                    "stream": "main"
                },
                "ringSpeed": {
                    "type": "feed",
                    "feedId": "ringSpeedSlider"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "ringDensity": {
                    "type": "feed",
                    "feedId": "ringDensitySlider"
                },
                "upstreamColor": {
                    "type": "stream",
                    "stream": "main"
                },
                "ringFade": {
                    "type": "feed",
                    "feedId": "ringFadeSlider"
                }
            }
        },
        "zigZag-patch": {
            "shaderId": "zigZag",
            "incomingLinks": {
                "time": {
                    "type": "feed",
                    "feedId": "time"
                },
                "uvIn": {
                    "type": "stream",
                    "stream": "main"
                },
                "depth": {
                    "type": "feed",
                    "feedId": "depthSlider"
                },
                "beatInfo": {
                    "type": "feed",
                    "feedId": "beatInfo"
                },
                "frequency": {
                    "type": "feed",
                    "feedId": "frequencySlider2"
                }
            }
        },
        "rotateTwist-patch": {
            "shaderId": "rotateTwist",
            "incomingLinks": {
                "uvIn": {
                    "type": "stream",
                    "stream": "main"
                },
                "rotation": {
                    "type": "feed",
                    "feedId": "rotationSlider"
                },
                "twist": {
                    "type": "feed",
                    "feedId": "twistSlider2"
                }
            },
            "priority": 1
        }
    },
    "controls": {
        "shaderControls": {
            "type": "baaahs.Core:ButtonGroup",
            "title": "Shader Controls",
            "showTitle": true,
            "buttonIds": []
        },
        "vacuity": {
            "type": "baaahs.Core:Vacuity",
            "title": "Vacuity"
        },
        "shaders": {
            "type": "baaahs.Core:ButtonGroup",
            "title": "Shaders",
            "direction": "Vertical",
            "showTitle": true,
            "buttonIds": []
        },
        "squarezzz": {
            "type": "baaahs.Core:Button",
            "title": "[🐑] Squarezzz",
            "patchIds": [
                "squarezzz-patch"
            ]
        },
        "complexTrippyShit1": {
            "type": "baaahs.Core:Button",
            "title": "[🐑] Complex Trippy Shit #1",
            "patchIds": [
                "complexTrippyShit1-patch"
            ]
        },
        "baaahzebra": {
            "type": "baaahs.Core:Button",
            "title": "[🐑] BAAAHZebra",
            "patchIds": [
                "baaahzebra-patch"
            ]
        },
        "orangeSnowflake": {
            "type": "baaahs.Core:Button",
            "title": "Orange Snowflake",
            "patchIds": [
                "orangeSnowflake-patch"
            ]
        },
        "acidAtTheDisco": {
            "type": "baaahs.Core:Button",
            "title": "Acid at the Disco",
            "patchIds": [
                "acidAtTheDisco-patch"
            ]
        },
        "plasma": {
            "type": "baaahs.Core:Button",
            "title": "Plasma",
            "patchIds": [
                "plasma-patch"
            ]
        },
        "wobblyColorGrid": {
            "type": "baaahs.Core:Button",
            "title": "Wobbly Color Grid",
            "patchIds": [
                "wobblyColorGrid-patch"
            ]
        },
        "gadzooks": {
            "type": "baaahs.Core:Button",
            "title": "Gadzooks",
            "patchIds": [
                "gadzooks-patch"
            ]
        },
        "faeriePulse": {
            "type": "baaahs.Core:Button",
            "title": "Faerie Pulse",
            "patchIds": [
                "faeriePulse-patch"
            ]
        },
        "yasQueen": {
            "type": "baaahs.Core:Button",
            "title": "Yas Queen",
            "patchIds": [
                "yasQueen-patch"
            ]
        },
        "circularDependency": {
            "type": "baaahs.Core:Button",
            "title": "Circular Dependency",
            "patchIds": [
                "circularDependency-patch"
            ]
        },
        "fireball": {
            "type": "baaahs.Core:Button",
            "title": "Fireball",
            "patchIds": [
                "fireball-patch"
            ]
        },
        "blueHearts": {
            "type": "baaahs.Core:Button",
            "title": "Blue Hearts",
            "patchIds": [
                "blueHearts-patch"
            ]
        },
        "blueSClues": {
            "type": "baaahs.Core:Button",
            "title": "Blue's Clues",
            "patchIds": [
                "blueSClues-patch"
            ]
        },
        "checkerboard": {
            "type": "baaahs.Core:Button",
            "title": "Checkerboard",
            "patchIds": [
                "checkerboard-patch"
            ]
        },
        "danceyCubes": {
            "type": "baaahs.Core:Button",
            "title": "Dancey Cubes",
            "patchIds": [
                "danceyCubes-patch"
            ]
        },
        "plaid": {
            "type": "baaahs.Core:Button",
            "title": "Plaid",
            "patchIds": [
                "plaid-patch"
            ]
        },
        "quiver": {
            "type": "baaahs.Core:Button",
            "title": "Quiver",
            "patchIds": [
                "quiver-patch"
            ]
        },
        "spaceRings": {
            "type": "baaahs.Core:Button",
            "title": "Space Rings",
            "patchIds": [
                "spaceRings-patch"
            ]
        },
        "waves": {
            "type": "baaahs.Core:Button",
            "title": "Waves",
            "patchIds": [
                "waves-patch"
            ]
        },
        "huerthquake": {
            "type": "baaahs.Core:Button",
            "title": "Huerthquake",
            "patchIds": [
                "huerthquake-patch"
            ]
        },
        "solidColor": {
            "type": "baaahs.Core:Button",
            "title": "Solid Color",
            "patchIds": [
                "solidColor-patch"
            ]
        },
        "sunsetClouds": {
            "type": "baaahs.Core:Button",
            "title": "Sunset Clouds",
            "patchIds": [
                "sunsetClouds-patch"
            ]
        },
        "oceanClouds": {
            "type": "baaahs.Core:Button",
            "title": "Ocean Clouds",
            "patchIds": [
                "oceanClouds-patch"
            ]
        },
        "electricEelUniverse": {
            "type": "baaahs.Core:Button",
            "title": "Electric Eel Universe",
            "patchIds": [
                "electricEelUniverse-patch"
            ]
        },
        "rainbows": {
            "type": "baaahs.Core:Button",
            "title": "Rainbows",
            "patchIds": [
                "rainbows-patch"
            ]
        },
        "voronoi": {
            "type": "baaahs.Core:Button",
            "title": "Voronoi",
            "patchIds": [
                "voronoi-patch"
            ]
        },
        "voxelEdges": {
            "type": "baaahs.Core:Button",
            "title": "Voxel Edges",
            "patchIds": [
                "voxelEdges-patch"
            ]
        },
        "octagrams": {
            "type": "baaahs.Core:Button",
            "title": "Octagrams",
            "patchIds": [
                "octagrams-patch"
            ]
        },
        "randomSin": {
            "type": "baaahs.Core:Button",
            "title": "Random Sin",
            "patchIds": [
                "randomSin-patch"
            ]
        },
        "diveToCloud": {
            "type": "baaahs.Core:Button",
            "title": "Dive to Cloud",
            "patchIds": [
                "diveToCloud-patch"
            ]
        },
        "sincos3d": {
            "type": "baaahs.Core:Button",
            "title": "sincos 3d",
            "patchIds": [
                "sincos3d-patch"
            ]
        },
        "midCentury": {
            "type": "baaahs.Core:Button",
            "title": "MidCentury",
            "patchIds": [
                "midCentury-patch"
            ]
        },
        "monitorsAndFractalLife": {
            "type": "baaahs.Core:Button",
            "title": "monitors and fractal_life",
            "patchIds": [
                "monitorsAndFractalLife-patch"
            ]
        },
        "discoteq2": {
            "type": "baaahs.Core:Button",
            "title": "Discoteq 2",
            "patchIds": [
                "discoteq2-patch"
            ]
        },
        "devilGlass": {
            "type": "baaahs.Core:Button",
            "title": "Devil Glass",
            "patchIds": [
                "devilGlass-patch"
            ]
        },
        "effects": {
            "type": "baaahs.Core:ButtonGroup",
            "title": "Effects",
            "direction": "Vertical",
            "showTitle": true,
            "allowMultiple": true,
            "buttonIds": []
        },
        "ripple": {
            "type": "baaahs.Core:Button",
            "title": "Ripple",
            "patchIds": [
                "ripple-patch"
            ]
        },
        "sparklez": {
            "type": "baaahs.Core:Button",
            "title": "Sparklez™",
            "patchIds": [
                "sparklez-patch"
            ]
        },
        "thatSAllFolks": {
            "type": "baaahs.Core:Button",
            "title": "That's all, folks!",
            "patchIds": [
                "thatSAllFolks-patch"
            ]
        },
        "zigZag": {
            "type": "baaahs.Core:Button",
            "title": "Zig Zag",
            "patchIds": [
                "zigZag-patch"
            ]
        },
        "rotateTwist": {
            "type": "baaahs.Core:Button",
            "title": "Rotate & Twist",
            "patchIds": [
                "rotateTwist-patch"
            ]
        },
        "globalControls": {
            "type": "baaahs.Core:ButtonGroup",
            "title": "Global Controls",
            "showTitle": true,
            "buttonIds": []
        },
        "brightness": {
            "type": "baaahs.Core:Slider",
            "title": "Brightness",
            "initialValue": 0.15,
            "maxValue": 0.75,
            "controlledFeedId": "brightnessSlider"
        },
        "saturation": {
            "type": "baaahs.Core:Slider",
            "title": "Saturation",
            "maxValue": 1.25,
            "controlledFeedId": "saturationSlider"
        },
        "hueShift": {
            "type": "baaahs.Core:Slider",
            "title": "Hue Shift",
            "maxValue": 2,
            "controlledFeedId": "hueShiftSlider"
        },
        "visualizer": {
            "type": "baaahs.Core:Visualizer"
        }
    },
    "feeds": {
        "modelInfo": {
            "type": "baaahs.Core:ModelInfo"
        },
        "pixelLocation": {
            "type": "baaahs.Core:PixelLocation"
        },
        "hueShiftSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Hue Shift",
            "initialValue": 1,
            "minValue": 0,
            "maxValue": 2
        },
        "brightnessSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Brightness",
            "initialValue": 0.15,
            "minValue": 0,
            "maxValue": 0.75
        },
        "saturationSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Saturation",
            "initialValue": 1,
            "minValue": 0,
            "maxValue": 1.25
        },
        "time": {
            "type": "baaahs.Core:Time"
        },
        "speedSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Speed",
            "initialValue": 3,
            "minValue": 1,
            "maxValue": 5
        },
        "resolution": {
            "type": "baaahs.Core:Resolution"
        },
        "beatInfo": {
            "type": "baaahs.BeatLink:BeatInfo"
        },
        "speedSlider2": {
            "type": "baaahs.Core:Slider",
            "title": "Speed",
            "initialValue": 5,
            "minValue": 0,
            "maxValue": 10
        },
        "pulsinessSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Pulsiness",
            "initialValue": 3,
            "minValue": 1,
            "maxValue": 5
        },
        "center": {
            "type": "baaahs.Core:XyPad",
            "title": "Center"
        },
        "conflagrationSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Conflagration",
            "initialValue": 15,
            "minValue": 5,
            "maxValue": 20
        },
        "checkerboardSizeSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Checkerboard Size",
            "initialValue": 0.125,
            "minValue": 0.001,
            "maxValue": 1
        },
        "mysterNumberSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Myster Number",
            "initialValue": 1,
            "minValue": 0,
            "maxValue": 1
        },
        "twistSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Twist",
            "initialValue": 0.2,
            "minValue": -4,
            "maxValue": 4
        },
        "frequencySlider": {
            "type": "baaahs.Core:Slider",
            "title": "Frequency",
            "initialValue": 15,
            "minValue": 3.14,
            "maxValue": 25
        },
        "colorColorPicker": {
            "type": "baaahs.Core:ColorPicker",
            "title": "Color",
            "initialValue": -13434625
        },
        "sparklinessSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Sparkliness",
            "initialValue": 0.02,
            "minValue": 0,
            "maxValue": 0.5
        },
        "colorBrightnessSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Color Brightness",
            "initialValue": 0.75,
            "minValue": 0,
            "maxValue": 1
        },
        "pixelCoordsTexture": {
            "type": "baaahs.Core:PixelCoordsTexture"
        },
        "rippleAmountSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Ripple Amount",
            "initialValue": 1,
            "minValue": 0,
            "maxValue": 1
        },
        "sparkleIntensitySlider": {
            "type": "baaahs.Core:Slider",
            "title": "Sparkle Intensity",
            "initialValue": 1,
            "minValue": 0,
            "maxValue": 2
        },
        "sparkleBrightnessSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Sparkle Brightness",
            "initialValue": 0.5,
            "minValue": 0,
            "maxValue": 4
        },
        "ringSpeedSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Ring Speed",
            "initialValue": 10,
            "minValue": -15,
            "maxValue": 20
        },
        "ringDensitySlider": {
            "type": "baaahs.Core:Slider",
            "title": "Ring Density",
            "initialValue": 60,
            "minValue": 10,
            "maxValue": 120
        },
        "ringFadeSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Ring Fade",
            "initialValue": 0.5,
            "minValue": 0,
            "maxValue": 1
        },
        "depthSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Depth",
            "initialValue": 0.1,
            "minValue": 0,
            "maxValue": 0.2
        },
        "frequencySlider2": {
            "type": "baaahs.Core:Slider",
            "title": "Frequency",
            "initialValue": 10,
            "minValue": 0,
            "maxValue": 20
        },
        "rotationSlider": {
            "type": "baaahs.Core:Slider",
            "title": "Rotation",
            "initialValue": 0,
            "minValue": -6.28,
            "maxValue": 6.28
        },
        "twistSlider2": {
            "type": "baaahs.Core:Slider",
            "title": "Twist",
            "initialValue": 0,
            "minValue": -1,
            "maxValue": 1
        },
        "fixtureInfo": {
            "type": "baaahs.Core:FixtureInfo"
        }
    },
    "version": 10
}