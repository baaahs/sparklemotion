{"title":"Beach Rave","patches":[{"shaderInstanceIds":["cylindricalProjection-inst","darkness-inst","brightness-inst","saturation-inst","flipY-inst"],"surfaces":{"name":"All Surfaces"}}],"eventBindings":[],"controlLayout":{"Scenes":["control"],"Patches":["control2"],"More Controls":["colorColorPickerControl","brightnessSliderControl","saturationSliderControl"]},"scenes":[{"title":"Pleistocene","patches":[],"eventBindings":[],"controlLayout":{},"patchSets":[{"title":"Red Yellow Green","patches":[{"shaderInstanceIds":["glslHueTestPattern-inst"],"surfaces":{"name":"All Surfaces"}}],"eventBindings":[],"controlLayout":{}},{"title":"Fire","patches":[{"shaderInstanceIds":["fireBall-inst"],"surfaces":{"name":"All Surfaces"}}],"eventBindings":[],"controlLayout":{"Patches":["intensitySliderControl"]}},{"title":"Checkerboard","patches":[{"shaderInstanceIds":["checkerboard-inst"],"surfaces":{"name":"All Surfaces"}}],"eventBindings":[],"controlLayout":{"Patches":["checkerboardSizeSliderControl"]}},{"title":"Wobbly Checkerboard","patches":[{"shaderInstanceIds":["checkerboard-inst","ripple-inst"],"surfaces":{"name":"All Surfaces"}}],"eventBindings":[],"controlLayout":{"Patches":["checkerboardSizeSliderControl"]}},{"title":"White","patches":[{"shaderInstanceIds":["untitledPaintShader-inst"],"surfaces":{"name":"All Surfaces"}}],"eventBindings":[],"controlLayout":{}}]},{"title":"Beotch","patches":[],"eventBindings":[],"controlLayout":{},"patchSets":[{"title":"Blue Aqua Green","patches":[{"shaderInstanceIds":["anotherGlslHueTestPattern-inst"],"surfaces":{"name":"All Surfaces"}}],"eventBindings":[],"controlLayout":{}},{"title":"Gaia's Orgasm","patches":[{"shaderInstanceIds":["untitledPaintShader2-inst"],"surfaces":{"name":"All Surfaces"}}],"eventBindings":[],"controlLayout":{}},{"title":"Fire Dancer","patches":[{"shaderInstanceIds":["untitledPaintShader3-inst"],"surfaces":{"name":"All Surfaces"}}],"eventBindings":[],"controlLayout":{}},{"title":"Circular Dependency","patches":[{"shaderInstanceIds":["untitledPaintShader4-inst"],"surfaces":{"name":"All Surfaces"}}],"eventBindings":[],"controlLayout":{}},{"title":"Huenami","patches":[{"shaderInstanceIds":["huenami-inst"],"surfaces":{"name":"All Surfaces"}}],"eventBindings":[],"controlLayout":{}},{"title":"Sunset","patches":[{"shaderInstanceIds":["sunset-inst"],"surfaces":{"name":"All Surfaces"}}],"eventBindings":[],"controlLayout":{}}]}],"layouts":{"panelNames":["Scenes","Patches","More Controls","Preview","Controls"],"map":{"default":{"rootNode":{"direction":"row","splitPercentage":70,"first":{"direction":"column","splitPercentage":20,"first":"Scenes","second":{"direction":"column","splitPercentage":60,"first":"Patches","second":"More Controls"}},"second":{"direction":"column","splitPercentage":20,"first":"Preview","second":"Controls"}}}}},"shaders":{"cylindricalProjection":{"title":"Cylindrical Projection","type":"Projection","src":"// Cylindrical Projection\n// !SparkleMotion:internal\n\nuniform sampler2D pixelCoordsTexture;\n\nstruct ModelInfo {\n    vec3 center;\n    vec3 extents;\n};\nuniform ModelInfo modelInfo;\n\nconst float PI = 3.141592654;\n\nvec2 project(vec3 pixelLocation) {\n    vec3 pixelOffset = pixelLocation - modelInfo.center;\n    vec3 normalDelta = normalize(pixelOffset);\n    float theta = atan(abs(normalDelta.z), normalDelta.x); // theta in range [-π,π]\n    if (theta < 0.0) theta += (2.0f * PI);                 // theta in range [0,2π)\n    float u = theta / (2.0f * PI);                         // u in range [0,1)\n    float v = (pixelOffset.y + modelInfo.extents.y / 2.0f) / modelInfo.extents.y;\n    return vec2(u, v);\n}\n\nvec2 main(vec2 rasterCoord) {\n    int rasterX = int(rasterCoord.x);\n    int rasterY = int(rasterCoord.y);\n    \n    vec3 pixelCoord = texelFetch(pixelCoordsTexture, ivec2(rasterX, rasterY), 0).xyz;\n    return project(pixelCoord);\n}"},"darkness":{"title":"Darkness","type":"Paint","src":"void main(void) {\n    gl_FragColor = vec4(0., 0., 0., 1.);\n}"},"brightness":{"title":"Brightness","type":"Filter","src":"uniform float brightness; // @@Slider min=0 max=1.25 default=1\n\nvec4 main(vec4 inColor) {\n    vec4 clampedColor = clamp(inColor, 0., 1.);\n    return vec4(clampedColor.rgb * brightness, clampedColor.a);\n}"},"saturation":{"title":"Saturation","type":"Filter","src":"uniform float saturation; // @@Slider min=0 max=1.25 default=1\n\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 main(vec4 inColor) {\n    if (saturation == 1.) return inColor;\n\n    vec4 clampedColor = clamp(inColor, 0., 1.);\n    vec3 hsv = rgb2hsv(clampedColor.rgb);\n    hsv.y *= saturation;\n    return vec4(hsv2rgb(hsv), clampedColor.a);\n}"},"flipY":{"title":"Flip Y","type":"Distortion","src":"vec2 main(vec2 uvIn) {\n  return vec2(uvIn.x, 1. - uvIn.y);\n}"},"glslHueTestPattern":{"title":"GLSL Hue Test Pattern","type":"Paint","src":"uniform vec2 resolution;\nvoid main(void) {\n    gl_FragColor = vec4(gl_FragCoord.xy / resolution, 0.0, 1.0);\n}"},"fireBall":{"title":"Fire Ball","type":"Paint","src":"// Fire Ball\n// From http://glslsandbox.com/e#61108.0\n\n// Fire ball by David Robles\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//#extension GL_OES_standard_derivatives : enable\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n\nconst float PI = 3.141592;\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x);\n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n    vec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat circleShape(vec2 coord, vec2 pos){\n    float dist = distance(coord, pos);\n    return clamp(   log(dist*(15.+4.*noise(vec2(time*.8))))  ,0.,1.);\n}\n\nvec2 sineWave(vec2 p){\n    float Ax = .05;\n    float wx = 1.50 * PI;\n    float x = sin(wx * p.x) * Ax * sin(noise(vec2(time)));\n\n    float Ay = .05;\n    float wy = PI * 10.;\n    float y = sin(wy*p.y) * Ay * noise(vec2(time));\n\n    return vec2(p.x + x, p.y + y);\n}\n\nvoid main( void ) {\n\n    vec2 pos = gl_FragCoord.xy / resolution.xy;\n    vec2 uv = pos;\n\n    uv += vec2(-.5, -.5);\n    uv *= vec2(2.3, 1.3);\n\n    float luz = clamp(1.05 - (pow(uv.x, 2.) + pow(uv.y * 1.6, 6.))*2., 0., 1.);\n    //vec3 color = vec3(0.3059, 0.1922, 0.0431);\n    vec3 color = vec3(0.7333, 0.2902, 0.0314);\n    //vec3 color = vec3(0.3882, 0.1686, 0.251);\n    float grad = circleShape(sineWave(pos), vec2(.5, .32));\n\n    float ruido = 0.;\n\n    pos *= 5.0;\n    float xoff = 1.05;\n    float yoff = 2.1;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    ruido = 0.7500*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido += 0.2500*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido += 0.5000*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido += 0.1250*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n\n\n    ruido = 0.5 + 0.5*ruido;\n    ruido = clamp(ruido, 0., 1.);\n\n    /////////////////////////////////////////////////////////////\n    pos = uv;\n    pos *= 3.0;\n    float ruido2 = 0.;\n    xoff = 1.5;\n    yoff = 1.5;\n    m = mat2( -2.1,  .5, -.5,  2.1 );\n    ruido2 = 0.2500*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido2 += 0.5000*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido2 += 0.1250*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n    ruido2 += 0.0625*noise(vec2(abs(pos.x-time*xoff), abs(pos.y-time*yoff))); pos = m*pos;\n\n    ruido2 = 0.5 + 0.5*ruido2;\n    ruido2 = clamp(ruido2, 0., 1.);\n\n    float f = 0.;\n    f += 1.0 - ( (1.0-luz) / (ruido2 + 0.001) );\n    f /= grad;\n    f /= ruido;\n\n    gl_FragColor = vec4(f*color*luz*(.5-.5*noise(vec2(time*.8))), 1.);\n    //gl_FragColor = vec4(color/grad, 1.);\n\n}"},"checkerboard":{"title":"Checkerboard","type":"Paint","src":"uniform float checkerboardSize = 10.0; // @@Slider min=.001 max=1 default=.1\nuniform float beat;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = floor(fragCoord / checkerboardSize + beat);\n    vec3 patternMask = vec3(mod(pos.x + mod(pos.y, 2.0), 2.0));\n    fragColor = vec4(patternMask.x + beat, patternMask.yz, 1.);\n}"},"ripple":{"title":"Ripple","type":"Distortion","src":"uniform float time;\n\nvec2 main(vec2 uvIn) {\n  vec2 p = -1.0 + 2.0 * uvIn;\n  float len = length(p);\n  return uvIn + (p/len)*cos(len*12.0-time*4.0)*0.03;\n}"},"untitledPaintShader":{"title":"Untitled Paint Shader","type":"Paint","src":"uniform float time;\n\nvoid main(void) {\n    gl_FragColor = vec4(gl_FragCoord.x, gl_FragCoord.y, mod(time, 1.), 1.);\n}"},"anotherGlslHueTestPattern":{"title":"Another GLSL Hue Test Pattern","type":"Paint","src":"uniform vec2 resolution;\nuniform float redness;\nvoid main(void) {\n    gl_FragColor = vec4(redness, gl_FragCoord.xy / resolution, 1.0);\n}"},"untitledPaintShader2":{"title":"Untitled Paint Shader","type":"Paint","src":"// Gaia's Orgasm\n// From http://glslsandbox.com/e#46597\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n//from https://www.shadertoy.com/view/4dl3zn\n\nvoid main( void ) {\n\n\tvec2 uv = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;\n\tuv.x *=  resolution.x / resolution.y;\n\n    // background\n\tvec3 color = vec3(0.8 + 0.2*uv.y);\n\n    // bubbles\n\tfor( int i=0; i<40; i++ )\n\t{\n        // bubble seeds\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * resolution.x / resolution.y;\n\n        // buble size, position and color\n\t\tfloat rad = 0.1 + 0.5*siz;\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*time*(0.2+0.8*siz),1.0));\n\t\tfloat dis = length( uv - pos );\n\t\tvec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\n\n        // render\n\t\tfloat f = length(uv-pos)/rad;\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\n\t}\n\n    // vigneting\n\tcolor *= sqrt(1.5-0.5*length(uv));\n\n\tgl_FragColor = vec4(color,1.0);\n}\n"},"untitledPaintShader3":{"title":"Untitled Paint Shader","type":"Paint","src":"// Fire Dancer\n// From http://glslsandbox.com/e#55301\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// SPARKLEMOTION GADGET: Slider {name: \"Scale\", initialValue: 10.0, minValue: 0.0, maxValue: 100.0}\nuniform float scale;\n\nuniform float time;\nuniform vec2 resolution;\nuniform float beat;\n\n#define N 6\n\nvoid main( void ) {\n\tvec2 v= (gl_FragCoord.xy-(resolution*0.5))/min(resolution.y,resolution.x)*scale;\n\tfloat t=time * 0.4,r=0.0;\n\tfor (int i=0;i<N;i++){\n\t\tfloat d=(3.14159265 / float(N))*(float(i)*5.0);\n\t\tr+=length(vec2(v.x,v.y))+0.01;\n\t\tv = vec2(v.x+cos(v.y+cos(r)+d)+cos(t),v.y-sin(v.x+cos(r)+d)+sin(t));\n\t}\n        r = (sin(r*0.1)*0.5)+0.5;\n\tr = pow(r, 128.0);\n\tgl_FragColor = vec4(r + beat / 5.,pow(max(r-0.75,0.0)*4.0,2.0),pow(max(r-0.875,0.0)*8.0,4.0), 1.0 );\n//\tgl_FragColor = vec4(gl_FragCoord.x, gl_FragCoord.y, r, 1.0);\n}\n"},"untitledPaintShader4":{"title":"Untitled Paint Shader","type":"Paint","src":"// Circular Dependency\n// From http://glslsandbox.com/e#56705\n\n/*\n * Original shader from: https://www.shadertoy.com/view/Wtf3zl\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\nuniform float timeAdjust;\n\n// shadertoy emulation\n#define iTime (time + timeAdjust)\n#define iResolution resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x*= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.5);\n    float d =length(uv)*20.;\n    float a = atan(uv.y, uv.x);\n    col.r = smoothstep(0.1, .2, abs(mod(d+iTime, 2.)-1.));\n\tcol.g = col.r*floor(mod(d*.5+.5+iTime*.5, 2.));\n    float f = smoothstep(-.1, .1,sin(a*3.+(sin(iTime*.5)*2.)*d-iTime));\n    col.rg = mix(1.-col.rg, col.rg, f);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n"},"huenami":{"title":"Huenami","type":"Paint","src":"// Huenami\n// From: http://glslsandbox.com/e#44092.1\n\n// amiga internal vendetta or coppermaster style plasma;\n// gigatron base source from here;\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform float timeAdjust;\nuniform vec2 resolution;\n#define t (time + timeAdjust / 4.)\nvoid main( void ) {\n    vec2 p=gl_FragCoord.xy/resolution;\n\n\n    p= floor(p*32.)/32.;\n    vec3 a=vec3(0.5, 0.5, 0.5);\n    vec3 b=vec3(0.5, 0.5, 0.5);\n    vec3 c=vec3(t/4., t*0.4, t/2.);\n    vec3 d=vec3(0.0, 0.33, 0.67);\n    vec3 col = b+a*sin(8.0*(c+p.y+sin(p.x+p.x+t) ));\n    //col*= b+a*sin(10.0*(c+p.y+cos(p.y+p.y+t) ));\n\n    gl_FragColor=vec4(col, 1.0);\n}\n"},"sunset":{"title":"Sunset","type":"Paint","src":"// - rand sea from https://www.shadertoy.com/view/Ms2SD1\n// - various from https://github.com/erichlof/THREE.js-PathTracing-Renderer/blob/gh-pages/js/pathTracingCommon.js\n\nprecision mediump float;\nstruct Ray { vec3 origin; vec3 direction; };\n\n#define INFINITY         999.9e16\n#define PI               3.14159265358979323\n#define PHI              1.61803398874989484820459\n#define EARTH_RADIUS      6360000.0\n#define ATMOSPHERE_RADIUS 6420000.0\n#define SUN_POWER 20.0\n#define SKY_SAMPLES 16\n#define SUN_SAMPLES 8\n#define SUNTIME (iTime/2.0)\n#define EPSILON_NRM (0.1 / iResolution.x)\n    \nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 2.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\nconst int NUM_STEPS = 8;\n\nfloat hash( vec2 p ) {\n  return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);}\n\n\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+iTime)*freq,choppy);\n    \td += sea_octave((uv-iTime)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+iTime)*freq,choppy);\n    \td += sea_octave((uv-iTime)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(Ray ray, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ray.origin + ray.direction * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ray.origin + ray.direction * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ray.origin + ray.direction * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1){\n\tfloat discrim = b * b - 4.0 * a * c;\n\tif (discrim < 0.0) return false;\n\tfloat rootDiscrim = sqrt(discrim);\n\tfloat q = (b > 0.0) ? -0.5 * (b + rootDiscrim) : -0.5 * (b - rootDiscrim); \n\tt1 = q / a; \n\tt0 = c / q;\n\treturn true;\n}\n\nbool PlanetSphereIntersect( Ray ray, float rad, vec3 pos, inout float t0, inout float t1 ) {\n\tvec3 L = ray.origin - pos;\n\tfloat a = dot( ray.direction, ray.direction );\n\tfloat b = 2.0 * dot( ray.direction, L );\n\tfloat c = dot( L, L ) - (rad * rad);\n\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\t\n\tfloat temp;\n\tif (t0 > t1)\n\t{\n\t\ttemp = t0;\n\t\tt0 = t1;\n\t\tt1 = temp;\n\t}\n\treturn true;\n}\n\nvec3 calculateSkySphereColor(Ray r, float tmin, float tmax, vec3 sunDirection){ \n  vec3 earthCenter = vec3(0, -1.0 * EARTH_RADIUS, 0);\n\tvec3 betaR = vec3(3.8e-6, 13.5e-6, 33.1e-6); \n\tvec3 betaM = vec3(21e-6);  \n\tfloat Hr = 7994.0;\n\tfloat Hm = 1200.0;\n\tfloat t0, t1; \n\tif (!PlanetSphereIntersect(r, ATMOSPHERE_RADIUS, earthCenter, t0, t1) || t1 < 0.0) return vec3(0); \n\tif (t0 > tmin && t0 > 0.0) tmin = t0; \n\tif (t1 < tmax) tmax = t1; \n  float segmentLength = (tmax - tmin) / float(SKY_SAMPLES); \n\tfloat tCurrent = tmin; \n\tvec3 sumR = vec3(0); // rayleigh contribution\n\tvec3 sumM = vec3(0); // mie contribution \n\tfloat opticalDepthR = 0.0;\n\tfloat opticalDepthM = 0.0; \n\tfloat mu = dot(r.direction, sunDirection); // mu in the paper which is the cosine of the angle between the sun direction and the ray direction \n\tfloat phaseR = 3.0 / (16.0 * PI) * (1.0 + mu * mu); \n\tfloat g = 0.76; \n\tfloat phaseM = 3.0 / (8.0 * PI) * ((1.0 - g * g) * (1.0 + mu * mu)) / ((2.0 + g * g) * pow(max(0.0, 1.0 + g * g - 2.0 * g * mu), 1.5)); \n\n  for (int i = 0; i < SKY_SAMPLES; ++i) { \n\t\tvec3 samplePosition = r.origin + (tCurrent) * r.direction; \n\t\tfloat height = length(samplePosition - earthCenter) - EARTH_RADIUS; \n\n\t\t// compute optical depth for light\n\t\tfloat hr = exp(-height / Hr) * segmentLength; \n\t\tfloat hm = exp(-height / Hm) * segmentLength; \n\t\topticalDepthR += hr; \n\t\topticalDepthM += hm; \n\n\t\t// light optical depth\n\t\tfloat t0Light, t1Light; \n\t\tPlanetSphereIntersect(Ray(samplePosition, sunDirection), ATMOSPHERE_RADIUS, earthCenter, t0Light, t1Light); \n\t\tfloat segmentLengthLight = t1Light / float(SUN_SAMPLES);\n\t\tfloat tCurrentLight = 0.0; \n\t\tfloat opticalDepthLightR = 0.0;\n\t\tfloat opticalDepthLightM = 0.0; \n\t\tint jCounter = 0; \n    for (int j = 0; j < SUN_SAMPLES; ++j) { \n\t\t\tvec3 samplePositionLight = samplePosition + (tCurrentLight) * sunDirection; \n\t\t\tfloat heightLight = length(samplePositionLight - earthCenter) - EARTH_RADIUS; \n\t\t\tif (heightLight < 0.0) break;\n\t\t\tjCounter += 1;\n\t\t\topticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight; \n\t\t\topticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight; \n\t\t\ttCurrentLight += segmentLengthLight; \n\t\t} \n\t\tif (jCounter == SUN_SAMPLES) { \n\t\t\tvec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM); \n\t\t\tvec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z)); \n\t\t\tsumR += attenuation * hr; \n\t\t\tsumM += attenuation * hm; \n\t\t} \n\t\ttCurrent += segmentLength; \n  } \n\n  vec3 attenuate_vec = (sumR * betaR * phaseR + sumM * betaM * phaseM) * SUN_POWER;\n  //return attenuate_vec;\n  // color map\n  if (attenuate_vec.x < 1.413) { \n    attenuate_vec.x = pow(attenuate_vec.x * 0.38317, 1.0 / 2.2); \n  } else { \n    attenuate_vec.x = 1.0 - exp(-attenuate_vec.x);\n  } \n  if (attenuate_vec.y < 1.413){\n    attenuate_vec.y = pow(attenuate_vec.y * 0.38317, 1.0 / 2.2); \n  } else { \n    attenuate_vec.y = 1.0 - exp(-attenuate_vec.y);\n  } \n  if (attenuate_vec.z < 1.413){\n    attenuate_vec.z = pow(attenuate_vec.z * 0.38317, 1.0 / 2.2); \n  } else { \n    attenuate_vec.z = 1.0 - exp(-attenuate_vec.z);\n  }\n  return attenuate_vec;\n} \n\nvec3 calculateSkyColor(Ray r, float tmin, float tmax, vec3 sunDirection){\n  return calculateSkySphereColor(r, tmin, tmax, sunDirection);\n}\n\nvec3 perspectiveCameraRayDirection(in vec2 pixelCoord) {\n  vec2 pixelPos = (pixelCoord) * 2.0 - 1.0;\n  vec3 camRight   = vec3( 1.0,  0.0,  0.0);\n  vec3 camUp      = vec3( 0.0,  1.0,  0.0);\n  vec3 camForward = vec3(0.0, 0.0, 1.0);\n  return normalize( pixelPos.x * camRight + pixelPos.y * camUp + camForward );\n}\n\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.5;\n        \n    vec3 reflected = calculateSkyColor(Ray(vec3(0), reflect(eye,n)), 0.0, INFINITY, l);    \n    vec3 base = SEA_BASE * calculateSkyColor(Ray(vec3(0), vec3(1.0)), 0.0, INFINITY, l); // SEA_BASE\n    vec3 refracted = base + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n\n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.01, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    color += vec3(specular(n,l,eye,20.0))* 0.8 * reflected;\n    return color;\n}\n\nvec4 pixel(in vec2 uv ) {\n  Ray r = Ray( vec3(0.0, 3.0,  -15.0), perspectiveCameraRayDirection(uv));\n  vec3 sunDir = normalize(vec3(0,abs(cos(SUNTIME))/2.0 - 0.2, abs(sin(SUNTIME)) * 2.0));\n  vec3 sky = calculateSkyColor(r, 0.0, INFINITY, sunDir);\n  vec3 p;\n  heightMapTracing(r,p);\n  vec3 dist = p - r.origin;\n  vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n\n  vec3 waves = mix(\n        sky,\n        getSeaColor(p,n, sunDir, r.direction, dist),\n    \tpow(smoothstep(0.0,-0.5,r.direction.y),0.5));\n\n  return vec4(waves, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 aa = 0.25 / iResolution.xy;\n  fragColor = pixel(uv); \n  fragColor += pixel(uv + aa);\n  fragColor *= 0.5;  \n}\n"}},"shaderInstances":{"cylindricalProjection-inst":{"shaderId":"cylindricalProjection","incomingLinks":{"pixelCoordsTexture":{"type":"datasource","dataSourceId":"pixelCoordsTexture"},"modelInfo":{"type":"datasource","dataSourceId":"modelInfo"}},"shaderChannel":"main","priority":0.0},"darkness-inst":{"shaderId":"darkness","incomingLinks":{"gl_FragCoord":{"type":"shader-channel","shaderChannel":"main"}},"shaderChannel":"main","priority":0.0},"brightness-inst":{"shaderId":"brightness","incomingLinks":{"gl_FragColor":{"type":"shader-channel","shaderChannel":"main"},"brightness":{"type":"datasource","dataSourceId":"brightnessSlider"}},"shaderChannel":"main","priority":0.0},"saturation-inst":{"shaderId":"saturation","incomingLinks":{"gl_FragColor":{"type":"shader-channel","shaderChannel":"main"},"saturation":{"type":"datasource","dataSourceId":"saturationSlider"}},"shaderChannel":"main","priority":0.0},"flipY-inst":{"shaderId":"flipY","incomingLinks":{"gl_FragCoord":{"type":"shader-channel","shaderChannel":"main"}},"shaderChannel":"main","priority":0.0},"glslHueTestPattern-inst":{"shaderId":"glslHueTestPattern","incomingLinks":{"gl_FragCoord":{"type":"shader-channel","shaderChannel":"main"},"resolution":{"type":"datasource","dataSourceId":"resolution"}},"shaderChannel":"main","priority":0.0},"fireBall-inst":{"shaderId":"fireBall","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"gl_FragCoord":{"type":"shader-channel","shaderChannel":"main"},"resolution":{"type":"datasource","dataSourceId":"resolution"}},"shaderChannel":"main","priority":0.0},"checkerboard-inst":{"shaderId":"checkerboard","incomingLinks":{"beat":{"type":"datasource","dataSourceId":"beatLink"},"sm_FragCoord":{"type":"shader-channel","shaderChannel":"main"},"checkerboardSize":{"type":"datasource","dataSourceId":"checkerboardSizeSlider"}},"shaderChannel":"main","priority":0.0},"ripple-inst":{"shaderId":"ripple","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"gl_FragCoord":{"type":"shader-channel","shaderChannel":"main"}},"shaderChannel":"main","priority":0.0},"untitledPaintShader-inst":{"shaderId":"untitledPaintShader","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"gl_FragCoord":{"type":"shader-channel","shaderChannel":"main"}},"shaderChannel":"main","priority":0.0},"anotherGlslHueTestPattern-inst":{"shaderId":"anotherGlslHueTestPattern","incomingLinks":{"gl_FragCoord":{"type":"shader-channel","shaderChannel":"main"},"redness":{"type":"datasource","dataSourceId":"rednessSlider"},"resolution":{"type":"datasource","dataSourceId":"resolution"}},"shaderChannel":"main","priority":0.0},"untitledPaintShader2-inst":{"shaderId":"untitledPaintShader2","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"gl_FragCoord":{"type":"shader-channel","shaderChannel":"main"},"resolution":{"type":"datasource","dataSourceId":"resolution"}},"shaderChannel":"main","priority":0.0},"untitledPaintShader3-inst":{"shaderId":"untitledPaintShader3","incomingLinks":{"beat":{"type":"datasource","dataSourceId":"beatLink"},"time":{"type":"datasource","dataSourceId":"time"},"scale":{"type":"datasource","dataSourceId":"beatLink"},"gl_FragCoord":{"type":"shader-channel","shaderChannel":"main"},"resolution":{"type":"datasource","dataSourceId":"resolution"}},"shaderChannel":"main","priority":0.0},"untitledPaintShader4-inst":{"shaderId":"untitledPaintShader4","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"mouse":{"type":"datasource","dataSourceId":"mouseXyPad"},"timeAdjust":{"type":"datasource","dataSourceId":"beatLink"},"gl_FragCoord":{"type":"shader-channel","shaderChannel":"main"},"resolution":{"type":"datasource","dataSourceId":"resolution"}},"shaderChannel":"main","priority":0.0},"huenami-inst":{"shaderId":"huenami","incomingLinks":{"time":{"type":"datasource","dataSourceId":"time"},"timeAdjust":{"type":"datasource","dataSourceId":"beatLink"},"gl_FragCoord":{"type":"shader-channel","shaderChannel":"main"},"resolution":{"type":"datasource","dataSourceId":"resolution"}},"shaderChannel":"main","priority":0.0},"sunset-inst":{"shaderId":"sunset","incomingLinks":{"iTime":{"type":"datasource","dataSourceId":"time"},"sm_FragCoord":{"type":"shader-channel","shaderChannel":"main"},"iResolution":{"type":"datasource","dataSourceId":"resolution"}},"shaderChannel":"main","priority":0.0}},"controls":{"control":{"type":"baaahs.Core:ButtonGroup","title":"Scenes"},"control2":{"type":"baaahs.Core:ButtonGroup","title":"Patches"},"colorColorPickerControl":{"type":"baaahs.Core:Gadget","gadget":{"type":"baaahs.Core:ColorPicker","title":"Color","initialValue":-1},"controlledDataSourceId":"colorColorPicker"},"brightnessSliderControl":{"type":"baaahs.Core:Gadget","gadget":{"type":"baaahs.Core:Slider","title":"Brightness","initialValue":1.0,"minValue":0.0,"maxValue":1.25,"stepValue":null},"controlledDataSourceId":"brightnessSlider"},"saturationSliderControl":{"type":"baaahs.Core:Gadget","gadget":{"type":"baaahs.Core:Slider","title":"Saturation","initialValue":1.0,"minValue":0.0,"maxValue":1.25,"stepValue":null},"controlledDataSourceId":"saturationSlider"},"intensitySliderControl":{"type":"baaahs.Core:Gadget","gadget":{"type":"baaahs.Core:Slider","title":"Intensity","initialValue":1.0,"minValue":0.0,"maxValue":1.0,"stepValue":null},"controlledDataSourceId":"intensitySlider"},"checkerboardSizeSliderControl":{"type":"baaahs.Core:Gadget","gadget":{"type":"baaahs.Core:Slider","title":"Checkerboard Size","initialValue":0.1,"minValue":0.001,"maxValue":1.0,"stepValue":null},"controlledDataSourceId":"checkerboardSizeSlider"}},"dataSources":{"pixelCoordsTexture":{"type":"baaahs.Core:PixelCoordsTexture"},"modelInfo":{"type":"baaahs.Core:ModelInfo"},"brightnessSlider":{"type":"baaahs.Core:Slider","title":"Brightness","initialValue":1.0,"minValue":0.0,"maxValue":1.25,"stepValue":null},"saturationSlider":{"type":"baaahs.Core:Slider","title":"Saturation","initialValue":1.0,"minValue":0.0,"maxValue":1.25,"stepValue":null},"colorColorPicker":{"type":"baaahs.Core:ColorPicker","title":"Color","initialValue":-1},"resolution":{"type":"baaahs.Core:Resolution"},"time":{"type":"baaahs.Core:Time"},"intensitySlider":{"type":"baaahs.Core:Slider","title":"Intensity","initialValue":1.0,"minValue":0.0,"maxValue":1.0,"stepValue":null},"beatLink":{"type":"baaahs.BeatLink:BeatLink"},"checkerboardSizeSlider":{"type":"baaahs.Core:Slider","title":"Checkerboard Size","initialValue":0.1,"minValue":0.001,"maxValue":1.0,"stepValue":null},"rednessSlider":{"type":"baaahs.Core:Slider","title":"Redness","initialValue":1.0,"minValue":0.0,"maxValue":1.0,"stepValue":null},"mouseXyPad":{"type":"baaahs.Core:XyPad","title":"Mouse","varPrefix":"mouseVec2"}}}